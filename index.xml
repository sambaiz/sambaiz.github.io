<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>http://sambaiz.net/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>2017-06-25 00:35:00 &#43;0900 JST</updated>

    
      
        <item>
          <title>fluentdのAggregatorをELBで負荷分散し、Blue/Green Deploymentする</title>
          <link>http://sambaiz.net/article/113/</link>
          <pubDate>Sun, 25 Jun 2017 00:35:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/113/</guid>
          <description>

&lt;h2 id=&#34;elbでの負荷分散&#34;&gt;ELBでの負荷分散&lt;/h2&gt;

&lt;p&gt;BeanstalkでAggregatrorを立ち上げた。TCPの24224(設定による)が
通るようにEC2,ELBのSGとリスナーの設定をする必要があって、
ELBのSGのアウトバウンドの設定が見落とされがち。ELBのクロスゾーン分散は有効になっている。&lt;/p&gt;

&lt;p&gt;まず、ELBに3台、それぞれ別のAZ(1b, 1c, 1d)に配置されている状態でログを送り始めるとそれぞれ均等にログが届いた。
その状態から4台(1b * 2, 1c, 1d)にすると、2つのインスタンス(1b, 1c)のみに均等にログが届くようになった。
4台になると(1b, 1c)と(1b, 1d)に分けられてELBのノードがそれらの組に紐づいたということだと思う。
各ノードにはDNSラウンドロビンするようになっている。実際restartすると今度は別の組の方に送られた。&lt;/p&gt;

&lt;p&gt;では、なぜ一度送り始めると同じ方にしか飛ばないかというと、forwardプラグインの&lt;a href=&#34;http://docs.fluentd.org/v0.12/articles/out_forward#expirednscache&#34;&gt;expire_dns_cache&lt;/a&gt;がデフォルトでnilになっていて、
heartbeatが届いている間は&lt;a href=&#34;https://github.com/fluent/fluentd/blob/v0.14.18/lib/fluent/plugin/out_forward.rb#L688&#34;&gt;無期限にDNSキャッシュする&lt;/a&gt;ようになっているため。これに0(キャッシュしない)か秒数を指定すると、
その間隔で他の組のインスタンスにもログが届くようになった。
&lt;code&gt;expire_dns_cache&lt;/code&gt;しなくても複数のインスタンスからラウンドロビンされるため全体でいえば分散される。&lt;/p&gt;

&lt;h2 id=&#34;elbでのheartbeat&#34;&gt;ELBでのheartbeat&lt;/h2&gt;

&lt;p&gt;ELB配下のEC2を全て落としても&lt;a href=&#34;https://github.com/fluent/fluentd/blob/v0.14.18/lib/fluent/plugin/out_forward.rb#L665&#34;&gt;heartbeat&lt;/a&gt;に失敗しないため、standyに移行せずELBのバックエンド接続エラーになってログがロストしてしまうようだ。
ログにも出ず、以下のようにactive-standbyの設定をしてもstandbyに移行しない。
全てのインスタンスが同時に落ちるというのは滅多に起きないだろうけど、少なくとも検知できるようにはしておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;server&amp;gt;
    name td1
    host autoscale-td1.us-east-1.elasticbeanstalk.com
    port 24224
&amp;lt;/server&amp;gt;
&amp;lt;server&amp;gt;
    name td2
    host autoscale-td2.us-east-1.elasticbeanstalk.com
    port 24224
    standby
&amp;lt;/server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;blue-green-deployment&#34;&gt;Blue/Green Deployment&lt;/h2&gt;

&lt;p&gt;Blue-Green Deploymentというのは、2つの系を用意し、activeでない方にデプロイし、
スワップして反映させるもの。ダウンタイムなしで問題が起きた際にもすぐに切り戻すことができる。
スワップして向き先を変えるには&lt;code&gt;expire_dns_cache&lt;/code&gt;を設定する必要がある。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/elb-configuration-guide-1&#34;&gt;AWS ELBの社内向け構成ガイドを公開してみる 負荷分散編 – Cross-Zone Routingを踏まえて ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのMecanimでヒューマノイドアニメーションさせる</title>
          <link>http://sambaiz.net/article/112/</link>
          <pubDate>Tue, 20 Jun 2017 23:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/112/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://www.assetstore.unity3d.com/jp/#!/content/4696&#34;&gt;Space Robot Kyle&lt;/a&gt;を動かす。&lt;/p&gt;

&lt;h2 id=&#34;アバターの作成&#34;&gt;アバターの作成&lt;/h2&gt;

&lt;p&gt;Assetsの&lt;code&gt;Model/Robot Kyle&lt;/code&gt;を選択し、RigのAnimation TypeをHumanoidにすると、
自動的にボーン構造を解析して人型にマッピングしたアバターが設定される。
Configure Avatarで確認すると正しく設定されているようだ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-rig.png&#34; alt=&#34;アバター&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;モーションの設定&#34;&gt;モーションの設定&lt;/h2&gt;

&lt;p&gt;KyleのAnimatorのAnimationに設定するAnimation Controllerを作成する。
まずは2つCreate Stateし、それぞれMotionに適当なモーション(今回は&lt;a href=&#34;https://www.assetstore.unity3d.com/jp/#!/content/36286&#34;&gt;Fighter Pack Bundle FREE&lt;/a&gt;を使った)を設定し、
Make Transitionで相互に結ぶと、オレンジになっているデフォルトステートから交互にモーションする。
ステートには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/StateMachineBehaviour.html&#34;&gt;StateMachineBehaviour&lt;/a&gt;のScriptを設定することもできる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-animation.png&#34; alt=&#34;モーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次にParametersでモーションを変化させる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-animation2.png&#34; alt=&#34;分岐したモーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Animatorの左上、parametersタブからBoolのWalkを追加する。
そして片方のTransitionのConditionにWalkがfalse、もう片方にはWalkがtrueを追加すると、
状態によって違うモーションをするようになる。
ちなみに、AnyStateからConditionを設定したTransitionを設定すると、どこのStateからでもそれで遷移させることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-parameters.png&#34; alt=&#34;パラメータ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このParameterはこんな感じに値を設定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Update () {
	GetComponent&amp;lt;Animator&amp;gt; ().SetBool (&amp;quot;Walk&amp;quot;, Random.value &amp;lt; 0.5);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一部だけモーションさせる&#34;&gt;一部だけモーションさせる&lt;/h2&gt;

&lt;p&gt;人体の一部だけをモーションさせるにはAvatar Maskを使う。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-avatar-mask.png&#34; alt=&#34;Avatar Mask&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-avatar-mask-motion.png&#34; alt=&#34;Avatar Maskしたモーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Animationで複数のレイヤーを作成すれば、異なるMaskでそれぞれステートを持たせることができる。&lt;/p&gt;

&lt;h2 id=&#34;animation-override-controller&#34;&gt;Animation Override Controller&lt;/h2&gt;

&lt;p&gt;作ったAnimationを違うモーションで再利用することができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-override.png&#34; alt=&#34;Animator Override Controller&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>NorikraでログをJOINする</title>
          <link>http://sambaiz.net/article/111/</link>
          <pubDate>Thu, 15 Jun 2017 00:17:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/111/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/109/&#34;&gt;NorikraとFluentdで流れてきたログをリアルタイムに集計する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;適当なログを出すコードを書いた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/lottery-log&#34;&gt;sambaiz/lottery-log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは以下のようなlottery.logを出力し続け、数秒後に一定確率で同じuidのreceived.logを出力するもの。
広告的に言えば、lotteryがimpで、receivedがclickといった感じかな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lottery.log
{&amp;quot;ts&amp;quot;:1497453504.6818597,&amp;quot;uid&amp;quot;:&amp;quot;b18c0d98-19b2-4e37-8fc4-6b00a4b728c3&amp;quot;,&amp;quot;prize&amp;quot;:855,&amp;quot;isWin&amp;quot;:true}
// received.log
{&amp;quot;ts&amp;quot;:1497453515.932101,&amp;quot;uid&amp;quot;:&amp;quot;bc4f578f-4a5f-47f1-a4e0-1ef0b43c316e&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリはこんな感じ。一つはlotteryログとreceivedログをuidでJOINするもので、
received_rateの計算にはサブクエリも使っている。
received_rateの計算で分母に小さな値を足しているのはNaNやInfinityにならないようにするため。
receivedログは最大30秒遅れて出力されるため、40秒前までのreceivedログをwin:timeで見ている。
これをtime_batchにしてしまうと期待通りの結果にならないので注意。&lt;/p&gt;

&lt;p&gt;もう一つはJavaの関数でboolを0/1にして平均をとることでisWinがtrueである割合を出している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker exec norikra norikra-client query add lottery_agg &#39;
SELECT COUNT(*) as received_count, (COUNT(*) / (SELECT COUNT(*) + 0.00001 FROM lottery.win:time_batch(1 sec, 0).std:unique(uid))) as received_rate, AVG(prize) as prize_avg, SUM(prize) as prize_sum FROM lottery.win:time(40 sec).std:unique(uid) as a, received.win:time_batch(1 sec, 0).std:unique(uid) as b WHERE a.uid = b.uid&#39;

$ docker exec norikra norikra-client query add lottery_win_rate &#39;SELECT avg(Boolean.compare(isWin, false)) as win_rate FROM lottery.win:time_batch(1 sec)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、このクエリの結果をElasticsearchに送って可視化してみたのがこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type tail
  path /var/log/lottery.log
  pos_file /etc/td-agent/log.pos
  tag event.lottery
  format json
&amp;lt;/source&amp;gt;

&amp;lt;source&amp;gt;
  @type tail
  path /var/log/received.log
  pos_file /etc/td-agent/log.pos
  tag event.received
  format json
&amp;lt;/source&amp;gt;

&amp;lt;match event.*&amp;gt;
  @type   norikra
  norikra localhost:26571
  
  remove_tag_prefix event # event.*の部分が
  target_map_tag    yes   # targetになる

  &amp;lt;default&amp;gt;
    auto_field false 
  &amp;lt;/default&amp;gt;
&amp;lt;/match&amp;gt;

&amp;lt;source&amp;gt;
  @type   norikra
  norikra localhost:26571
  &amp;lt;fetch&amp;gt;
    method   event
    target   lottery_agg
    tag      string data.lottery_agg
    interval 1m
  &amp;lt;/fetch&amp;gt;
  &amp;lt;fetch&amp;gt;
    method   event
    target   lottery_win_rate
    tag      string data.lottery_win_rate
    interval 1m
  &amp;lt;/fetch&amp;gt;
&amp;lt;/source&amp;gt;

&amp;lt;match data.lottery_agg&amp;gt;
  @type elasticsearch
  host 172.31.5.20
  port 9200
  logstash_prefix lottery
  type_name lottery_agg
  logstash_format true
&amp;lt;/match&amp;gt;

&amp;lt;match data.lottery_win_rate&amp;gt;
  @type elasticsearch
  host 172.31.5.20
  port 9200
  logstash_prefix lottery
  type_name lottery_win_rate
  logstash_format true
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;received_rateを計算するときのウィンドウが1secと小さく、タイミングによってはreceivedの数がlotteryの数を上回ることがあるため1以下で絞っている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/111v.png&#34; alt=&#34;可視化したもの&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>VSでのネイティブプラグインのビルドからUnityでのWSAのビルドまでをバッチでする</title>
          <link>http://sambaiz.net/article/110/</link>
          <pubDate>Tue, 13 Jun 2017 00:32:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/110/</guid>
          <description>

&lt;h2 id=&#34;vsでのネイティブプラグインのビルド&#34;&gt;VSでのネイティブプラグインのビルド&lt;/h2&gt;

&lt;p&gt;VSが使っているビルドツール
&lt;a href=&#34;https://docs.microsoft.com/ja-jp/visualstudio/msbuild/msbuild&#34;&gt;MSBuild&lt;/a&gt;を使う。
VSのプロジェクトファイルにはMSBuildのXMLが含まれている。
これ自体はVSに依存していないため、単体で動かすこともできる。&lt;/p&gt;

&lt;p&gt;パスが通ってなかったらパスを通す。管理者権限が必要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild
&#39;MSBuild&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;別プロセスから適用されるので立ち上げ直すとパスが通っていることを確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild /version
Microsoft (R) Build Engine バージョン 15.1.1012.6693
Copyright (C) Microsoft Corporation.All rights reserved.

15.1.1012.6693
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドして&lt;code&gt;Assets\Plugins&lt;/code&gt;に配置する。これは前作ったBLEのネイティブプラグインのもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105/&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; git clone git@github.com:sambaiz/UnityBLE_UWP.git
&amp;gt; cd UnityBLE_UWP
&amp;gt; MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
&amp;gt; MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
&amp;gt; copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
&amp;gt; copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
&amp;gt; cd ..
&amp;gt; rmdir /S /Q UnityBLE_UWP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなエラーが出てきたらmscorlib.dllをインポートできていないのが原因のようで、
restoreしたらうまくいった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error CS0518: 定義済みの型 &#39;System.Object&#39; は定義、またはインポートされていません
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unityでのwsaのビルド&#34;&gt;UnityでのWSAのビルド&lt;/h2&gt;

&lt;p&gt;同様にUnityもパスが通ってなかったら通す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity
&#39;Unity&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files\Unity\Editor&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/BuildPipeline.BuildPlayer.html&#34;&gt;スクリプト&lt;/a&gt;
をAssets/Editorの中に置く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEditor;

public class Build {

    static void PerformBuild()
    {
        string[] scenes = { &amp;quot;Assets/main.unity&amp;quot; };
        BuildPipeline.BuildPlayer(scenes, &amp;quot;build&amp;quot;,
            BuildTarget.WSAPlayer, BuildOptions.None);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このstaticメソッドを&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/CommandLineArguments.html&#34;&gt;executeMethod&lt;/a&gt;
で渡してビルドする。Unityを開いたままだと失敗するので閉じる必要がある。&lt;/p&gt;

&lt;p&gt;この例だとbuildディレクトリに出力される。もし出力されなかったらEditorログを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity -quit -batchmode -executeMethod Build.PerformBuild
&amp;gt; type C:\Users\(username)\AppData\Local\Unity\Editor\Editor.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめたもの&#34;&gt;まとめたもの&lt;/h2&gt;

&lt;p&gt;ということでこんなバッチをUnityプロジェクトの直下に置いておくことにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:sambaiz/UnityBLE_UWP.git
cd UnityBLE_UWP
MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
cd ..
rmdir /S /Q UnityBLE_UWP

rmdir /S /Q build
Unity -quit -batchmode -executeMethod Build.PerformBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://sh-yoshida.hatenablog.com/entry/2017/05/27/012755&#34;&gt;MSBuildでコマンドラインからビルドする - 1.21 jigowatts&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>NorikraとFluentdで流れてきたログをリアルタイムに集計する</title>
          <link>http://sambaiz.net/article/109/</link>
          <pubDate>Sat, 10 Jun 2017 12:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/109/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://norikra.github.io/&#34;&gt;Norikra&lt;/a&gt;はTD社の&lt;a href=&#34;https://github.com/tagomoris&#34;&gt;tagomoris&lt;/a&gt;氏が作った、
スキーマレスのストリーミングデータを処理するOSS。&lt;/p&gt;

&lt;p&gt;モチベーションとしてはfluentdでElasticsearchにログを送って可視化していたのだけど、
流量が増えてきてピーク帯に耐えられなくなってしまったため、前もって集計してから送ることで流量を減らそうというもの。&lt;/p&gt;

&lt;h2 id=&#34;norikraを立ち上げてクエリを実行する&#34;&gt;Norikraを立ち上げてクエリを実行する&lt;/h2&gt;

&lt;p&gt;公式で紹介されているDockerイメージがあったのでこれで動かしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -e &amp;quot;TZ=Asia/Tokyo&amp;quot; -p 26578:26578 -p 26571:26571 -v `pwd`:/var/tmp/norikra:rw -d myfinder/docker-norikra norikra start --stats /var/tmp/norikra/stats.json -l /var/tmp/norikra 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほかの&lt;a href=&#34;https://github.com/norikra/norikra/blob/master/lib/norikra/cli.rb&#34;&gt;オプション&lt;/a&gt;として&lt;code&gt;-Xms&lt;/code&gt;や&lt;code&gt;-Xmx&lt;/code&gt;でJVMのヒープメモリの量を設定したり、Experimentalではあるけど&lt;code&gt;--shutoff&lt;/code&gt;でヒープメモリが一杯になる前に弾いて
OutOfMemoryを防ぐことができる。
また、Norikraのコアエンジンで使われているOSSの
&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E8%A4%87%E5%90%88%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E5%87%A6%E7%90%86&#34;&gt;CEP&lt;/a&gt;
(Complex event processing)エンジン、
&lt;a href=&#34;http://www.espertech.com/products/esper.php&#34;&gt;Esper&lt;/a&gt;
のパフォーマンスチューニングとして&lt;code&gt;--micro&lt;/code&gt;や&lt;code&gt;--small&lt;/code&gt;などを渡すこともできるけど試していない。&lt;/p&gt;

&lt;p&gt;公式サイトの例に従ってクライアントからデータを入れてクエリを実行してみる。&lt;/p&gt;

&lt;p&gt;まずはtargetをopenする。targetというのはスキーマレスのイベントストリームのこと。
ここで定義したフィールドは必須になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client target open www path:string status:integer referer:string agent:string userid:integer
$ norikra-client target list
TARGET	AUTO_FIELD
www	true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にクエリを追加する。一見普通のSQLのように見えるけど、EsperのクエリであるEPL(Event Processing Language)。
ただしSELECTしか使えないのも含めてクエリにいくらかの制限がある。&lt;/p&gt;

&lt;p&gt;このクエリでは&lt;code&gt;win:time_batch&lt;/code&gt;で10秒のWindowを定義し、eventをgroup byして、その数をeventとして出力する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client query add www.toppageviews &#39;SELECT count(*) AS cnt FROM www.win:time_batch(10 sec) WHERE path=&amp;quot;/&amp;quot; AND status=200&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eventを流す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/login&amp;quot;, &amp;quot;status&amp;quot;:301, &amp;quot;referer&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリの値をfetchする。送るのが遅くてgroup byされなかったけどこんな感じ。
eventがこなかったはじめのWindowは0が出力されるが、それ以降のWindowでは出力されない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client event fetch www.toppageviews
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 20:58:13&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:42:33&amp;quot;,&amp;quot;cnt&amp;quot;:1}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:42:43&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:13&amp;quot;,&amp;quot;cnt&amp;quot;:1}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:23&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:33&amp;quot;,&amp;quot;cnt&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとWeb-uiが用意されていて、クエリを追加したり、targetやクエリの一覧、メモリの使用量やサーバーログなどが取得できる。デフォルトでは26578ポート。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/109-norikra.png&#34; alt=&#34;web-ui&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;クエリ-epl-http-norikra-github-io-query-html&#34;&gt;&lt;a href=&#34;http://norikra.github.io/query.html&#34;&gt;クエリ(EPL)&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;windowなし&#34;&gt;Windowなし&lt;/h3&gt;

&lt;p&gt;上の例では&lt;code&gt;time_batch&lt;/code&gt;でWindowを定義したけど、定義しないクエリを追加してみる。
以下のようなクエリを登録し、再びeventを流してfetchすると流した分が全てとれる。
ただし、このようなクエリはfetchされないと大量のoutput eventが溜まる可能性がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT path, status AS cnt FROM www WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-nowin
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 23:06:12&amp;quot;,&amp;quot;cnt&amp;quot;:200,&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 23:09:10&amp;quot;,&amp;quot;cnt&amp;quot;:200,&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-time-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-time-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-time-batch&#34;&gt;win:time_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10 sec&lt;/code&gt;のように秒以外にも&lt;code&gt;msec&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;hour&lt;/code&gt;、どう使うか想像できないけど&lt;code&gt;year&lt;/code&gt;まで指定でき、
&lt;code&gt;10 minutes 30 seconds&lt;/code&gt;みたいに組み合わせることも&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl_clauses.html#epl-syntax-time-periods&#34;&gt;できる&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;また、第二引数にミリ秒を渡すと出力するタイミングを指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT count(*) AS cnt FROM www.win:time_batch(1min, 0L) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-tb-opts
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 00:43:00&amp;quot;,&amp;quot;cnt&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-ext-timed-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-ext-time-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-ext-time-batch&#34;&gt;win:ext_timed_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;来た時間ではなくフィールドのUNIXミリ秒を参照するWindow。時系列順にソートされている必要があって、
tagomoris氏いわく&lt;a href=&#34;https://twitter.com/tagomoris/status/486851407140507648&#34;&gt;おすすめしない&lt;/a&gt;とのこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT count(*) AS cnt FROM www.win:ext_timed_batch(timestamp, 1 min) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3, &amp;quot;timestamp&amp;quot;:1496852100000 }&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3, &amp;quot;timestamp&amp;quot;:1496852200000 }&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-ext_timed
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 01:19:02&amp;quot;,&amp;quot;cnt&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-length-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-length-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-length-batch&#34;&gt;win:length_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;event数のWindow。毎回渡した数ずつ集計できると思いきや、数が集まらなければfetchできず、
それ以上集まったらfetchできるようだ。使いづらいような気がする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT avg(userid) as nosense FROM www.win:length_batch(2) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat

$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat

$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:2}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:42:20&amp;quot;,&amp;quot;nosense&amp;quot;:2.0}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-length-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-length&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-length&#34;&gt;win:length&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;こっちは渡した数スライドして集計するもの。Windowなしのときと同様、大量に溜まる可能性がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT avg(userid) as nosense FROM www.win:length(2) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:5}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:4}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-len
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:11&amp;quot;,&amp;quot;nosense&amp;quot;:3.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:22&amp;quot;,&amp;quot;nosense&amp;quot;:2.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:32&amp;quot;,&amp;quot;nosense&amp;quot;:3.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:45&amp;quot;,&amp;quot;nosense&amp;quot;:4.5}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもいろいろあるし、JOINやサブクエリも使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/111/&#34;&gt;NorikraでログをJOINする - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fluentdとやり取りする&#34;&gt;fluentdとやり取りする&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/norikra/fluent-plugin-norikra&#34;&gt;fluent-plugin-norikra&lt;/a&gt;でNorikraサーバーにeventを送り、
eventを受け取ってファイルに出力する。&lt;/p&gt;

&lt;p&gt;c4.large(2コア,メモリ3.75GiB)でDockerでNorikraを立ち上げ、以下の設定でtd-agentを実行した。
&lt;code&gt;auto_field&lt;/code&gt;は来たeventのフィールドを自動でtargetに登録するかの設定で、
true(デフォルト)にするとどんなフィールドが来ているかNorikra上で確認することができる。
falseにしてもクエリで使う分は自動で登録される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type dummy
  dummy {&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;}
  tag event.dummy
  rate 1000
&amp;lt;/source&amp;gt;
   
&amp;lt;match event.*&amp;gt;
  @type   norikra
  norikra localhost:26571
  
  remove_tag_prefix event # event.*の部分が
  target_map_tag    yes   # targetになる

  &amp;lt;default&amp;gt;
    auto_field false 
  &amp;lt;/default&amp;gt;
&amp;lt;/match&amp;gt;

&amp;lt;source&amp;gt;
  @type   norikra
  norikra localhost:26571
  &amp;lt;fetch&amp;gt;
    method   event
    # norikra-client query add dummy_count_1sec &#39;SELECT COUNT(*) AS count FROM dummy.win:time_batch(1 sec)&#39;
    target   dummy_count_1sec
    tag      string data.dummy_count_1sec
 #  tag      field FIELDNAME : tag by value with specified field name in output event
    interval 1m
  &amp;lt;/fetch&amp;gt;
&amp;lt;/source&amp;gt;

&amp;lt;match data.*&amp;gt;
  @type file
  path /var/log/td-agent/dummy_count
  time_slice_format %Y%m%d%H
  time_slice_wait 10s
  time_format %Y%m%dT%H%M%S%z
  compress gzip
  symlink_path /var/log/td-agent/dummy_count
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Norikraのスループットは以下の要素が影響する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;number of targets
number of queries
how complex queries are
how complex UDFs are
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、目安としてはこんな感じらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 queries
2,000 events per seconds
5% usage of 4core CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1target、単純な1クエリなら秒間10000送ってみても問題なかった。
あまり現実的なケースではないけど限界を目指してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f dummy_count
20170609T212717+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212718+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212719+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212720+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212721+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212722+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212723+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212724+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212725+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212726+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 8256 root      20   0 1878m 249m  19m S 29.3  6.6   6:46.94 java
 9812 root      20   0  296m  68m 6288 S 20.0  1.8   2:38.08 ruby  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;秒間40000送ってみるとカウントがおかしい。
dummyの方の限界かと思ってnorikraを外してみたらおおよそ数が合ったので
Norikraサーバーかやり取りの部分で処理が追いついていないようだ。
一旦rateを下げてみたところ20000あたりを境目にこうなってしまった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f dummy_count
20170609T222018+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:31248}
20170609T222019+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:27468}
20170609T222020+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:35309}
20170609T222021+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:31944}
20170609T222022+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:22805}
20170609T222023+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:30716}
20170609T222024+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:33617}
20170609T222025+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:28740}
20170609T222026+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:32058}
20170609T222027+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:27253}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CPUの使用量をみてみると、ほぼ限界まで使用されていた。
fluentdはrubyの&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF%E3%83%AD%E3%83%83%E3%82%AF&#34;&gt;GIL&lt;/a&gt;
(Global Interpreter Lock = GVL(Giant VM Lock))のため同時に&lt;a href=&#34;https://docs.ruby-lang.org/ja/2.3.0/doc/spec=2fthread.html&#34;&gt;1ネイティブスレッドしか動かせず&lt;/a&gt;、1コアしかCPUを使えないが、
jrubyで動くNorikraは残りのコアを使うことができる。
今回はtargetもクエリも一つだし、データ量も小さいためかメモリにはまだ余裕があった。
ログのサイズやウィンドウサイズが大きければメモリを使う量が増えるため、実際のログをしばらく
流してどちらが問題になりそうか確認するべき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
11378 root      20   0  350m 111m 6336 S 96.1  3.0   1:53.03 ruby
8256 root      20   0 1892m 642m  19m S 84.2 17.1  34:36.38 java   
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HEAP MEMORY USED: 244MB (55.8%), COMMITTED: 437MB, MAX: 437MB
NON-HEAP MEMORY USED: 51MB (23.8%), COMMITTED: 81MB, MAX: 214MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1Gbps、1Mevent/sを超えるような高トラフィックではStormなどのフレームワークを使えとのこと。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdでKinesis streamsに送るときの性能確認</title>
          <link>http://sambaiz.net/article/108/</link>
          <pubDate>Mon, 05 Jun 2017 23:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/108/</guid>
          <description>

&lt;h2 id=&#34;localでのstreamsとproducerのbenchmark&#34;&gt;localでのstreamsとproducerのbenchmark&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;の
&lt;code&gt;make benchmark&lt;/code&gt;はlocalにDummyServerを&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis/blob/v1.1.3/benchmark/task.rake#L18&#34;&gt;立ち上げて&lt;/a&gt;送っている。&lt;/p&gt;

&lt;p&gt;空でもいいのでroleをつけておく必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/awslabs/aws-fluent-plugin-kinesis.git
$ cd aws-fluent-plugin-kinesis
$ yum install -y ruby-devel gcc
$ echo &#39;gem &amp;quot;io-console&amp;quot;&#39; &amp;gt;&amp;gt; Gemfile
$ make
$ make benchmark
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATEを指定しなければデフォルトで&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis/blob/v1.1.3/benchmark/task.rake#L19&#34;&gt;秒間1000レコード&lt;/a&gt;が送られる設定。
fluentdを起動してから10秒後にプロセスをkillし、そのレコード数などを出力している。&lt;/p&gt;

&lt;p&gt;t2.microでデフォルト(RATE=1000)で実行した結果がこれ。
固める分producerの方はややパフォーマンスが落ちる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 20, raw_records: 9400, records: 9400
bundle exec rake benchmark TYPE=producer
Results: requets: 14, raw_records: 1005, records: 8900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATE=3000のとき。producerではraw_recordsが1/100、リクエスト数は1/5。
streamsだとシャードを増やしていく必要があるけど、producerの方は当分大丈夫そうだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 57, raw_records: 27600, records: 27600
bundle exec rake benchmark TYPE=producer
Results: requets: 12, raw_records: 241, records: 25200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATE=10000のとき。raw_records, requestの圧縮率はさらに上がり、
パフォーマンスの差が大きくなってきている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 177, raw_records: 88000, records: 88000
bundle exec rake benchmark TYPE=producer
Results: requets: 26, raw_records: 385, records: 75000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実際にkinesis-streamsに送ってみる&#34;&gt;実際にkinesis streamsに送ってみる&lt;/h2&gt;

&lt;p&gt;ap-northeast-1でシャードは3のKinesis streamsにt2.microインスタンス1台から送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type dummy
  dummy {&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;}
  tag dummy
  rate 1000
&amp;lt;/source&amp;gt;

&amp;lt;source&amp;gt;
  @type monitor_agent
  bind 0.0.0.0
  port 24220
&amp;lt;/source&amp;gt;

&amp;lt;match **&amp;gt;
  @type kinesis_streams
  region ap-northeast-1
  stream_name test

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;秒間3000まではほとんどキューにたまらず送れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:24220/api/plugins.json | jq
{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 0,
      &amp;quot;buffer_total_queued_size&amp;quot;: 17500,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4000にするとそのうちretryが発生してしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
     &amp;quot;buffer_queue_length&amp;quot;: 60,
      &amp;quot;buffer_total_queued_size&amp;quot;: 56544178,
      &amp;quot;retry_count&amp;quot;: 5,
      &amp;quot;retry&amp;quot;: {
        &amp;quot;steps&amp;quot;: 5,
        &amp;quot;next_time&amp;quot;: &amp;quot;2017-06-05 14:05:38 +0000&amp;quot;
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たしかにスループットが超過している。スペック通りだ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/108.png&#34; alt=&#34;書き込みスループットの超過&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に30シャードにしてみる。一度にシャード数は倍から半分にしかできないので作り直し。&lt;/p&gt;

&lt;p&gt;これに秒間30000を送ってみると、キューにいくらか溜まった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 7,
      &amp;quot;buffer_total_queued_size&amp;quot;: 7752600,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに倍にして60シャード。これに秒間60000で送ってみる。キューに溜まるものの増え続けはしないのでなんとか送れてそうだ。
td-agentのプロセスがCPUを99%使っているので、このインスタンスではこの辺が限界かもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 15,
      &amp;quot;buffer_total_queued_size&amp;quot;: 16105807,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにus-east-1にも30シャードのStreamsを作成して30000送ってみたところ、キューに溜まる量が格段に増えた。
早くFirehoseやAnalyticsが東京リージョンにも来てほしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 50,
      &amp;quot;buffer_total_queued_size&amp;quot;: 52432436,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>td-agent2.3.5のfluentdが0.14系になってしまっているのでソースからビルドする</title>
          <link>http://sambaiz.net/article/107/</link>
          <pubDate>Sun, 04 Jun 2017 23:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/107/</guid>
          <description>&lt;blockquote&gt;
&lt;p&gt;追記(2016-06-25): 現在は普通に入れても0.12系の2.3.5-1が入るようになっている。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent2.sh | sh
$ td-agent --version
td-agent 0.14.16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0.12系じゃない！？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum list installed | grep td-agent
td-agent.x86_64                       2.3.5-0.el2017               @treasuredata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら2.3.5では0.14系になってしまっているよう。
そのあとにリリースされた2.3.5-1では直ってるみたいだけど、現時点ではrpmリポジトリに上がっていない。&lt;/p&gt;

&lt;p&gt;しょうがないのでソースからビルドすることにした。
いずれにせよ各環境で同じバージョンのビルドに合わせるべきだとは思う。
Beanstalk環境の場合、AMIに固めていたとしても非Beanstalk AMIではyum updateされてしまうので注意が必要だ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/106/&#34;&gt;BeanstalkでのパッケージのバージョンがAMIでのバージョンと異なる原因 - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前UbuntuでやったようにDockerでビルドする。今回はAmazon Linux向け。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/32/&#34;&gt;td-agentをビルドしてfluentdのバージョンを上げる - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/sambaiz/docker-td-agent-build-amazon-linux/&#34;&gt;https://hub.docker.com/r/sambaiz/docker-td-agent-build-amazon-linux/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM amazonlinux:2017.03

WORKDIR /tmp

RUN yum -y update &amp;amp;&amp;amp; \
    yum groupinstall -y &amp;quot;Development Tools&amp;quot; &amp;amp;&amp;amp; \
    yum install -y ruby23 ruby23-devel &amp;amp;&amp;amp; \
    gem install bundler io-console &amp;amp;&amp;amp; \
    git clone https://github.com/treasure-data/omnibus-td-agent

WORKDIR /tmp/omnibus-td-agent

RUN bundle install --binstubs &amp;amp;&amp;amp; \
    bin/gem_downloader core_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader plugin_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader ui_gems.rb &amp;amp;&amp;amp; \
    mkdir -p /opt/td-agent /var/cache/omnibus &amp;amp;&amp;amp; \
    bin/omnibus build td-agent2 &amp;amp;&amp;amp; \
    mv ./pkg/*.rpm /
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t amazon-linux-td-agent .
$ docker run --name altd -itd amazon-linux-td-agent sh
$ docker cp altd:/td-agent-2.3.5-1.el2017.x86_64.rpm .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはこれをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install -y redhat-lsb-core
$ rpm -ivh td-agent-2.3.5-1.el2017.x86_64.rpm 
$ td-agent --version
td-agent 0.12.36
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>BeanstalkでのパッケージのバージョンがAMIでのバージョンと異なる原因</title>
          <link>http://sambaiz.net/article/106/</link>
          <pubDate>Sun, 04 Jun 2017 23:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/106/</guid>
          <description>

&lt;h2 id=&#34;user-dataとは-http-docs-aws-amazon-com-ja-jp-awsec2-latest-userguide-user-data-html&#34;&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/user-data.html&#34;&gt;User-Dataとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;EC2インスタンス起動時に、シェルスクリプトを走らせたりcloud-initディレクティブを適用できる機能。
コンソールではインスタンスの詳細の設定の、高度な詳細のところから設定できる。&lt;/p&gt;

&lt;h2 id=&#34;beanstalkでのuser-data&#34;&gt;BeanstalkでのUser-Data&lt;/h2&gt;

&lt;p&gt;実はBeanstalkでも使われていて、CloudFormationで設定されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;    /bin/bash /tmp/ebbootstrap.sh &amp;quot;,

...

&amp;quot;Fn::FindInMap&amp;quot;: [
    &amp;quot;AWSEBOptions&amp;quot;,
    &amp;quot;options&amp;quot;,
    &amp;quot;UserDataScript&amp;quot;
]
&amp;quot; &amp;gt; /tmp/ebbootstrap.sh &amp;quot;,

...

&amp;quot;AWSEBOptions&amp;quot;: {
    &amp;quot;options&amp;quot;: {
        &amp;quot;UserDataScript&amp;quot;: &amp;quot;https://s3-ap-northeast-1.amazonaws.com/elasticbeanstalk-env-resources-ap-northeast-1/stalks/eb_node_js_4.0.1.90.2/lib/UserDataScript.sh&amp;quot;,
        &amp;quot;guid&amp;quot;: &amp;quot;f08557fc43ac&amp;quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このshellの中では、時計を同期させたり、awsebユーザーを作成したりするほかに、
非Beanstalk AMI(is_baked=false)ではyum updateが走るようになっている。
そのため、AMIでのバージョンとBeanstalkで立ち上がったときのバージョンが異なることがある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GUID=$7

function update_yum_packages
{
  if is_baked update_yum_packages_$GUID; then
    log yum update has already been done.
  else
    log Updating yum packages.
    yum --exclude=aws-cfn-bootstrap update -y || echo Warning: cannot update yum packages. Continue...
    mark_installed update_yum_packages_$GUID

    # Update system-release RPM package will reset the .repo files
    # Update the mirror list again after yum update
    update_mirror_list

    log Completed updating yum packages. 
  fi
}

function is_baked
{
	if [[ -f /etc/elasticbeanstalk/baking_manifest/$1 ]]; then
    true
	else
    false
	fi
}

function mark_installed
{
    mkdir -p /etc/elasticbeanstalk/baking_manifest/
    echo `date -u` &amp;gt; /etc/elasticbeanstalk/baking_manifest/$1-manifest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Beanstalk AMIでのログ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /var/log/messages | grep yum
[eb-cfn-init]: yum repo has already been locked to f08557fc43ac.
[eb-cfn-init]: yum update has already been done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非Beanstalk AMIでのログ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /var/log/messages | grep yum
[eb-cfn-init]: Completed yum repo version locking.
[eb-cfn-init]: Updating yum packages.
yum[1597]: Updated: *****
...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unity/UWPでBLEを扱うプラグインを作る</title>
          <link>http://sambaiz.net/article/105/</link>
          <pubDate>Sun, 04 Jun 2017 11:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/105/</guid>
          <description>&lt;p&gt;コードは&lt;a href=&#34;https://github.com/sambaiz/UnityBLE_UWP&#34;&gt;ここ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/aonishi/2013/12/04/unity-on-windows-8-1/&#34;&gt;この動画&lt;/a&gt;の
50:00あたりから説明があるように、
ビルドされたWSAが読むUWPのdllのほかに、
Unityエディタ上から読むための.NET Framework3.5のdllを用意する。
こうすることで実行環境ごとの違いをUnityコード上で気にしなくてもよくなる。&lt;/p&gt;

&lt;p&gt;新しいプロジェクトで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Visual C# から.NET Framework 3.5にしてクラスライブラリ(.NET Framework)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visual C# -&amp;gt;　Windows -&amp;gt; ユニバーサルからクラスライブラリ(ユニバーサルWindows)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのプロジェクトを同じソリューションに作成する。
VS2017で.NET Frameworkのクラスライブラリプロジェクトを作成するためには
Visual Studio Installerで.NET Coreのワークロードをインストールする必要がある。
また、これとは別に動作確認用のUWPアプリケーションプロジェクトを作成した。&lt;/p&gt;

&lt;p&gt;UWPの方のプロジェクトにあるClass1.csを削除し、追加 -&amp;gt; 既存の項目から、
もう片方のClass1.csをリンクとして追加して、この共通のcsにUWPのコードを書いていくんだけど、
そのまま書くと当然.NET Frameworkの方でビルドできないので
実装部分を&lt;a href=&#34;https://docs.unity3d.com/Manual/PlatformDependentCompilation.html&#34;&gt;#if WINDOWS_UWP ~ #endif&lt;/a&gt;
で囲む。UWPの方のプロジェクトにはプロパティ -&amp;gt; ビルドの条件付きコンパイルにWINDOWS_UWPが含まれているので有効になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void Start()
{
#if WINDOWS_UWP
    ...
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UWPでBLEを扱うのは前書いた通り。
ただし、なぜかXAMLに依存しているようでD3Dビルドすると失敗する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/101&#34;&gt;UWPでBLEデバイスとペアリングして値を取得する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ビルドするとdllができるので.NET Frameworkの方をAssets/Pluginsに置いてInspectorからEditorにだけチェックを入れる。
UWPの方は&lt;a href=&#34;https://docs.unity3d.com/Manual/PluginInspector.html&#34;&gt;Assets/Plugins/WSA&lt;/a&gt;に置くとWSA Playerにだけチェックが入る。&lt;/p&gt;

&lt;p&gt;あとは普通にusingして使うだけ。Bluetoothのcapabilityを有効にするのを忘れずに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityBLE;
  
public class BLE : MonoBehaviour {

    string value = &amp;quot;no connection&amp;quot;;

    public GameObject text;

    private string serviceUUID = &amp;quot;***&amp;quot;;
    private string characteristicUUID = &amp;quot;***&amp;quot;;

    void Start() {
        var ble = new UnityBLE.BLE();
        ble.DeviceAdded += (sender, obj) =&amp;gt; {
            value = &amp;quot;DeviceID: &amp;quot; + obj.DeviceID;
            ble.Listen(obj.DeviceID, serviceUUID, characteristicUUID);
            ble.Stop();
        };
        ble.CharacteristicReceived += (sender, obj) =&amp;gt;
        {
            if (sender == ble)
            {
                if (obj.ex == null)
                {
                    value = Encoding.UTF8.GetString(obj.Value);
                }
                else
                {
                    value = obj.ex.Message;
                }
            }
        };
        ble.Start();
    }

    void Update() {
        text.GetComponent&amp;lt;TextMesh&amp;gt;().text = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Golangの高速なロガーzapとlumberjackでログを出力してrotateさせる</title>
          <link>http://sambaiz.net/article/104/</link>
          <pubDate>Sat, 27 May 2017 16:35:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/104/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap&#34;&gt;https://github.com/uber-go/zap&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u go.uber.org/zap
$ go get -u gopkg.in/natefinch/lumberjack.v2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;速さの秘訣&#34;&gt;速さの秘訣&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://techblog.ca-reward.co.jp/2016/06/post-33.html&#34;&gt;Go言語のLogger「zap」は何故高速に構造化されたログを出力する事が出来るのか｜株式会社CAリワード&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;reflectionとallocationの回避。&lt;/p&gt;

&lt;p&gt;一度allocateしたBufferやEncoderは
&lt;a href=&#34;https://golang.org/pkg/sync/#Pool&#34;&gt;sync.Pool&lt;/a&gt;で使い回している。
このPoolはまさにallocateされたアイテムを再利用するためのもので、GCの負担を緩和させることができる。
Poolのアイテムは勝手に削除されることがあり、もし参照しか持っていなかったらそのままdeallocateされる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap/blob/v1.4.0/buffer/pool.go#L34&#34;&gt;https://github.com/uber-go/zap/blob/v1.4.0/buffer/pool.go#L34&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewPool() Pool {
	return Pool{p: &amp;amp;sync.Pool{
		New: func() interface{} {
			return &amp;amp;Buffer{bs: make([]byte, 0, _size)}
		},
	}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;現状ドキュメントが乏しいのでコードから探っていく必要がある。
まずはQuick Startから。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zap.NewProduction()&lt;/code&gt;は&lt;code&gt;NewProductionConfig().Build(options...)&lt;/code&gt;の&lt;a href=&#34;https://github.com/uber-go/zap/blob/master/logger.go#L87&#34;&gt;ショートカット&lt;/a&gt;。
ConfigをBuildしてLoggerを取得し、InfoやErrorで書く流れ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logger, _ := zap.NewProduction()
defer logger.Sync()
logger.Info(&amp;quot;Hoge&amp;quot;,
  // Structured context as strongly-typed Field values.
  zap.Int(&amp;quot;attempt&amp;quot;, 3),
  zap.Duration(&amp;quot;backoff&amp;quot;, time.Second),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;ts&amp;quot;:1495870212.3378785,&amp;quot;caller&amp;quot;:&amp;quot;zap-log/main.go:36&amp;quot;,&amp;quot;msg&amp;quot;:&amp;quot;Hoge&amp;quot;,&amp;quot;attempt&amp;quot;:3,&amp;quot;backoff&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewProductionConfig()&lt;/code&gt;の内容はこんな感じ。ここからOutputPathを書き換えるとファイルに出力されるようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config := zap.Config{
    Level:       zap.NewAtomicLevelAt(zap.ErrorLevel),
    Development: false,
    Sampling: &amp;amp;zap.SamplingConfig{
        Initial:    100,
        Thereafter: 100,
    },
    Encoding: &amp;quot;json&amp;quot;,
    EncoderConfig: zapcore.EncoderConfig{
        TimeKey:        &amp;quot;ts&amp;quot;,
        LevelKey:       &amp;quot;level&amp;quot;,
        NameKey:        &amp;quot;logger&amp;quot;,
        CallerKey:      &amp;quot;caller&amp;quot;,
        MessageKey:     &amp;quot;msg&amp;quot;,
        StacktraceKey:  &amp;quot;stacktrace&amp;quot;,
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    zapcore.LowercaseLevelEncoder,
        EncodeTime:     zapcore.EpochTimeEncoder,
        EncodeDuration: zapcore.SecondsDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
    },
    OutputPaths:      []string{&amp;quot;stderr&amp;quot;},
    ErrorOutputPaths: []string{&amp;quot;stderr&amp;quot;},
}
config.OutputPaths = []string{&amp;quot;./aaaa.log&amp;quot;}
logger, _ = config.Build()
defer logger.Sync()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Buildの引数にも渡せるOptionというのは&lt;code&gt;apply(logger)&lt;/code&gt;でloggerを操作するインタフェース。
&lt;a href=&#34;https://github.com/uber-go/zap/blob/74ca5ef91c08e5eafb5ab9739df05d66f1b5d8da/options.go#L55&#34;&gt;zap.Fields&lt;/a&gt;は
フィールドを追加するもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logger = logger.WithOptions(zap.Fields(zap.String(&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;)))
defer logger.Sync()
logger.Error(&amp;quot;aaa&amp;quot;,
    zap.String(&amp;quot;eee&amp;quot;, &amp;quot;eee&amp;quot;),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap/blob/v1.4.0/config.go#L154&#34;&gt;Build&lt;/a&gt;の実装をみると、
中では&lt;code&gt;zapcore.NewCore(enc, sink, cfg.Level)&lt;/code&gt;とOptionを引数として取る&lt;code&gt;New()&lt;/code&gt;でloggerを生成している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enc, err := cfg.buildEncoder()
if err != nil {
    return nil, err
}

sink, errSink, err := cfg.openSinks()
if err != nil {
    return nil, err
}

log := New(
    zapcore.NewCore(enc, sink, cfg.Level),
    cfg.buildOptions(errSink)...,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このsinkは&lt;code&gt;io.Writer&lt;/code&gt;をwrapした&lt;a href=&#34;https://github.com/uber-go/zap/blob/179e456766f6ba6d1006f432f90d52ecb6296e84/zapcore/write_syncer.go#L32&#34;&gt;WriteSyncer&lt;/a&gt;
で、&lt;code&gt;AddSync(w io.Writer)&lt;/code&gt;で変換できる。
これに&lt;a href=&#34;https://github.com/natefinch/lumberjack&#34;&gt;lumberjack&lt;/a&gt;を渡してやるとrotateできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config := zap.NewProductionConfig()
enc := zapcore.NewJSONEncoder(config.EncoderConfig)
sink := zapcore.AddSync(
    &amp;amp;lumberjack.Logger{
        Filename:   &amp;quot;./aaaa.log&amp;quot;,
        MaxSize:    500, // megabytes
        MaxBackups: 3,
        MaxAge:     28, //days
    },
)
logger := zap.New(
    zapcore.NewCore(enc, sink, config.Level),
)
defer logger.Sync()
logger.Error(&amp;quot;aaa&amp;quot;,
    zap.String(&amp;quot;eeef&amp;quot;, &amp;quot;eefe&amp;quot;),
)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>夜のNY郊外を無一文で彷徨い、Google I/OとMaker Faire Bay Areaに行ってきた</title>
          <link>http://sambaiz.net/article/103/</link>
          <pubDate>Mon, 22 May 2017 23:44:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/103/</guid>
          <description>

&lt;p&gt;Googleが毎年やっているイベント、Google I/Oのチケットが当たったのでアメリカに行ってきた。
海外に行くのはこれが3回目でアメリカははじめて。一人での海外もはじめて。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;p&gt;チケットが当たってからExpediaで航空券やホテルを取った。航空券の流れで保険にも加入した。
アメリカの医療費は相当高いそうなので何かしらの保険に入っておかないと不安だ。&lt;/p&gt;

&lt;p&gt;会期中は会場近辺のサンフランシスコ/マウンテンビューのホテルがとんでもなく値上がりしている模様。
多分通常の倍ぐらいにはなっているので早めに取っておくとよいと思われる。&lt;/p&gt;

&lt;p&gt;GoogleI/Oは週末にかけての3日間だったので、その前の週末から出発し、前半はニューヨークに行くことにして、
マンハッタンに宿を取った。&lt;/p&gt;

&lt;p&gt;アメリカに入国するのには&lt;a href=&#34;https://esta.cbp.dhs.gov/esta/application.html&#34;&gt;ESTA&lt;/a&gt;を申請する必要がある。
申請自体は72時間以内に通るのだけど、パスポート番号が必要がなので持っていなければ先に作っておく必要がある。
ESTAが通っていないと本当に入れないらしい。怖い。&lt;/p&gt;

&lt;p&gt;現地での通信手段はT-mobileの&lt;a href=&#34;https://prepaid-phones.t-mobile.com/prepaid-international-tourist-plan&#34;&gt;Tourist plan&lt;/a&gt;($30プリペイドでSIM+2GB LTE+国内通話+SMS)
を購入することにした。
日本にはsimを送ってくれないので現地で調達する必要がある。モバイルルータはちょっと高いような気がして借りなかった。&lt;/p&gt;

&lt;p&gt;あとは英語力をなんとかしようと付け焼刃でDMM英会話をはじめてみたが、準備期間が短すぎたかなと思う。&lt;/p&gt;

&lt;h2 id=&#34;出国&#34;&gt;出国&lt;/h2&gt;

&lt;p&gt;チェックインの締め切りが出発の1時間前だったので、
余裕を持って2時間前ぐらいには着くはずだったんだけど、こんなときに限って財布を落とすわ成田エクスプレスは突然運休するわで大ピンチ。
日暮里から京急のスカイライナーに乗ってスーツケースをかついで走ってなんとか飛行機には間に合ったが、
両替などする時間はなく、財布に1000円しか入っていない状態で出発することになってしまった。&lt;/p&gt;

&lt;p&gt;距離にして11000km、12時間のフライトの末、ニューヨークのジョン・F・ケネディ国際空港(JFK)に到着。
時差で-13時間になるため出発よりも早い時刻に到着することになって得した気分だ。
ついにアメリカに来た。&lt;/p&gt;

&lt;h2 id=&#34;ニューヨーク&#34;&gt;ニューヨーク&lt;/h2&gt;

&lt;p&gt;当初はニューヨーク観光しつつ、アムトラック(電車)でワシントンD.C.にも行っちゃおうかと考えてチケットまで買っていた。
しかし現実は厳しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;現地に到着し、通信手段を調達するためT-mobileのショップに向かおうとしたが、肝心のショップの場所がわからない。
もちろん日本のsimカードはすでに機能停止しているので空港のWifiで調べたところ、そこから一番近いところでも数km離れていることがわかった。
タイムズスクエアの近くにはあるようだったので、まずはなんとかしてホテルに向かうことにしたが、
JFKからマンハッタンまでは直線距離で20km以上離れている。ホテルの送迎サービスはなかった。
それでもGoogle mapに従って、途中free wifiを乗り継いでいけばこのときはなんとかなるかなと思っていた。&lt;/p&gt;

&lt;p&gt;空港から電車で行こうと思っていたところ、うかつにも謎タクシーに誘導されて乗ってしまった。
47ドルでホテルまで行ってくれると思いきや、それはJamaica駅までの料金で、ホテルまでは100ドルという。調べていた相場の倍だ。
傷口を広げないようJamaicaで降ろしてもらうことにした。
乗る前に現金はないからクレジットカードで払う旨を伝えたのだけど、
支払いの段になってクレジットカードの機械が壊れたから現金でと言い出して困った。なにせ1ドルも持っていないのだから。
近くのATMで現金を下ろすよう言われたのでクレジットカードを入れたのだけれど
2枚ともアウト。そこからどうやって払うんだって問いつめられるもののどうしようもない。
結局解放してもらえたが、初っ端からほとんど心が折れてしまって国に帰りたかった。&lt;/p&gt;

&lt;p&gt;それでもなんとかしてホテルにはたどり着かなくてはならないので、LIRRという電車でJamaicaからWoodside駅に向かった。
空港で調べたGoogle mapの経路に出たからそうしたのだけど、
マンハッタンにあるハブ駅、Pensilvania(Penn) stationまで行くほうが行き先表示に出ているので分かりやすかった。
改札はなくて切符は車内で確認される。&lt;/p&gt;

&lt;p&gt;案内の人に聞いて電車に乗ったんだけど、切符の確認の際にこの電車ではないと言われる。
乗り間違えると、引き返すためにホームで割と長く待つことになる。5月も半ばなのに白い息が出るぐらい寒い。
Googleで調べようにも、駅にあるWifiはどうも契約していないと使えなさそうなものしかなかった。
地下鉄にはfree wifiが通っていたが、それも全ての駅で使えるというわけではなさそうだった。&lt;/p&gt;

&lt;p&gt;Woodsideからは地下鉄に乗るのだけれど、この券売機がなぜかクレジットカードのPINをうけつけてくれずチケットを買えなかった。
カードが止まったかと思い、しょうがないので6kmほど歩いてマンハッタンまで向かうことにした。雨が降っていて、寒くて泣きたくなった。
空港でマップのデータを読んでいたのでGPSと合わせればオフラインでも自分の位置はわかるのが唯一の救いだ。
電話もなかったので、道中あったスタバなどのfree wifiを外から使わせてもらって、
家族に連絡をとって日本からクレジットカード会社に問い合わせてもらったが、
本人からの連絡じゃないとだめとのことでどうしようもなかった。&lt;/p&gt;

&lt;p&gt;マンハッタンに行くためにはイースト川を越える必要があったので、
地図上で橋になっているところを順番に見てまわったが、車や電車でないとだめなところばかりで暗雲がただこめる。
あとから調べたら、マンハッタンの南側、ブルックリンとマンハッタン橋は歩いて渡れたらしい。
あの向こうがマンハッタンなのになと沿岸を眺めながら、この時点で夜中の0時を回っていて、野宿の可能性を考え始める。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-manhattan.jpg&#34; alt=&#34;マンハッタンを眺める&#34; /&gt;&lt;/p&gt;

&lt;p&gt;途方に暮れて彷徨っていたところ、歩いていたおじさんとたまたま目が合って、
お金がなくて電車には乗れないんだけど、徒歩でマンハッタンに渡る方法はあるか聞いたら、
なんと地下鉄の駅まで案内してくれて運賃を出してくれた。
お礼するために連絡先を聞こうとしたのにすぐいなくなってしまわれた。命の恩人だ。&lt;/p&gt;

&lt;p&gt;なんとかホテルに到着し、電話を借りてカード会社に連絡したところ、
カードは普通に使える状態で電車の明細はこちらには届いていない、キャッシングは枠がないからできない、
というまさかの事実が発覚した。
カードが使えるとはいえ現金がないと困ることが分かったので、キャッシング枠の審査を急いでもらうよう頼んでみた。&lt;/p&gt;

&lt;p&gt;もはや遠出する気が全くなくなったのでアムトラックのチケットをキャンセルしようと思ったら、システムメンテナンスでできずに諦める。
雨の中歩き回ったのでスーツケースの中の服はほとんどびしょ濡れだった。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次の日は昼をまわったころ目覚めて、だらだらして風呂に入ってT-mobileのショップに向かってsimを購入。
設定は向こうの人がやってくれるので、言語を英語にしておくとスムーズだ。
念願の通信手段を得て、Google mapがいつでも使えるようになった。つまり無敵。
とはいえ、いまだ現金がないのでマンハッタンの中で過ごすことにした。&lt;/p&gt;

&lt;p&gt;マンハッタンは高いビルが多く、GPSが大きくずれる。縦横のStreetとAvenueに番号が振られているのでそれに従うと動きやすかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-stav.jpg&#34; alt=&#34;StreetとAvenueの表示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Shake Shackのハンバーガーを食べて、チェルシーマーケットでロブスターを食べた。これでもsmall。
身はぎっしり入っていてレモンをかけて食べるとおいしい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-bigebi.jpg&#34; alt=&#34;チェルシーマーケットのロブスター&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それと、なぜかカードが使えなかった地下鉄に再チャレンジしてみた。
問題になったのはこういう券売機。クレジットカードを抜き差し(dip)してPINを入力する。やっぱり買えない。
いろいろ試して見たところPINを入力せずにENTERだけ押したら買えることがわかった。意味わからん・・・。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ny-subway-machine.jpg&#34; alt=&#34;NYの地下鉄の券売機&#34; /&gt;&lt;/p&gt;

&lt;p&gt;夜にキャッシングができるようになったのでタクシードライバーに連絡をとって代金を支払って2日目も終わり。
3日目は空港に向かう日なので、これがNY滞在の全て。次来るときはもう少しなんとかしたい。&lt;/p&gt;

&lt;p&gt;到着はJFKだったけど、出発はニューアーク・リバティー空港(EWR)からで、Penn stationからNJ TRANSIT(電車)一本で行ける。
Penn stationは上にも書いたとおりハブ駅で、アムトラック、LIRR、NJ TRANSITの駅が入っている。
ワシントンD.C.に行くときもこの駅から出るはずだった。
最初、画面にTrack(ホーム)が書いてなくてちょっと焦ったが、STATUSがBOARDINGになると表示される。&lt;/p&gt;

&lt;p&gt;EWRの飲食店にはタブレットが置いてあって、そこで注文しカードを通すと注文される。現金は使えない。
最初にboarding passのバーコードをかざすと乗る便の情報が表示されるので乗り遅れる心配がない。乗り遅れるどころか2時間遅延してたけど。
終わったらtabをcloseする。チップの割合も選択できるようになっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ewr.jpg&#34; alt=&#34;EWRの飲食店のタブレット&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここから西海岸、サンフランシスコへ。
国内ながら3時間の時差があって、6時間のフライトなのに3時間しか進まない。&lt;/p&gt;

&lt;h2 id=&#34;googlei-o&#34;&gt;GoogleI/O&lt;/h2&gt;

&lt;p&gt;I/Oに参加する同僚2人と合流した。一人でないのは心強い限りだ。&lt;/p&gt;

&lt;p&gt;GoogleI/O自体は3日間なのだけれど、前日に登録ができ、先着順でKeynoteの前の方の席が割り当てられる。
今年の会場は去年と同じマウンテンビューのShoreline Amphitheatreというところで、Googleの近くにある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-shoreline.jpg&#34; alt=&#34;Shoreline Amphitheatre&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サンフランシスコからもサンノゼからもそれなりに離れていて、最寄りの電車の駅も少し離れているので、バスか車で来ることになると思う。
同僚がレンタカーを借りてくれていたのでそれで向かったが、フリーウェイの、特に出口が渋滞して結構時間がかかる。
駐車場が一杯なのではないか心配していたけど、普通の駐車場の他に滅茶苦茶広いオーバーフロー駐車場があるので問題なかった。
どこまで駐車場なのかわからないぐらい広い。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-parking.jpg&#34; alt=&#34;オーバーフロー駐車場&#34; /&gt;&lt;/p&gt;

&lt;p&gt;受付を済ませると首からかけるバッジと、水筒、日焼け止め、Tシャツ、サングラスがもらえた。
会場は基本屋外なのでかなり実用的なセットだ。一方夜は相当寒いので上着を持っていったほうがよい。
バッジはNFCタグになっていて、セッション予約の確認に使われる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ioset.jpg&#34; alt=&#34;もらったもの&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ついでに近くのGoogleも見にいってきた。ショップがある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-google.jpg&#34; alt=&#34;Google&#34; /&gt;&lt;/p&gt;

&lt;p&gt;その後サンフランシスコ市内の北、フィッシャーマンズワーフのBOUDINという店でパンの器のクラムチャウダーを食べた。
おいしかった。海の方を眺めるとアルカトラズが見える。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-boudin.jpg&#34; alt=&#34;クラムチャウダー&#34; /&gt;&lt;/p&gt;

&lt;p&gt;夜はIntel&amp;rsquo;s Google I/O Day Zero Partyという非公式の前夜祭みたいなのに行ってきた。
I/Oに比べると規模はそんなに大きくはないけど、それでも多くの人が集まっていて、日本勢にも出会った。
飲み放題食べ放題で、IntelやGoogleのテクノロジーに絡んだデモが行われている。
体験したりしてトークンを集めることで賞品と交換でき、アンドロイドのTシャツをもらった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-zero-day.jpg&#34; alt=&#34;アンドロイドのTシャツ&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Keynoteは一番広いアンフィシアターで行われ、内側の椅子エリアと外側の芝のエリアがある。
遅れてしまったため芝エリアしか入れなくて午前中はそこで聞くことしたら、暑いけど寝転がりながら聞くことができるので案外悪くなかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-keynote.jpg&#34; alt=&#34;芝席&#34; /&gt;&lt;/p&gt;

&lt;p&gt;食事は指定の場所で配られているので取っていって適当な場所で食べる。
朝食も含めて食事や飲み物やお菓子は全て提供されるが、朝食は数がそんなに多くないのか、遅い時間に行くとなくなっていることがあった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-food.jpg&#34; alt=&#34;食事のリスト&#34; /&gt;&lt;/p&gt;

&lt;p&gt;午後のDeveloper Keynoteでは主な新機能などがざっくり発表されて、What&amp;rsquo;s newなどのセッションではそれが詳細に説明されたりする形になっている。&lt;/p&gt;

&lt;p&gt;Androidは、GooglePlay Protectや、地味に長いブート時間が2倍速くなったりするAndroid Oが発表された。あと、嬉しそうにもう一つあるよって言い出して
何かなと思ったらKotlin公式サポート。Android勢歓喜。よかったね。&lt;/p&gt;

&lt;p&gt;Daydream(VR)はスマホ不要のStandaloneヘッドセットと、位置トラッキングのWorldSense。
Tango(AR)はGPSに対して、室内で位置を知ることができるVPS(Visual Positioning Service)というのが発表されていた。これを使うと店内でナビできるすごく便利そうなやつだ。
VR/ARは教育分野、&lt;a href=&#34;https://edu.google.com/expeditions/&#34;&gt;Google Expeditions&lt;/a&gt;でも使われているらしい。
ARで教室に火山や竜巻を出したりできる。後のセッションで言っていたのは、どこにでもVRで行って何でもARで見れるだったかな。&lt;/p&gt;

&lt;p&gt;あとはGoogle photoのサジェスト機能や、なんかすごいGoogle lensなどなど。
Keynoteを通して、Googleっていろんなことをやっていて、世界が便利になるイメージが湧いた。&lt;/p&gt;

&lt;p&gt;最後に突然のGoogle Home+GCPクレジット配布の発表。うれしい。
日本での発売も発表されたが、一足早く手に入れることができた。何か作ってみたい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-home.jpg&#34; alt=&#34;Google Home&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Keynoteが終わると並行してセッション、展示やオフィスアワーなどが行われる。
セッションは1時間区切りになっていて、移動の時間が用意されていないように見えるが、
実際は30~40分ほどで終わるので一杯に入れても問題はない。
ただ、一日中ずっとセッションを聞いているというのも疲れるので、
割とみんなその辺りにある椅子や芝生に座ったり寝転がったりしてPCを開いてたり、歓談してたりする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-relax.jpg&#34; alt=&#34;会場風景&#34; /&gt;&lt;/p&gt;

&lt;p&gt;セッションはAR(Tango)/VR(Daydream)、Firebase、Android Thingsなどいろいろな種類のを聞きにいった。
全てのセッションはライブストリーミングされているので日本でも聞けるけど、
現地だと会場の雰囲気を楽しめるのはもちろん、しなかったけどセッションの後やオフィスアワーで質問したりすることができる。
次来るときは質問できるぐらい使い込んでいきたい。&lt;/p&gt;

&lt;p&gt;Firebaseもいくつか機能追加があって、そのうちの一つがPhone number auth。早速ためしてみた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/102/&#34;&gt;io17で発表されたFirebaseのphone number authをwebで試してみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AndroidThingsはIoTのためのOS。
Androidのエコシステムに乗れることと、プロトタイプから本番までのスケーリングしやすさ、セキュリティが特長として挙げられていた。
せっかくなのでcodelabsで触ってきた。codelabsでは、Googleのテクノロジーのチュートリアルのコースを質問しながら進められる。
Android端末など必要な機材は用意されているので、それらを持っていなくても問題ない。IoTはなかなかの人気コンテンツで2時間待つことになった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-codelabs.jpg&#34; alt=&#34;IOT codelab&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コースを最後まで終えるとAndroid Things対応のハードウェアセットがもらえた。
codelabsはwebに&lt;a href=&#34;https://codelabs.developers.google.com/io2017&#34;&gt;公開されている&lt;/a&gt;ので家でも試すことができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-iot-omiyage.jpg&#34; alt=&#34;IOTおみやげ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1,2日目のセッションが終わるとAfter Hourというパーティーがある。
朝から夜まで楽しめる、とても良いイベントだった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-party.jpg&#34; alt=&#34;After Hour&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;maker-faire-bay-area&#34;&gt;Maker Faire Bay Area&lt;/h2&gt;

&lt;p&gt;Google I/Oが終わった翌日、同僚を空港で見送ってSan mateoで行われるMaker Faire Bay Areaにいってきた。&lt;/p&gt;

&lt;p&gt;Maker Faireは、ものづくりが好きな人たちが集まり、作ったものを展示発表したり体験したりするお祭り。
このBay Areaからはじまり、世界中に広がっている。
東京でも行われているんだけど、行ったことがないためこれが初参加。&lt;/p&gt;

&lt;p&gt;空港から会場のSan Mateo Event Centerまではバス(SamTrans)で向かった。
運賃は現金で払うこともできるけど、Clipperという日本のSuicaみたいなやつがあると便利。空港のInformationで買えた。
バスの運賃は2ドルちょっと。&lt;/p&gt;

&lt;p&gt;バス停は柱の上の方にある行き先が書いてある札が目印。待合所があるところもあれば、ただの柱にくっついているところもあってちょっと気づきにくい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-busstop.jpg&#34; alt=&#34;バス停&#34; /&gt;&lt;/p&gt;

&lt;p&gt;乗ったらClipperをピッとやって席に座り、降りたければ黄色い紐を引くとSTOP REQUESTEDされる。
バス停に近づいても特にアナウンスなく通過してしまうのでGPSの位置を注意して見ていた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-stop-requested.jpg&#34; alt=&#34;STOP REUESTEDの紐&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;会場はとても広い。何も考えずにうろうろしていたのだけど、あとでマップを見返したら、見てない場所とかがあったりしたので、最初にマップで行く場所に目星をつけておいたほうがよいと思う。
展示のジャンルごとにテントがあって、ほかにはアクティビティやステージ、食べ物の屋台、体験コーナーなどがある。
屋台は基本現金払いだけど、ATMが会場内にもある。
子供連れもたくさんいて、大人子供ともに楽しめるイベントになっていた。&lt;/p&gt;

&lt;p&gt;展示物は、子供が作ったものから、こんなの個人で作れるのかというようなものまで、ジャンルも電子工作からガーデニングまでいろいろ。
日本から出している人もいて、ロボットのところにデイリーポータルZや個人のブースがいくつかあった。&lt;/p&gt;

&lt;p&gt;すごい勢いで燃えながら回転する球。日本だと消防法的にまずそう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-burning.jpg&#34; alt=&#34;燃える球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自転車をこいで電力を賄うステージ。ステージもいくつかあって、他では化学の実験をやっていた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-you-are-the-power.jpg&#34; alt=&#34;YOU ARE THE POWER!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アクティビティをやるには自己責任的な誓約書にサインしてリストバンドをもらう必要がある。
これは音楽に合わせて対応するところを踏んだり引いたりするゲーム。アクションは5つしかないんだけど、なかなか難しかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-make-act.jpg&#34; alt=&#34;音ゲー&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ドローンレースをやっているテントもあった。モニターにはドローン視点の映像が流れていて迫力がある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-drone.jpg&#34; alt=&#34;ドローンレース&#34; /&gt;&lt;/p&gt;

&lt;p&gt;R2D2がいた。もちろん動く。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-r2d2.jpg&#34; alt=&#34;R2D2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;せっかくAndroid Thingsのハードウェアも手に入ったことだし、何か作って出展してみたい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでアメリカでの予定も終わり。
9日間ながら内容が濃い滞在だった。また行きたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>io17で発表されたFirebaseのphone number authをwebで試してみた</title>
          <link>http://sambaiz.net/article/102/</link>
          <pubDate>Wed, 17 May 2017 23:34:00 -0700</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/102/</guid>
          <description>&lt;p&gt;今日のdeveloper keynoteで発表されたphone number authを試してみた。
Firebaseだと他にはPerformance Monitoringも発表されている。
あとSDKをオープンソースにするとか。&lt;/p&gt;

&lt;p&gt;firebase-toolsを最新版にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# npm install -g firebase-tools
$ firebase -V
3.9.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FirebaseUIを使う場合、これも最新版にしないと出てこない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdn.firebase.com/libs/firebaseui/2.0.0/firebaseui.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.firebase.com/libs/firebaseui/2.0.0/firebaseui.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;firebase.auth.PhoneAuthProvider.PROVIDER_ID&lt;/code&gt;がphone number authの
&lt;a href=&#34;https://github.com/firebase/firebaseui-web#starting-the-sign-in-flow&#34;&gt;オプション&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const uiConfig = {
    signInOptions: [
        firebase.auth.PhoneAuthProvider.PROVIDER_ID
    ],
    ...
}

const ui = new firebaseui.auth.AuthUI(firebase.auth());
ui.start(&#39;#firebaseui-auth-container&#39;, uiConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなボタンを押すと&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-1.png&#34; alt=&#34;ボタン&#34; /&gt;&lt;/p&gt;

&lt;p&gt;電話番号とCAPTCHAが入り、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-2.png&#34; alt=&#34;電話番号とCAPTCHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SMSに書かれた番号を入力すると認証される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-3.png&#34; alt=&#34;番号入力&#34; /&gt;&lt;/p&gt;

&lt;p&gt;二段階認証のようなものだと思っていたけど、そうではないみたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UWPでBLEデバイスとペアリングして値を取得する</title>
          <link>http://sambaiz.net/article/101/</link>
          <pubDate>Sat, 13 May 2017 10:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/101/</guid>
          <description>

&lt;p&gt;ManifestからBluetoothを許可しておく。&lt;/p&gt;

&lt;h2 id=&#34;bleデバイスを見つける-https-github-com-microsoft-windows-universal-samples-blob-dev-samples-bluetoothleclient-cs-scenario1-discoverserver-xaml-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/Windows-universal-samples/blob/dev/Samples/BluetoothLEClient/cs/Scenario1_DiscoverServer.xaml.cs&#34;&gt;BLEデバイスを見つける&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CreateWatcher&lt;/code&gt;にBluetooth LEプロトコルの&lt;a href=&#34;https://docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/aep-service-class-ids&#34;&gt;AEP(Association EndPoint)サービスクラスID&lt;/a&gt;と
requestPropaertiesで必要なデバイス情報を渡している。
最後の&lt;code&gt;AssociationEndpoint&lt;/code&gt;は&lt;code&gt;System.Devices.Aep.ProtocolId&lt;/code&gt;のAepと&lt;a href=&#34;https://docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/enumerate-devices-over-a-network&#34;&gt;対応している&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Windows.Devices.Enumeration;

string[] requestedProperties = { &amp;quot;System.Devices.Aep.DeviceAddress&amp;quot;, &amp;quot;System.Devices.Aep.IsConnected&amp;quot; };

deviceWatcher = DeviceInformation.CreateWatcher(
                        &amp;quot;(System.Devices.Aep.ProtocolId:=\&amp;quot;{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\&amp;quot;)&amp;quot;,
                        requestedProperties,
                        DeviceInformationKind.AssociationEndpoint);

deviceWatcher.Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;deviceWatcher.Added += DeviceWatcher_Added;
deviceWatcher.Removed += DeviceWatcher_Removed;
deviceWatcher.Updated += DeviceWatcher_Updated;
/*
deviceWatcher.EnumerationCompleted += DeviceWatcher_EnumerationCompleted;
deviceWatcher.Stopped += DeviceWatcher_Stopped;
*/

Dictionary&amp;lt;string, DeviceInformation&amp;gt; deviceInfos = new Dictionary&amp;lt;string, DeviceInformation&amp;gt;();

private void DeviceWatcher_Added(DeviceWatcher sender, DeviceInformation deviceInfo)
{

    if (sender == deviceWatcher)
    {
        if (deviceInfo.Name != string.Empty)
        {
            deviceInfos.Add(deviceInfo.Id, deviceInfo);   
        }
    }
}

private void DeviceWatcher_Updated(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
{
    if (sender == deviceWatcher)
    {
        deviceInfos[deviceInfoUpdate.id].Update(deviceInfoUpdate);
    }
}

 private void DeviceWatcher_Removed(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
{
    if (sender == deviceWatcher)
    {
        deviceInfos.Remove(deviceInfoUpdate.id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ペアリング&#34;&gt;ペアリング&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DevicePairingResult result = await deviceInfo.Pairing.PairAsync();
if (result.Status == DevicePairingResultStatus.Paired || result.Status == DevicePairingResultStatus.AlreadyPaired){
    // success
} else{
    // fail
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなウィンドウが出てくる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/101.png&#34; alt=&#34;ペアリング確認&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OSの設定からペアリングすることもできる。&lt;/p&gt;

&lt;h2 id=&#34;serviceのcharacteristicを取得する&#34;&gt;serviceのcharacteristicを取得する&lt;/h2&gt;

&lt;p&gt;ペアリングしたらこんな感じで値を取得できる。
&lt;code&gt;GetGattServicesForUuidAsyc&lt;/code&gt;などはCreaters Updateから追加されたAPI。
deviceの値が取得できない場合はBluetoothが許可されているか確認する。
あと、characteristicが一つも取れない場合、他のアプリケーションからアクセスしていないか注意。
ドキュメントにも書いてあるけど、一つのサービスには一つのアプリケーションしかアクセスできない。
そもそも接続できない場合、一旦お互いの接続設定を消して再ペアリングするとよくなることがある。
ペアリングもできないようだったらBluetoothをオフにしてみるとか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var device = await BluetoothLEDevice.FromIdAsync(deviceInfo.Id);

var services = await device.GetGattServicesForUuidAsync(serviceUUID);

var characteristics = await services.Services[0].GetCharacteristicsForUuidAsync(characteristicUUID);

characteristics.Characteristics[0].ValueChanged += characteristicChanged;

await characteristics.Characteristics[0].WriteClientCharacteristicConfigurationDescriptorAsync(
    GattClientCharacteristicConfigurationDescriptorValue.Notify
);

void characteristicChanged(
    GattCharacteristic sender,
    GattValueChangedEventArgs eventArgs
){
    byte[] data = new byte[eventArgs.CharacteristicValue.Length];
    Streams.DataReader.FromBuffer(eventArgs.CharacteristicValue).ReadBytes(data);
    var str = System.Text.Encoding.ASCII.GetString(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest)</title>
          <link>http://sambaiz.net/article/100/</link>
          <pubDate>Tue, 09 May 2017 20:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/100/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;merge-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-merge&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge&#34;&gt;merge&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;2つのstreamの両方の値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.merge(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`merge ${data}`),
  err =&amp;gt; console.log(`merge ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;forkjoin-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-forkjoin&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin&#34;&gt;forkJoin&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;completeしたときの最後の値を配列としてemitする。
非同期で一つ値をemitするようなstreamで、Promise.allのようなことをしたいときはこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.forkJoin(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`      forkJoin: ${data}`),
  err =&amp;gt; console.log(`      forkJoin: ${err}`)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concat-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-concat&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat&#34;&gt;concat&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;前のstreamがcompleteしたら次のstreamの値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.concat(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`  concat ${data}`),
  err =&amp;gt; console.log(`  concat ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinelatest-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-combinelatest&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest&#34;&gt;combineLatest&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;stream自体を結合するのではなく値を結合する。
この例だと、streamでemitされた値がa、stream2で最後のemitされた値がbになる。
combineする値がない場合はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stream1.combineLatest(stream2, (a, b) =&amp;gt; a + b).subscribe(
  data =&amp;gt; console.log(`    combineLatest ${data}`),
  err =&amp;gt; console.log(`    combineLatest ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;同時に実行したときの結果&#34;&gt;同時に実行したときの結果&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;const stream1 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 1-${v+1}`).take(3);
const stream2 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 2-${v+1}`).take(3).delay(150);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/100.png&#34; alt=&#34;stream1とstream2&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;merge stream 1-1
  concat stream 1-1
merge stream 1-2
  concat stream 1-2
merge stream 2-1 &amp;lt;- mergeではstream1はcompleteしていないが、stream2がemitされる
merge stream 1-3
  concat stream 1-3
    combineLatest stream 1-3stream 2-1 &amp;lt;- stream2の値がemitされたのでcombineする
merge stream 2-2
    combineLatest stream 1-3stream 2-2
      forkJoin: stream 1-3,stream 2-3 &amp;lt;- stream1とstream2がcompleteしたのでforkJoinでemitされる
    combineLatest stream 1-3stream 2-3
merge stream 2-3
  concat stream 2-1 &amp;lt;- concatではstream1がcompleteしたので、stream2がemitされる
  concat stream 2-2
  concat stream 2-3
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>angular/material2でフォームを作る</title>
          <link>http://sambaiz.net/article/99/</link>
          <pubDate>Sat, 06 May 2017 22:16:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/99/</guid>
          <description>

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99.gif&#34; alt=&#34;フォーム&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/angular4-form&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;angular-material2-https-github-com-angular-material2-の準備&#34;&gt;&lt;a href=&#34;https://github.com/angular/material2&#34;&gt;angular/material2&lt;/a&gt;の準備&lt;/h2&gt;

&lt;p&gt;現時点で
&lt;a href=&#34;https://github.com/angular/material2/issues/675&#34;&gt;DatePicker&lt;/a&gt;や
&lt;a href=&#34;https://github.com/angular/material2/issues/581&#34;&gt;Table&lt;/a&gt;など
開発中のコンポーネントが多いため足りないものを他のライブラリで補うなどする必要がある。
DatePickerはもう少しで出そう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save @angular/material
$ npm install --save hammerjs # gesture用
$ npm install --save @angular/animations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moduleで&lt;code&gt;import &#39;hammerjs&#39;;&lt;/code&gt;して、以下のModuleをimportに加える。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BrowserAnimationsModule&lt;/code&gt;(&lt;code&gt;from &#39;@angular/platform-browser/animations&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MdButtonModule&lt;/code&gt;など使うもの(&lt;code&gt;from &#39;@angular/material&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スタイルとアイコン(md-icon)を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&amp;quot;../node_modules/@angular/material/prebuilt-themes/indigo-pink.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;link href=&amp;quot;https://fonts.googleapis.com/icon?family=Material+Icons&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フォームを作る-https-angular-io-docs-ts-latest-guide-forms-html&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/forms.html&#34;&gt;フォームを作る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;とりあえずコンポーネントを作成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component TodoForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Formの値をバインドするためのクラスを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class TodoForm {
  constructor(
    public id: number,
    public title: string,
    public active: boolean,
    public priority?: number,
  ) {  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://material.angular.io/components&#34;&gt;material2の&lt;/a&gt;mdInput, mdSelect, mdButtonでフォームを作る。
&lt;code&gt;#todoForm&lt;/code&gt;のように頭についている#は
&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/template-syntax.html#!#ref-vars&#34;&gt;reference variable&lt;/a&gt;で、
titleはrequiredとしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;root&amp;quot;&amp;gt;
  &amp;lt;form (ngSubmit)=&amp;quot;onSubmit()&amp;quot; #todoForm=&amp;quot;ngForm&amp;quot;&amp;gt;

    &amp;lt;div *ngIf=&amp;quot;model.id !== 0&amp;quot; class=&amp;quot;form-item&amp;quot;&amp;gt;
      ID: {{model.id}}
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-input-container&amp;gt;
        &amp;lt;input mdInput name=&amp;quot;title&amp;quot; required placeholder=&amp;quot;やること&amp;quot; 
          [(ngModel)]=&amp;quot;model.title&amp;quot;&amp;gt;
      &amp;lt;/md-input-container&amp;gt;
    &amp;lt;/div&amp;gt;
    
    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-select placeholder=&amp;quot;優先度&amp;quot; name=&amp;quot;priority&amp;quot; 
        [(ngModel)]=&amp;quot;model.priority&amp;quot;&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;1&amp;quot;&amp;gt;高&amp;lt;/md-option&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;2&amp;quot;&amp;gt;中&amp;lt;/md-option&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;3&amp;quot;&amp;gt;低&amp;lt;/md-option&amp;gt;        
      &amp;lt;/md-select&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-slide-toggle name=&amp;quot;active&amp;quot; [(ngModel)]=&amp;quot;model.active&amp;quot;&amp;gt;
        有効にする
      &amp;lt;/md-slide-toggle&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;submit&amp;quot; md-raised-button [disabled]=&amp;quot;!todoForm.form.valid&amp;quot;&amp;gt;
        Submit
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Active&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Priority&amp;lt;/th&amp;gt;
  &amp;lt;/thead&amp;gt;
  &amp;lt;tbody&amp;gt;
    &amp;lt;tr li *ngFor=&amp;quot;let todo of todos&amp;quot;&amp;gt;
      &amp;lt;td&amp;gt;{{todo.id}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.title}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.active}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.priority}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;button md-button (click)=&amp;quot;onEdit(todo.id)&amp;quot;&amp;gt;編集&amp;lt;/button&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンポーネントはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({
  selector: &#39;app-todo-form&#39;,
  templateUrl: &#39;./todo-form.component.html&#39;,
  styleUrls: [&#39;./todo-form.component.css&#39;]
})
export class TodoFormComponent implements OnInit {

  constructor() { }

  todos: TodoForm[] = [];
  model = new TodoForm(0, &amp;quot;&amp;quot;, false);

  ngOnInit() {
  }

  onSubmit() {
    if(this.model.id === 0) {
      this.model.id = this.todos.length + 1;
      this.todos.push(this.model);
    }else{
      this.todos[this.model.id - 1] = this.model;
    }
    this.model = new TodoForm(0, &amp;quot;&amp;quot;, false);
  }

  onEdit(id: number) {
    this.model = Object.assign({}, this.todos[id - 1]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;autocomplete-https-material-angular-io-components-component-autocomplete&#34;&gt;&lt;a href=&#34;https://material.angular.io/components/component/autocomplete&#34;&gt;AutoComplete&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;次に人を登録するためのtextフォームを作る。これは前もって登録されている人の中からAutoCompleteさせる。&lt;/p&gt;

&lt;p&gt;mdAutocompleteに候補を渡してmdInputのmdAutoCompleteにmdAutoCompleteの参照を渡す。
&lt;a href=&#34;https://angular.io/docs/ts/latest/api/forms/index/FormControl-class.html&#34;&gt;FormControl&lt;/a&gt;を扱うためには&lt;code&gt;@angular/forms&lt;/code&gt;の&lt;code&gt;ReactiveFormsModule&lt;/code&gt;をimportする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
    &amp;lt;md-input-container&amp;gt;
      &amp;lt;input mdInput name=&amp;quot;assignee&amp;quot; required placeholder=&amp;quot;やるひと&amp;quot; 
        [(ngModel)]=&amp;quot;model.assignee&amp;quot;
        [mdAutocomplete]=&amp;quot;autoAssignee&amp;quot;
        [formControl]=&amp;quot;assigneeFormControl&amp;quot;
      &amp;gt;
    &amp;lt;/md-input-container&amp;gt;

    &amp;lt;md-autocomplete #autoAssignee=&amp;quot;mdAutocomplete&amp;quot; [displayWith]=&amp;quot;displayAssignee&amp;quot;&amp;gt;
      &amp;lt;md-option *ngFor=&amp;quot;let p of filteredAssignee | async&amp;quot; [value]=&amp;quot;p&amp;quot;&amp;gt;
          {{ p.name }}
      &amp;lt;/md-option&amp;gt;
    &amp;lt;/md-autocomplete&amp;gt;
  &amp;lt;/div&amp;gt;
  
  &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
    &amp;lt;md-select placeholder=&amp;quot;優先度&amp;quot; name=&amp;quot;priority&amp;quot; 
      [(ngModel)]=&amp;quot;model.priority&amp;quot;&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;1&amp;quot;&amp;gt;高&amp;lt;/md-option&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;2&amp;quot;&amp;gt;中&amp;lt;/md-option&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;3&amp;quot;&amp;gt;低&amp;lt;/md-option&amp;gt;        
    &amp;lt;/md-select&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;people: Person[] = [
  {id: 1, name: &amp;quot;taro&amp;quot;},
  {id: 2, name: &amp;quot;jiro&amp;quot;},
  {id: 3, name: &amp;quot;ichiro&amp;quot;}
];
assigneeFormControl = new FormControl();
filteredAssignee: Observable&amp;lt;Person[]&amp;gt;;

ngOnInit() {
  this.filteredAssignee = this.assigneeFormControl.valueChanges
        .startWith(null)
        .map(val =&amp;gt; val ? this.assigneeFilter(val) : this.people.slice());

  this.assigneeFormControl.asyncValidator
}

assigneeFilter(val: string): Person[] {
  return this.people.filter(p =&amp;gt; new RegExp(`^${val}`, &#39;gi&#39;).test(p.name)); 
}

displayAssignee(person: Person): string {
  return person ? person.name : &#39;&#39;;
}

export class TodoForm {
  constructor(
    public id: number,
    public title: string,
    public active: boolean,
    public priority?: number,
    public assignee?: Person,
  ) {  }
}

interface Person { id: number, name: string };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;datepicker&#34;&gt;DatePicker&lt;/h2&gt;

&lt;p&gt;最後に目標日を設定するためにDatePickerを用意する。
上にも書いた通り、material2にはまだDatepickerがないので他のライブラリで代用する。
今回はAngular v4に対応していて見た目がシンプルな&lt;a href=&#34;https://github.com/koleary94/Angular-2-Datepicker&#34;&gt;koleary94/Angular-2-Datepicker&lt;/a&gt;を使った。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save angular2-material-datepicker
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
  &amp;lt;material-datepicker placeholder=&amp;quot;終了予定日&amp;quot; [(date)]=&amp;quot;model.deadline&amp;quot;&amp;gt;&amp;lt;/material-datepicker&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CSSのdisplayとposition</title>
          <link>http://sambaiz.net/article/98/</link>
          <pubDate>Sat, 06 May 2017 14:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/98/</guid>
          <description>

&lt;h2 id=&#34;display-https-developer-mozilla-org-ja-docs-web-css-display&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/display&#34;&gt;display&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;レンダリングに使うボックスを指定する。&lt;/p&gt;

&lt;h3 id=&#34;outer-display-type&#34;&gt;outer display type&lt;/h3&gt;

&lt;p&gt;pのようなブロックレベル要素やspanのようなインラインレベル要素に関わらず、指定したボックスにレンダリングする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99.png&#34; alt=&#34;outer display type&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:none&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;none&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;p style=&amp;quot;display:inline&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline&amp;lt;/p&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;中央寄せ&#34;&gt;中央寄せ&lt;/h3&gt;

&lt;p&gt;中央寄せはblockにwidthを設定して&lt;code&gt;margin auto&lt;/code&gt;するか、
親要素で&lt;code&gt;text-align: center&lt;/code&gt;してinline(-block)にする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-center.png&#34; alt=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  height: 80px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin width&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;text-align: center&amp;quot;&amp;gt;
  
  &amp;lt;div style=&amp;quot;display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block align-center&amp;lt;/div&amp;gt;
  
  &amp;lt;div style=&amp;quot;width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block align-center width&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flex-https-developer-mozilla-org-ja-docs-web-css-css-flexible-box-layout-using-css-flexible-boxes&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes&#34;&gt;flex&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;displayでflexを指定するとflex containerになる。
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-flow&#34;&gt;flex-flow&lt;/a&gt;は
表示する方向の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-direction&#34;&gt;flex-direction&lt;/a&gt;と
折り返しの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-wrap&#34;&gt;flex-wrap&lt;/a&gt;のショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;子要素の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex&#34;&gt;flex&lt;/a&gt;は
伸びるときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-grow&#34;&gt;flex-grow&lt;/a&gt;(default: 0)と
縮むときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-shrink&#34;&gt;flex-shrink&lt;/a&gt;(default: 1)、
初期サイズの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-basis&#34;&gt;flex-basis&lt;/a&gt;(default: auto)の
ショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-flex.png&#34; alt=&#34;flex&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  this is
  &amp;lt;div style=&amp;quot;display:flex; flex-flow: row wrap&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;flex: auto; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item1&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 300px; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item2&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-grow | flex-shrink | flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 0 1 30%; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item3&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  desu
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;position-https-developer-mozilla-org-ja-docs-web-css-position&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/position&#34;&gt;position&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;relative&#34;&gt;relative&lt;/h3&gt;

&lt;p&gt;この設定を考慮せずにすべての要素を配置した後に設定を適用する。
そのため、この例の3つ目のdivの&lt;code&gt;left: 30px&lt;/code&gt;は2つ目のdivの元々の位置から30px右になっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-relative.png&#34; alt=&#34;relative&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 30px; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;bbb&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;ccc&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute&#34;&gt;absolute&lt;/h3&gt;

&lt;p&gt;絶対位置で指定する。位置指定された祖先要素の相対的な位置になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-absolute.png&#34; alt=&#34;absolute&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 50px&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;background-color: #eeeeee&amp;quot;&amp;gt;relative top 50px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; left: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;left 100px&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fixed&#34;&gt;fixed&lt;/h3&gt;

&lt;p&gt;ビューポートに対して絶対的な位置を指定する。この例では2つ目のfixedなdivはスクロールしてもビューポートに対して位置が固定される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-fixed.png&#34; alt=&#34;fixed&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;height: 3000px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;position: fixed; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AngularのRouter</title>
          <link>http://sambaiz.net/article/97/</link>
          <pubDate>Sun, 30 Apr 2017 22:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/97/</guid>
          <description>

&lt;pre&gt;&lt;code&gt;@angular/core&amp;quot;: 4.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/40/&#34;&gt;Angular2とangular-cliでTODOを作る - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular-cli&lt;/code&gt;は&lt;code&gt;@angular/cli&lt;/code&gt;に&lt;a href=&#34;https://github.com/angular/angular-cli/commit/601f9b38f8ce53052d623a4b8a2dc5bb30f9eee1&#34;&gt;変更された&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;routingを行うのでnewで&lt;code&gt;--routing&lt;/code&gt;オプションを付けている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g @angular/cli
$ ng -v
@angular/cli: 1.0.1

$ ng new angular4-routing --routing
$ cd angular4-routing/
$ cat package.json | grep @angular/core
    &amp;quot;@angular/core&amp;quot;: &amp;quot;^4.0.0&amp;quot;,

$ ng serve
** NG Live Development Server is running on http://localhost:4200 **     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--routing&lt;/code&gt;を付けたので&lt;code&gt;app-routing.module.ts&lt;/code&gt;が作成され、&lt;code&gt;app.module.ts&lt;/code&gt;にAppRoutingModuleが追加される。
&lt;code&gt;index.html&lt;/code&gt;のheadにはpushStateのroutingが働くように
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&#34;&gt;base&lt;/a&gt;要素が
&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#base-href&#34;&gt;追加されている&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { NgModule } from &#39;@angular/core&#39;;
import { Routes, RouterModule } from &#39;@angular/router&#39;;

const routes: Routes = [
  {
    path: &#39;&#39;,
    children: []
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;app.component.html&lt;/code&gt;に&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#router-outlet&#34;&gt;router-outlet&lt;/a&gt;が置かれていてroutingによるComponentはこの下に描画される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;
  {{title}}
&amp;lt;/h1&amp;gt;
&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動的に追加されるコンポーネントのstyleは&lt;code&gt;@HostBinding&lt;/code&gt;で設定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class TodoMainComponent implements OnInit {

  @HostBinding(&#39;style.width&#39;)   width = &#39;100%&#39;;

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ルーティング定義-https-angular-io-docs-ts-latest-guide-router-html-route-config&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-config&#34;&gt;ルーティング定義&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;children&lt;/code&gt;で&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#child-routing-component&#34;&gt;child route&lt;/a&gt;を設定しているが、
これは親コンポーネントの&lt;code&gt;router-outlet&lt;/code&gt;の下に描画される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component todo/todo-main
$ ng g component todo/todo-list
$ ng g component todo/todo-item
$ ng g component not-found
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { NgModule } from &#39;@angular/core&#39;;
import { Routes, RouterModule } from &#39;@angular/router&#39;;

import { TodoMainComponent } from &#39;./todo/todo-main/todo-main.component&#39;
import { TodoListComponent } from &#39;./todo/todo-list/todo-list.component&#39;
import { TodoItemComponent } from &#39;./todo/todo-item/todo-item.component&#39;
import { NotFoundComponent } from &#39;./not-found/not-found.component&#39;

const routes: Routes = [
  {
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
  },
  {
    path: &#39;**&#39;,
    component: NotFoundComponent,
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-main works!
&amp;lt;/p&amp;gt;
&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;a href=&#34;http://localhost:4200/todo&#34;&gt;http://localhost:4200/todo&lt;/a&gt; にアクセスすると、&lt;code&gt;TodoMainComponent&lt;/code&gt;と&lt;code&gt;TodoListComponent&lt;/code&gt;が表示される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app works!

todo-main works!

todo-list works!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パラメータの取得-https-angular-io-docs-ts-latest-guide-router-html-route-parameters-activated-route&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-parameters-activated-route&#34;&gt;パラメータの取得&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ActivatedRoute&lt;/code&gt;をDIしてObservableなparamsをSubscribeする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit, HostBinding } from &#39;@angular/core&#39;;
import { Router, ActivatedRoute, Params } from &#39;@angular/router&#39;;

@Component({
  selector: &#39;app-todo-item&#39;,
  templateUrl: &#39;./todo-item.component.html&#39;,
  styleUrls: [&#39;./todo-item.component.css&#39;]
})
export class TodoItemComponent implements OnInit {

  id: number;

  constructor(
    private route: ActivatedRoute,
  ) { }

  ngOnInit() {  
    this.route.params.subscribe(
      (params: Params) =&amp;gt; this.id = +params[&#39;id&#39;]
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-item ({{id}}) works!
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;遷移&#34;&gt;遷移&lt;/h2&gt;

&lt;p&gt;タグなら&lt;code&gt;&amp;lt;a routerLink&amp;gt;&lt;/code&gt;を、コードなら&lt;code&gt;Router.navigate&lt;/code&gt;を使って遷移できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-item ({{id}}) works!
  &amp;lt;button (click)=&amp;quot;onClickNext()&amp;quot;&amp;gt;Next&amp;lt;/button&amp;gt;
  &amp;lt;a routerLink=&amp;quot;/todo&amp;quot;&amp;gt;todos&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
export class TodoItemComponent implements OnInit {

  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) { }

  ...

  onClickNext() {
    if(typeof this.id !== &#39;undefined&#39;){
      this.router.navigate([`/todo/${this.id+1}`, {hoge: &amp;quot;fuga&amp;quot;}]);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;navigateでhogeという適当なパラメータを付けているが、呼ぶと&lt;code&gt;http://localhost:4200/todo/10;hoge=fuga&lt;/code&gt;のように
クエリパラメータが&lt;code&gt;?, &amp;amp;&lt;/code&gt;ではなく&lt;code&gt;;&lt;/code&gt;で区切られたURLに遷移する。
これをmatrix URL notationといって、&lt;a href=&#34;https://www.w3.org/DesignIssues/MatrixURIs.html&#34;&gt;結構由緒正しい&lt;/a&gt;ものらしい。&lt;/p&gt;

&lt;h2 id=&#34;guard-https-angular-io-docs-ts-latest-guide-router-html-guards&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#guards&#34;&gt;Guard&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;routeの遷移時に何かするためのもの。
具体的にはログインしているかどうかをチェックしたりとか、
遷移する前にデータを一時保存したりとかそういうのに使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g guard auth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanActivate-interface.html&#34;&gt;canActivate()&lt;/a&gt;
はrouteに遷移するときに呼ばれ、trueを返すとそのまま続行され、falseを返すと中断される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable } from &#39;@angular/core&#39;;
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &#39;@angular/router&#39;;
import { Observable } from &#39;rxjs/Observable&#39;;

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable&amp;lt;boolean&amp;gt; | Promise&amp;lt;boolean&amp;gt; | boolean {
    console.log(`canActivate(): ${state.url}`);
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AppModuleのprovidersにAuthGuardを入れて、routesにも&lt;code&gt;canActivate&lt;/code&gt;としてAuthGuardを設定すると呼ばれるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { AuthGuard } from &#39;./auth.guard&#39;

const routes: Routes = [
  {
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    canActivate: [AuthGuard],
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
  },
  {
    path: &#39;**&#39;,
    component: NotFoundComponent,
  }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定だと上で追加したNextボタンを押してchild routeに遷移したときには呼ばれない。
&lt;code&gt;canActivateChild()&lt;/code&gt;にするとchild routeに遷移したときにも呼ばれるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&amp;lt;boolean&amp;gt; | Promise&amp;lt;boolean&amp;gt; | boolean {
  return this.canActivate(route, state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    canActivateChild: [AuthGuard],
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの他には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html&#34;&gt;canDeactivate()&lt;/a&gt;: 今のrouteから離れるとき&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/Resolve-interface.html&#34;&gt;resolve()&lt;/a&gt;: コンポーネントを表示する前。pre-fetchのため。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanLoad-interface.html&#34;&gt;canLoad()&lt;/a&gt;: &lt;code&gt;loadChildren&lt;/code&gt;で指定したModuleを&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#lazy-loading-route-config&#34;&gt;lazy load&lt;/a&gt;
するとき。ドキュメントではAdminModuleに対して、認証されていなかったらロードしないようにしている。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のGuardがある。&lt;/p&gt;

&lt;h2 id=&#34;アニメーション-https-angular-io-docs-ts-latest-guide-router-html-route-animation&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-animation&#34;&gt;アニメーション&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;app.module.ts&lt;/code&gt;に&lt;code&gt;BrowserAnimationsModule&lt;/code&gt;を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save @angular/animations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;

@NgModule({
  ...
  imports: [
    ...
    BrowserAnimationsModule
  ],
  ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;animations.ts&lt;/code&gt;を作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { animate, AnimationEntryMetadata, state, style, transition, trigger } from &#39;@angular/core&#39;;

// Component transition animations
export const slideInDownAnimation: AnimationEntryMetadata =
  trigger(&#39;routeAnimation&#39;, [
    state(&#39;*&#39;,
      style({
        opacity: 1,
        transform: &#39;translateX(0)&#39;
      })
    ),
    transition(&#39;:enter&#39;, [
      style({
        opacity: 0,
        transform: &#39;translateX(-100%)&#39;
      }),
      animate(&#39;0.2s ease-in&#39;)
    ]),
    transition(&#39;:leave&#39;, [
      animate(&#39;0.5s ease-out&#39;, style({
        opacity: 0,
        transform: &#39;translateY(100%)&#39;
      }))
    ])
  ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを@Componentのanimationsに入れて&lt;code&gt;@HostBinding&lt;/code&gt;でanimationのトリガー(routeAnimation)を発火させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit, HostBinding } from &#39;@angular/core&#39;;
import { Router, ActivatedRoute, Params } from &#39;@angular/router&#39;;
import { slideInDownAnimation } from &#39;../../animations&#39;;

@Component({
  selector: &#39;app-todo-item&#39;,
  templateUrl: &#39;./todo-item.component.html&#39;,
  styleUrls: [&#39;./todo-item.component.css&#39;],
  animations: [ slideInDownAnimation ]
})
export class TodoItemComponent implements OnInit {

  @HostBinding(&#39;@routeAnimation&#39;) routeAnimation = true;
  @HostBinding(&#39;style.display&#39;)   display = &#39;block&#39;;
  @HostBinding(&#39;style.position&#39;)  position = &#39;absolute&#39;;

  id: number;

  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) { }

  ngOnInit() {  
    this.route.params.subscribe(
      (params: Params) =&amp;gt; this.id = +params[&#39;id&#39;]
    );
  }

  onClickNext() {
    this.router.navigate([&#39;/todo&#39;, {id: this.id + 1, hoge: &amp;quot;fuga&amp;quot;}])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにアニメーションする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/97.gif&#34; alt=&#34;アニメーション&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのStream API</title>
          <link>http://sambaiz.net/article/96/</link>
          <pubDate>Sat, 22 Apr 2017 19:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/96/</guid>
          <description>

&lt;h2 id=&#34;stream-apiとは-https-nodejs-org-docs-v7-9-0-api-stream-html&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html&#34;&gt;Stream APIとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NodeでStreamデータを扱うためのもの。
例えばサイズが大きいファイルの入出力をStreamとして扱うことでバッファを最小限にできる。&lt;/p&gt;

&lt;p&gt;Streamは&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/events.html&#34;&gt;EventEmitter&lt;/a&gt;で、
Readable streamやWritable stream、ReadableとWritableを合わせたDuplex streamと
Readしたものを加工してWriteするTransform streamの種類があり、
それぞれ特定の関数が&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_api_for_stream_implementers&#34;&gt;実装&lt;/a&gt;されている必要がある。&lt;/p&gt;

&lt;h2 id=&#34;readable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-streams&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_streams&#34;&gt;Readable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamには&lt;code&gt;flowing&lt;/code&gt;と&lt;code&gt;paused&lt;/code&gt;の
&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_two_modes&#34;&gt;二つのモード&lt;/a&gt;がある。
最初は&lt;code&gt;paused&lt;/code&gt;モードで、readableになってからread()することで読むことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;readable&#39;, () =&amp;gt; {
  let chunk;
  while (null !== (chunk = readable.read(10))) {
    console.log(`${i++}: ${chunk}`);
  }
});
dable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat sample.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

$ node main.js
0: abcdefghij
1: klmnopqrst
2: uvwxyz
123
3: 4567890
あい
4: うえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dataのイベントハンドラーを追加するか、後で書くpipeを使うと&lt;code&gt;flowing&lt;/code&gt;モードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0: abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーハンドリングはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js
{ Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native) errno: -2, code: &#39;ENOENT&#39;, syscall: &#39;open&#39;, path: &#39;error.txt&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-readable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_readable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_read&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Readable = require(&#39;stream&#39;).Readable;

class Random extends Readable {
  constructor(opt) {
    super(opt); 
  }
  
  _read() {
    
    // error handling
    // if(err){ 
    //   this.emit(&#39;error&#39;, err)
    //   return
    // }
    
    this.push(Math.random()+&#39;&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;writable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-class-stream-writable&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_class_stream_writable&#34;&gt;Writable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;output.txtに出力するWritable stream。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let writable = fs.createWriteStream(&#39;output.txt&#39;)

writable.write(&#39;hoge\n&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力の流量が多く、Writable streamのバッファが&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_constructor_new_stream_writable_options&#34;&gt;highWaterMark&lt;/a&gt;を超えてしまうと、write()はfalseを返す。そのまま書き込み続けるとメモリを食いつぶしてしまうので、
全てのバッファが捌けて&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_event_drain&#34;&gt;drain&lt;/a&gt;イベントが発行されるまで書き込みを止めてback-pressureとする必要がある。
ただし、pipeを使う場合このあたりはやってくれるので、あまり気にすることはない。&lt;/p&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-writable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_writable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_write&lt;/code&gt;と、バッファされているchunkをまとめて扱うなら&lt;code&gt;_writev&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Writable = require(&#39;stream&#39;).Writable;

class DummyWritable extends Writable {
  constructor(opt) {
    super(opt);
  }

  _write(chunk, encoding, callback) {
    const chunkStr = chunk.toString()
    if (chunkStr == &#39;this is error&#39;) {
      callback(new Error(&#39;chunk is invalid&#39;));
    } else {
      console.log(chunkStr);
      callback();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipe-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-pipe-destination-options&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_pipe_destination_options&#34;&gt;pipe&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamをWritable streamとつなげる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
readable.pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意すべきなのは、pipeしたものをまとめてエラーハンドリングすることはできないこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
let piped = readable.pipe(writable);

piped.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;events.js:160
      throw er; // Unhandled &#39;error&#39; event
      ^

Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面倒だけど、毎度エラーハンドリングする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
const errorHandling = (err) =&amp;gt; { console.log(err) }
let piped = readable.on(&#39;error&#39;, errorHandling).pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeを組み合わせると、こんな風にcsvをfetchして加工し、文字コードを変えて出力するといったこともStreamでできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fetch = require(&#39;node-fetch&#39;);
const Iconv = require(&#39;iconv&#39;).Iconv;
const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
const csv = require(&#39;csv&#39;);
const fs = require(&#39;fs&#39;);

const errorHandling = (err) =&amp;gt; { console.log(err); };

const outputFile = fs.createWriteStream(&#39;output.csv&#39;);

fetch(&#39;http://example.com/test.csv&#39;).then((res) =&amp;gt; {

  res.body
  .pipe(csv.parse({columns : true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.transform(function(record){
    if(record[&#39;hoge&#39;] &amp;lt; 100000){
      return null;
    }
    return record;
  }))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.stringify({header: true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(iconv)
  .on(&#39;error&#39;, errorHandling)
  .pipe(outputFile)
  .on(&#39;error&#39;, errorHandling);

}).then(() =&amp;gt; console.log(&amp;quot;done&amp;quot;)).catch((err) =&amp;gt; console.log(err));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeではないけど、readlineのcreateInterfaceに入力と出力のStreamを渡すと、
行ごとに処理することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);

let readable = fs.createReadStream(&#39;sample.txt&#39;);
const rl = readline.createInterface({
  input: readable,
  output: process.stdout
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rxjsで扱う&#34;&gt;RxJSで扱う&lt;/h2&gt;

&lt;p&gt;StreamはEventEmitterなのでRxJSのfromEvent()でObservableとして扱うこともできる。ただし&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;v5&lt;/a&gt;にはpipeがない(v4には&lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS/blob/8fa95ac884181fb6cbff8ce7c1d669ffb190f5e4/src/core/linq/observable/pipe.js#L6&#34;&gt;ある&lt;/a&gt;)ので、pipeする場合は自分でSubscribeしてwriteする必要がありそう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const Rx = require(&#39;rxjs/Rx&#39;);
const writable = fs.createWriteStream(&#39;output.txt&#39;)

Rx.Observable.fromEvent(process.stdin, &#39;data&#39;)
.map((v) =&amp;gt; `- ${v}`)
.subscribe((v) =&amp;gt; write(v));

function write(v){
  // TODO: back-pressure
  writable.write(v);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js 
aiueo
kakikukeko
^C

$ cat output.txt 
- aiueo
- kakikukeko
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>tmuxのメモ</title>
          <link>http://sambaiz.net/article/95/</link>
          <pubDate>Fri, 21 Apr 2017 00:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/95/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://tmux.github.io/&#34;&gt;https://tmux.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;セッションを立ち上げてその中で複数のウィンドウやペインからコマンドを実行できるやつ。
サーバーでの作業中にネットワークが切断されてしまってもセッションをattachすることで再開することができる。
ローカル環境でもコマンドキーでのウィンドウ作成やペインの分割、
複数のサーバーにsshで入って調査するようなときにペインの同時入力は便利。
もちろんターミナルを閉じてしまっても再開できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install tmux
$ tmux
$ tmux ls
$ tmux a # sessionをattachする
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind key(デフォルトで&lt;code&gt;Ctrl + b&lt;/code&gt;)を入れてからコマンドキーを入れる。よく使うもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c: 新しいウインドウをCreateする&lt;/li&gt;
&lt;li&gt;d: 今のクライアントをDetachする&lt;/li&gt;
&lt;li&gt;n: Nextウィンドウに移動する&lt;/li&gt;
&lt;li&gt;p: Previousウィンドウに戻る&lt;/li&gt;
&lt;li&gt;w: Windowを一覧表示して選択する&lt;/li&gt;
&lt;li&gt;x: ペインを削除する&lt;/li&gt;
&lt;li&gt;,: ウィンドウの名前を変更する&lt;/li&gt;
&lt;li&gt;z: ウィンドウ一杯にペインをzoomする/解除&lt;/li&gt;
&lt;li&gt;[: ペイン内をスクロールできるようになる。qで解除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;~/.tmux.conf&lt;/code&gt;はこんな感じにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bind keyをC-tに変更してC-bを解除
set -g prefix C-t
unbind C-b

# Vimのキーバインドでペインを移動する
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# - でペインを横に分割する(縦に切る)
bind - split-window -h

# | でペインを縦に分割する(横に切る)
bind | split-window -v

# 同時入力
bind s set-window-option synchronize-panes on
bind S set-window-option synchronize-panes off
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Firebaseをwebで使う(Hosting, Authentication, Realtime Database, Storage)</title>
          <link>http://sambaiz.net/article/94/</link>
          <pubDate>Sun, 16 Apr 2017 20:03:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/94/</guid>
          <description>

&lt;h2 id=&#34;firebase-https-firebase-google-com-hl-ja-とは&#34;&gt;&lt;a href=&#34;https://firebase.google.com/?hl=ja&#34;&gt;Firebase&lt;/a&gt;とは&lt;/h2&gt;

&lt;p&gt;GoogleのmBaaS。Android/iOSアプリの開発に使う認証、データストア、クラッシュレポート、分析、通知、広告などなど全部入りサービス。
今年のGoogleI/Oでも&lt;a href=&#34;https://events.google.com/io/schedule/?section=may-19&#34;&gt;毎時間のように&lt;/a&gt;
Firebaseのセッションがあって大分推している印象。&lt;/p&gt;

&lt;p&gt;基本的にはアプリで使うのだけれど、webで使える機能も結構ある。今回は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hosting&lt;/li&gt;
&lt;li&gt;Authentication&lt;/li&gt;
&lt;li&gt;Realtime Database&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を使ってみる。&lt;/p&gt;

&lt;h2 id=&#34;料金-https-firebase-google-com-pricing&#34;&gt;&lt;a href=&#34;https://firebase.google.com/pricing/&#34;&gt;料金&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;プランは無料のSPARKと25ドル/月のFLAME、従量課金のBLAZEがある。
試す分にはSPARKで十分だけど、Realtime Databaseの同時接続数が100なので注意。&lt;/p&gt;

&lt;h2 id=&#34;セットアップ-https-firebase-google-com-docs-web-setup&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/web/setup&#34;&gt;セットアップ&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/cli/&#34;&gt;firebase-cli&lt;/a&gt;をインストール、ログインして初期化する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g firebase-tools
$ firebase login
$ mkdir firebase-chat &amp;amp;&amp;amp; cd firebase-chat
$ firebase init
...
? What Firebase CLI features do you want to setup for this folder? 
❯◉ Database: Deploy Firebase Realtime Database Rules
 ◉ Functions: Configure and deploy Cloud Functions
 ◉ Hosting: Configure and deploy Firebase Hosting sites

? What Firebase project do you want to associate as default? *****

? What file should be used for Database Rules? database.rules.json

? Do you want to install dependencies with npm now? Yes

? What do you want to use as your public directory? public

? Configure as a single-page app (rewrite all urls to /index.html)? Yes

✔  Firebase initialization complete!

$ ls
database.rules.json	firebase.json		functions		public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;firebase.jsonはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat firebase.json
{
  &amp;quot;database&amp;quot;: {
    &amp;quot;rules&amp;quot;: &amp;quot;database.rules.json&amp;quot;
  },
  &amp;quot;hosting&amp;quot;: {
    &amp;quot;public&amp;quot;: &amp;quot;public&amp;quot;,
    &amp;quot;rewrites&amp;quot;: [
      {
        &amp;quot;source&amp;quot;: &amp;quot;**&amp;quot;,
        &amp;quot;destination&amp;quot;: &amp;quot;/index.html&amp;quot;
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルでサーバーを立ち上げて確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase serve
Server listening at: http://localhost:5000

$ curl http://localhost:5000 # Firebase SDK loaded with auth, database, messaging, storage
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hosting-https-firebase-google-com-docs-hosting-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/hosting/?hl=ja&#34;&gt;Hosting&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;静的サイトのホスティング。もちろん独自ドメインも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only hosting
...
✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/*****/overview
Hosting URL: https://*****.firebaseapp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;authentication-https-firebase-google-com-docs-auth&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/auth/&#34;&gt;Authentication&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ユーザー認証。Googleだけではなく、TwitterやFacebook、Githubといったプロバイダや、メールとパスワードでの認証が用意されていて、
コンソールから有効にする必要がある。&lt;/p&gt;

&lt;p&gt;実装はFirebase SDKで自分でやるか、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const provider = new firebase.auth.GoogleAuthProvider();
firebase.auth().signInWithPopup(provider).then((result) =&amp;gt; {
    console.log(`sign in successfully. ${result.user.displayName}`)
}).catch((error) =&amp;gt; {
    console.log(`fail to sign in. ${error.message}`)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/firebase/FirebaseUI-Web&#34;&gt;FirebaseUI Auth&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script defer src=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.css&amp;quot; /&amp;gt;

&amp;lt;div id=&amp;quot;firebaseui-auth-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// FirebaseUI config.
var uiConfig = {
  signInOptions: [
    // Leave the lines as is for the providers you want to offer your users.
    firebase.auth.GoogleAuthProvider.PROVIDER_ID
  ],
  callbacks: {
    signInSuccess: function(currentUser, credential, redirectUrl) {
      // リダイレクトさせない
      return false;
    }
  },
  // Terms of service url.
  tosUrl: &#39;&amp;lt;your-tos-url&amp;gt;&#39;
};

// Initialize the FirebaseUI Widget using Firebase.
var ui = new firebaseui.auth.AuthUI(firebase.auth());
// The start method will wait until the DOM is loaded.
ui.start(&#39;#firebaseui-auth-container&#39;, uiConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにボタンが並ぶ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/93-firebase-authentication.png&#34; alt=&#34;Firebase authentication&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;onAuthStateChanged()&lt;/code&gt;でsign in/outをハンドリングでき、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firebase.auth().onAuthStateChanged((user) =&amp;gt; {
    if (user) {
      console.log(`${user.displayName} sign in`);
    } else {
      console.log(&#39;sign out&#39;);
    }
  }, (error) =&amp;gt; {
    console.log(error);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;currentUserでsign inしてるユーザーを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(firebase.auth().currentUser){
  console.log(firebase.auth().currentUser.displayName);
}else{
  // need to sign in
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;realtime-database-https-firebase-google-com-docs-database&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/&#34;&gt;Realtime Database&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NoSQLなデータベース。直接読み書きするのではなく、
ローカルにデータを保存してリアルタイムに同期するため一時的にオフライン状態になっても読み書きできる。&lt;/p&gt;

&lt;h3 id=&#34;読み書き-https-firebase-google-com-docs-database-web-read-and-write&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/web/read-and-write&#34;&gt;読み書き&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;データベースへの書き込みと更新。refで&lt;code&gt;users/1&lt;/code&gt;のように参照を取って操作する。
&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#push&#34;&gt;push()&lt;/a&gt;で
&lt;code&gt;hoge/-Khp36CCygw5AI6G8L1B&lt;/code&gt;のようなユニークなキーを発行することができ、これは時系列にソートされるようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const database = firebase.database();

for(let i = 0; i &amp;lt; 10; i++){
    
    const newHogeRef = database.ref(&#39;hoge&#39;).push();
    console.log(`newHogeRef: ${newHogeRef.toString()}`);
    
    newHogeRef.set({
        idx: i,
        aaa: &amp;quot;bbb123&amp;quot;,
    });

    newHogeRef.update({
        aaa: &amp;quot;bbb456&amp;quot;,
        eee: &amp;quot;fff&amp;quot;
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CCygw5AI6G8L1B
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CLyJ9BQVefW-l5
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CMs9-jJoKUUgr0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#on&#34;&gt;on()&lt;/a&gt;で
value eventを拾うと、
呼んだときとデータに変更があったときに&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.DataSnapshot?hl=ja&#34;&gt;snapshot&lt;/a&gt;が取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 7}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 8}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 9}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス権限-バリデーション-https-firebase-google-com-docs-database-security-securing-data&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data&#34;&gt;アクセス権限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;firebase.jsonで指定しているdatabase ruleファイル(database.rules.json)でルールを設定する。
デフォルトで認証していれば読み書きできる設定になっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read/writeだけではなくバリデーションの設定もこんな感じでできる。
これは&lt;code&gt;users/${ユーザーのuid}&lt;/code&gt;への読み書きを本人のみができるようにするもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only database
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の設定を適用したデータベースに読み書きしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const uid = firebase.auth().currentUser.uid;

database.ref(`users/${uid}`).set({
    age: 20,
    name: &amp;quot;taro&amp;quot;
});

// ok: Object {age: 20, name: &amp;quot;taro&amp;quot;}
database.ref(`users/${uid}`).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    console.log(snapshot.val()); // Object {age: 20, name: &amp;quot;taro&amp;quot;}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のような不正なデータや不正なキーに書き込もうとすると
&lt;code&gt;PERMISSION_DENIED: Permission denied&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ageがおかしい
database.ref(`users/${uid}`).set({
    age: &amp;quot;aaaa&amp;quot;,
    name: &amp;quot;jiro&amp;quot;
});

// 本人じゃない
database.ref(`users/hogehoge`).set({
    age: 20,
    name: &amp;quot;jiro&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、さっきまでアクセスできていたhogeにもアクセスできなくなっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// PERMISSION_DENIED: Permission denied
database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを解決するためにrulesのルートに&lt;code&gt;auth != null&lt;/code&gt;の設定を入れてしまうと、
&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data#read_and_write_rules_cascade&#34;&gt;浅い階層のルールが深い階層のルールより優先される&lt;/a&gt;
ためusersのread/writeの設定が無効になってしまうので注意。ただしvalidateはそれぞれの階層でチェックされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;storage-https-firebase-google-com-docs-storage&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/&#34;&gt;Storage&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;画像などを保存しておくために使う。
Realtime Databaseと同様、
ネットワーク品質が良くない環境でも使えるように、処理が中断されても途中から処理を再開するようになっている。
裏側ではGoogle Cloud Storageが使われている。&lt;/p&gt;

&lt;h3 id=&#34;アップロード-https-firebase-google-com-docs-storage-web-upload-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/upload-files&#34;&gt;アップロード&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file-upload&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const storage = firebase.storage();

const inputFile = document.getElementById(&#39;file-upload&#39;);

inputFile.addEventListener(&#39;change&#39;, (e) =&amp;gt; {
  const files = e.target.files;
  const user = firebase.auth().currentUser;
  if(user){
    const ref = storage.ref(`images/${user.uid}`);
    const uploadTask = ref.put(files[0]);
  }
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中断、再開、キャンセル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.pause();
uploadTask.resume();
uploadTask.cancel();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アップロードの状態はstage_changed eventで確認し、完了するとダウンロードURLを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.on(&#39;state_changed&#39;, (snapshot) =&amp;gt; {

  const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
  console.log(&#39;Upload is &#39; + progress + &#39;% done&#39;);

  switch (snapshot.state) {
    case firebase.storage.TaskState.PAUSED: // or &#39;paused&#39;
      console.log(&#39;Upload is paused&#39;);
      break;
    case firebase.storage.TaskState.RUNNING: // or &#39;running&#39;
      console.log(&#39;Upload is running&#39;);
      break;
  }
}, (error) =&amp;gt; {
  // Handle unsuccessful uploads
  console.log(error);
}, () =&amp;gt; {
  // Handle successful uploads on complete
  // For instance, get the download URL: https://firebasestorage.googleapis.com/...
  console.log(uploadTask.snapshot.downloadURL);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス制限-バリデーション-https-firebase-google-com-docs-storage-security-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/security/?hl=ja&#34;&gt;アクセス制限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Realtime Databaseと同様にアクセス制限やバリデーションをかけることができる。
設定はコンソールから。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/93-firebase-storage-rule.png&#34; alt=&#34;Storageのルール&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service firebase.storage {
  match /b/*****.appspot.com/o {
    match /images/{imageId} {
      // Only allow uploads of any image file that&#39;s less than 5MB
      allow write: if request.resource.size &amp;lt; 5 * 1024 * 1024
                   &amp;amp;&amp;amp; request.resource.contentType.matches(&#39;image/.*&#39;)
                   &amp;amp;&amp;amp; request.auth != null;
      allow read: if request.auth != null;             
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ダウンロード-https-firebase-google-com-docs-storage-web-download-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/download-files&#34;&gt;ダウンロード&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;getDownloadURL()&lt;/code&gt;でURLを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img id=&amp;quot;myimg&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const ref = storage.ref(`images/${user.uid}`).getDownloadURL().then((url) =&amp;gt; {
  
  const img = document.getElementById(&#39;myimg&#39;);
  img.src = url;

}).catch((error) =&amp;gt; {

  switch (error.code) {
    case &#39;storage/object-not-found&#39;:
      console.log(&amp;quot;not found&amp;quot;);
      break;

    default:
      console.log(error);
  }
});;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>MySQLのALTER TABLEのメモ</title>
          <link>http://sambaiz.net/article/93/</link>
          <pubDate>Sat, 15 Apr 2017 19:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/93/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/ja/alter-table.html&#34;&gt;MySQL :: MySQL 5.6 リファレンスマニュアル :: 13.1.7 ALTER TABLE 構文&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE t0 (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    c1 VARCHAR(30),
    c2 VARCHAR(30)
);
CREATE TABLE t2 (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE t0 RENAME t1;
ALTER TABLE t1
  ADD COLUMN t2_id BIGINT UNSIGNED AFTER id,
  ADD COLUMN c3 INTEGER NOT NULL AFTER t2_id,
  MODIFY COLUMN c1 VARCHAR(30) NOT NULL,
  DROP COLUMN c2,
  ADD INDEX (c3),
  ADD FOREIGN KEY (t2_id) REFERENCES t2(id) ON UPDATE CASCADE ON DELETE CASCADE
;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW CREATE TABLE t1 \G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `t2_id` bigint(20) unsigned DEFAULT NULL,
  `c3` int(11) NOT NULL,
  `c1` varchar(30) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `c3` (`c3`),
  KEY `t2_id` (`t2_id`),
  CONSTRAINT `t1_ibfk_1` FOREIGN KEY (`t2_id`) REFERENCES `t2` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE t1
  DROP INDEX c3,
  DROP FOREIGN KEY t1_ibfk_1,
  DROP INDEX t2_id
;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW CREATE TABLE t1 \G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `t2_id` bigint(20) unsigned DEFAULT NULL,
  `c3` int(11) NOT NULL,
  `c1` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityのパーティクル設定(Shuriken)</title>
          <link>http://sambaiz.net/article/92/</link>
          <pubDate>Thu, 13 Apr 2017 17:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/92/</guid>
          <description>

&lt;p&gt;Unityには&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/class-ParticleSystem.html&#34;&gt;Shuriken&lt;/a&gt;というパーティクルシステムがある。&lt;/p&gt;

&lt;p&gt;Sphereを置いてParticle Systemを追加すると、Particleが出始める。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-1.png&#34; alt=&#34;Particleの初期状態&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;モジュール&#34;&gt;モジュール&lt;/h2&gt;

&lt;p&gt;設定項目が多いためモジュールに分かれている。ひとまずデフォルトで有効になっている&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(メインモジュール)&lt;/li&gt;
&lt;li&gt;Emission&lt;/li&gt;
&lt;li&gt;Shape&lt;/li&gt;
&lt;li&gt;Renderer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;について見ていく。&lt;/p&gt;

&lt;h3 id=&#34;メインモジュール-https-docs-unity3d-com-550-documentation-manual-partsysmainmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysMainModule.html&#34;&gt;メインモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Duration: 5&lt;/li&gt;
&lt;li&gt;Looping: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;デフォルトだとLoopingにチェックが入っているのでずっと出ているが、チェックを外すとDurationで止まる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Delay: 0&lt;/li&gt;
&lt;li&gt;Play On Awake: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PlayOnAwakeがtrueでStartDelayが0なので実行してからすぐにParticleが出始める。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Lifetime: 5&lt;/li&gt;
&lt;li&gt;Max Particles: 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartLifetimeはParticleが消えるまでの時間。ただしMaxParticlesに達したら消される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Speed: 5&lt;/li&gt;
&lt;li&gt;Simulation Speed: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartSpeedはParticleの初速で、上げると勢い良く飛んでいく。
SimulationSpeedを上げるとParticleが出るのも含めて全体のスピードが上がる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Size: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期サイズ。小さくすると塵みたいになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Rotation: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期角度。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gravity Modifier: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重力値。0だと無重力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Simulation Space: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleをlocal座標かworld座標で動かすか。
Localだとオブジェクトが移動したときに一緒に移動する。Worldだと置いてかれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scaling Mode: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ParticleのScale。LocalだとそのオブジェクトのScaleだけを見る。Hierarchyだと親も考慮したScale。Shapeだと開始位置だけ。&lt;/p&gt;

&lt;h3 id=&#34;emissionモジュール-https-docs-unity3d-com-550-documentation-manual-partsysemissionmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysEmissionModule.html&#34;&gt;Emissionモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Rate over time: 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単位時間あたりにParticleを出す数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rate over Distance: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;オブジェクトが移動するときにParticleを出す数。Simulation SpaceがWorldのときのみ有効。&lt;/p&gt;

&lt;h3 id=&#34;shapeモジュール-https-docs-unity3d-com-550-documentation-manual-partsysshapemodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysShapeModule.html&#34;&gt;Shapeモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shape: Corn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleを出す形。Cornだと特定方向に向けた円錐状に出る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-corn.png&#34; alt=&#34;ShapeがCorn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Spehreで全方向に出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-sphere.png&#34; alt=&#34;ShapeがSphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hemisphereで片側だけ出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-hemisphere.png&#34; alt=&#34;ShapeがHemisphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;EdgeでY方向に直線上に出したりすることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-edge.png&#34; alt=&#34;ShapeがEdge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そのほかのパラメータはShapeに応じて設定する。&lt;/p&gt;

&lt;h3 id=&#34;rendererモジュール-https-docs-unity3d-com-550-documentation-manual-partsysrenderermodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysRendererModule.html&#34;&gt;Rendererモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Render Mode: Billboard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleがどのようにレンダリングされるか。Billboardは常にカメラに向くようにレンダリングされる。&lt;/p&gt;

&lt;p&gt;Stretched Billboardにするとカメラの方向に向きながら、&lt;a href=&#34;https://en.wikipedia.org/wiki/Squash_and_stretch&#34;&gt;stretch and squash&lt;/a&gt;させる。つまり速度を強調するように変形させる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-stretched-billboard.png&#34; alt=&#34;Render ModeがStretched Billboard&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material: None&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleのmaterial。これにDefault-Particleを指定するとこうなる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-default-particle.png&#34; alt=&#34;MaterialがDefault Particle&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;afterburner&#34;&gt;AfterBurner&lt;/h2&gt;

&lt;p&gt;Standard AssetsにあるAfterBurnerの設定を見てみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner.png&#34; alt=&#34;AfterBurner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;中央の濃い部分と、そのまわりの薄い部分の2つの設定を組み合わせている。
Explosionとかは9個組み合わせているので比較的シンプル。&lt;/p&gt;

&lt;p&gt;濃い部分ではEmissionのRate over Timeを80にすることで続いているように見えるようにして、
Size over LifetimeモジュールのSizeを徐々に小さくすることによって尾の方にかけて細くなるようにしている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-size.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;さらにColor over LifetimeモジュールのColorで両端のAlphaを0、Location 6.0%のAlphaを30に設定することで、
素早くフェードインし、徐々にフェードアウトするようにしている。&lt;/p&gt;

&lt;p&gt;また、Start SizeをRandom Between Two Constantsの(1.2, 1.4)に設定することで多少揺らいでいるように見せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-gradient.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;薄い部分ではEmissionのRate over Timeを60、ColorのLocation 6.0%のAlphaを8に設定して薄く見せている。
あとはSize over Lifetimeを設定し、Start SizeはRandom Between Two Constantsの(4,6)と大きく設定してある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>godocのメモ</title>
          <link>http://sambaiz.net/article/91/</link>
          <pubDate>Wed, 05 Apr 2017 22:11:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/91/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/godoc&#34;&gt;https://godoc.org/golang.org/x/tools/cmd/godoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;コメントからドキュメントを生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc cmd/fmt Printf
func Printf(format string, a ...interface{}) (n int, err error)
    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.

$ godoc -src cmd/fmt Printf
// Printf formats according to a format specifier and writes to standard output.
// It returns the number of bytes written and any write error encountered.
func Printf(format string, a ...interface{}) (n int, err error) {
    return Fprintf(os.Stdout, format, a...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;記述対象の要素の名前から始まる、完全な文として&lt;a href=&#34;https://blog.golang.org/godoc-documenting-go-code&#34;&gt;コメントを書く&lt;/a&gt;。
インデントすれば整形した文になり、&lt;code&gt;Bug(ユーザー名):&lt;/code&gt;から始めればバグセクションにまとめられる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo bar package
package foo

import &amp;quot;fmt&amp;quot;

// Hoge returns &amp;quot;HOGE (input num)&amp;quot; string.
//   Hoge
//   Fuga
//   Piyo
// BUG(sambaiz): when passed 2, it panic.
func Hoge(num int) string {
	if num == 2 {
		panic(&amp;quot;AAAAAAAAHHHH&amp;quot;)
	}
	return fuga(&amp;quot;HOGE&amp;quot;, num)
}

// returns &amp;quot;(keyword) (num)&amp;quot; string
func fuga(keyword string, num int) string {
	return fmt.Sprintf(&amp;quot;%s %d&amp;quot;, keyword, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#hdr-Examples&#34;&gt;例&lt;/a&gt;を&lt;code&gt;ExampleXXX&lt;/code&gt;のような関数に書いておくと、これもドキュメントに追加される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package foo

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;
)

func TestHoge(t *testing.T){
	...
}

func ExampleHoge() {
	fmt.Println(Hoge(1))
	// Output: HOGE 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Webサーバーを立ち上げてブラウザで確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc -http=:6060 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じでfooパッケージのドキュメントが表示される。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:6060/pkg/github.com/sambaiz/godoctest/foo/&#34;&gt;http://localhost:6060/pkg/github.com/sambaiz/godoctest/foo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/91_godoc.png&#34; alt=&#34;godoc&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Nightmareでブラウザでの操作を自動化する</title>
          <link>http://sambaiz.net/article/90/</link>
          <pubDate>Wed, 29 Mar 2017 23:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/90/</guid>
          <description>&lt;p&gt;最近、&lt;a href=&#34;http://postwash.net/&#34;&gt;POSTWASH&lt;/a&gt;という洗濯代行サービスを使っている。
専用のカバンに詰めて集荷にきた人に渡すと、きれいに畳まれた洗濯ものが届く便利なサービスだ。
注文時にはWebのフォームから集荷、配達時間や支払い方法などを選ぶ必要があるんだけど、毎週のことなのでこれを自動化してみる。&lt;/p&gt;

&lt;p&gt;ブラウザの操作を自動化するのに&lt;a href=&#34;https://github.com/segmentio/nightmare&#34;&gt;Nightmare&lt;/a&gt;を使う。
&lt;a href=&#34;https://electron.atom.io/&#34;&gt;Electron&lt;/a&gt;を使っていて、&lt;a href=&#34;http://phantomjs.org/&#34;&gt;PahntomJS&lt;/a&gt;より2倍くらい速く、簡潔に書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install nightmare
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Nightmare()&lt;/code&gt;の引数に&lt;code&gt;show: true&lt;/code&gt;を渡すとウィンドウが開いて実行し始める。
これで確認画面までいくのであとは注文ボタンを押すだけ。
ウィンドウが閉じないように最後に&lt;code&gt;nightmare.end()&lt;/code&gt;を呼んでいない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const co = require(&#39;co&#39;);
const moment = require(&#39;moment&#39;)
const jst = +9
const Nightmare = require(&#39;nightmare&#39;);		
const nightmare = Nightmare({ 
  show: true,
  waitTimeout: 3000,
  gotoTimeout: 3000
});
const loginID = process.env.LOGIN_ID;
const loginPassword = process.env.LOGIN_PASSWORD;

moment.locale(&#39;ja&#39;);
const now = moment().utcOffset(jst)
const dayAfterTomorrow = now.add(2, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;);
const nextWeek = now.add(7, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;)
console.log(`${dayAfterTomorrow}~${nextWeek}`);

// IDとパスワードを入れてログイン
const login = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/accounts/&#39;)
  .type(&#39;#loginid&#39;, loginID)
  .insert(&#39;#loginpw&#39;, loginPassword) // .insert() is faster than .type() but does not trigger the keyboard events.
  .click(&#39;#submit&#39;)
  .wait(&#39;#yokoso&#39;)
  .evaluate(() =&amp;gt; document.querySelector(&#39;#yokoso h5&#39;).textContent);

// 注文フォームを埋めていく
const order = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/mypage/order.html&#39;)
  .wait(&#39;#item\\[4\\]&#39;)
  .check(&#39;#item\\[4\\]&#39;)
  .insert(&#39;#itemnum\\[4\\]&#39;, &#39;1&#39;)
  .select(&#39;#pickup_date_request&#39;, dayAfterTomorrow)
  .select(&#39;#pickup_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .wait(500) // #delivery_date_request が切り替わってしまうので少し待つ
  .select(&#39;#delivery_date_request&#39;, nextWeek)
  .select(&#39;#delivery_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .select(&#39;#payment&#39;, &#39;代金引換&#39;)
  .check(&#39;#agreement&#39;)
  .click(&#39;#submit&#39;)

co(function *(){
    yield login().then(
        (result) =&amp;gt; console.log(result), // ようこそ
        (err) =&amp;gt; console.log(err)
    );
    yield order();
    // yield nightmare.end();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでの文字コードの変換</title>
          <link>http://sambaiz.net/article/89/</link>
          <pubDate>Tue, 28 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/89/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/bnoordhuis/node-iconv&#34;&gt;node-iconv&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install iconv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SHIFT_JISからUTF-8への変換はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = new Buffer([
    0x8b, 0x8d, 
    0x8e, 0x4d, 
    0x26,
    0x82, 0xb2,
    0x94, 0xd1
]);

const iconv = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
console.log(`before: ${before.toString(&#39;hex&#39;)} ${before.toString()}`)
const after = iconv.convert(before);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;before: 8b8d8e4d2682b294d1 ���M&amp;amp;����
after:  e7899be79abf26e38194e9a3af 牛皿&amp;amp;ご飯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字コードによっては変換後に表せないことがある。
例えば、UTF-8からSHIFT_JISへの変換でサロゲートペア🍚を渡すと変換できず、エラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw errnoException(&#39;EILSEQ&#39;, &#39;Illegal character sequence.&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;//IGNORE&lt;/code&gt;を&lt;a href=&#34;https://www.npmjs.com/package/iconv#dealing-with-untranslatable-characters&#34;&gt;付ける&lt;/a&gt;ことで
そのような文字があった場合でもエラーにしないようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = &amp;quot;牛皿&amp;amp;🍚&amp;quot;;

const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
console.log(`before: ${new Buffer(before).toString(&#39;hex&#39;)} ${before.toString()}`)
const conv = iconv.convert(before);
const iconv2 = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
const after = iconv2.convert(conv);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変換できないものは無視される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before: e7899be79abf26f09f8d9a 牛皿&amp;amp;🍚
after:  e7899be79abf26 牛皿&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambdaでは&#34;&gt;Lambdaでは&lt;/h2&gt;

&lt;p&gt;Lambdaではインストールされているiconvコマンドを使うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new Promise((resolve, reject) =&amp;gt; {
    let filePath = &amp;quot;/tmp/shiftjis&amp;quot;;
    fs.writeFileSync(filePath, shiftjis);
    var exec = require(&#39;child_process&#39;).exec;
    var cmd = `iconv -c -f sjis -t utf-8 ${filePath}`;
    var child = exec(cmd, (err, stdout, stderr) =&amp;gt; {
      if (err) reject(err);
      else resolve(stdout);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bokukoko.info/entry/2015/08/30/AWS_Lambda%E5%86%85%E3%81%A7%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95&#34;&gt;AWS Lambda内で文字コードを変換する方法 - ボクココ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HoloLensのSharing</title>
          <link>http://sambaiz.net/article/88/</link>
          <pubDate>Sat, 25 Mar 2017 22:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/88/</guid>
          <description>

&lt;ul&gt;
&lt;li&gt;HoloToolkit-Unity v1.5.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;サーバー&#34;&gt;サーバー&lt;/h2&gt;

&lt;p&gt;SharingService.exeを
&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/tree/v1.5.5.0/External/HoloToolkit/Sharing/Server&#34;&gt;ここ&lt;/a&gt;
からとってきて実行する。開発に使っているHoloToolkitと同じリリースバージョンのものを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SharingService.exe -local
...
SharingService: Listening for session list connections on port 20602 of all network devices of the local machine.
SharingService: Local IP addresses are:
SharingService:         xxx.xxx.xxx.xxx
SharingService: Created Session &amp;quot;Default&amp;quot; with ID 0 on port 20601
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今日のTokyo Hololens Meetup Vol.2の開発者セッションで、
ちょうどSharingの話があったのだけれど、残念ながら先着順で出遅れて聞けなかった。&lt;/p&gt;

&lt;p&gt;Tweetを見る限りだとカスタマイズできず、スケーリングできないSharingService.exeは使わずに
&lt;a href=&#34;https://github.com/neuecc/MagicOnion&#34;&gt;MagicOnion&lt;/a&gt;というのを自前で作ったらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://togetter.com/li/1094037&#34;&gt;Tokyo Hololens MeetuUp Vol.2 Session5 #HoloLensJP #TMCN - Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;クライアント-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing&#34;&gt;クライアント&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Assets/HoloToolkit/Sharing/Tests&lt;/code&gt;のSceneで試してみる。&lt;/p&gt;

&lt;p&gt;以下のcapabilitiesを設定し、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SpatialPerception&lt;/li&gt;
&lt;li&gt;InternetClient&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharingのServer Addressを設定してビルド。ほかにはこんな設定がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingStage.cs#L15&#34;&gt;Client Role&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Primary: 直接セッションサーバーに接続し、セッションを管理する&lt;/li&gt;
&lt;li&gt;Secondary: Primaryクライアントに接続して、セッション管理は任せる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Server Address&lt;/li&gt;
&lt;li&gt;Port&lt;/li&gt;
&lt;li&gt;Auto Discover Server&lt;/li&gt;
&lt;li&gt;Session Name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;起動して以下のようなエラーが出たらSharingService.exeがHoloToolkitのバージョンと合っていない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List Server Handshake Failed: Invalid schema version.
Expected: 17, got 15
Please sync to latest XTools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接続と離脱のメッセージはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SharingService: User UnknownUser at address xxx.xxx.xxx.xxx joined session Default
SharingService: User UnknownUser left session Default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つ以上クライアントを立ち上げると、他のクライアントの、球からの相対的な頭の位置にCubeが映った。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/88-sharing.jpg&#34; alt=&#34;他のクライアントの頭の位置にCubeがある&#34; /&gt;&lt;/p&gt;

&lt;p&gt;が、球の場所が空間に対して同期されない・・・。&lt;/p&gt;

&lt;p&gt;原因を探るために、
TestsのSceneと同様に、SharingのPrefabにCustomMessage.csを、
適当なGameObjectにImportExportAnchorManager.csとRemoteHeadManager.csと
目印になるオブジェクトを追加し、
ImportExportAnchorManager.csにこんな感じのを追加してcurrentStateを表示してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public GameObject statusText;
private void Update()
{
    statusText.GetComponent&amp;lt;TextMesh&amp;gt;().text = currentState.ToString();
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、起動してからまだReady状態になっていなかったことが分かった。
少し待ってみるといろんな状態を経て、Ready状態になると、
目印のオブジェクトが物理的に同じところに移動し、頭の位置も正しいところに移動した。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/88-sharing2.png&#34; alt=&#34;Sharingしている状態&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;なにをやっているか見ていく。&lt;/p&gt;

&lt;p&gt;まずは拾えるevent。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/83/&#34;&gt;C#のdelegateとevent - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sharingsessiontracker-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-scripts-sharingsessiontracker-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingSessionTracker.cs&#34;&gt;SharingSessionTracker&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler&lt;SessionJoinedEventArgs&gt; SessionJoined;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ユーザーがセッションに入ったとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SessionJoinedEventArgs : EventArgs
{
    public User joiningUser;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler&lt;SessionLeftEventArgs&gt; SessionLeft;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;セッションから出たとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SessionLeftEventArgs : EventArgs
{
    public long exitingUserId;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sharingstage-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-scripts-sharingstage-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingStage.cs&#34;&gt;SharingStage&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler SharingManagerConnected;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharingManagerが接続されたとき。ArgsはEmpty。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connectedEvent(this, EventArgs.Empty);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これらのeventをsubscribeしているTestsの中のコード。&lt;/p&gt;

&lt;h2 id=&#34;custommessages-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-custommessages-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/CustomMessages.cs&#34;&gt;CustomMessages&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;データを送受信するところ。&lt;/p&gt;

&lt;h3 id=&#34;初期化-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-custommessages-cs-l57&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/CustomMessages.cs#L57&#34;&gt;初期化&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SharingManagerが接続されたら初期化がはじまる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Start()
{
    SharingStage.Instance.SharingManagerConnected += SharingManagerConnected;
}

private void SharingManagerConnected(object sender, EventArgs e)
{
    InitializeMessageHandlers();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、ServerとのConnectionを取得し、Messageを受信したときのeventをsubscribeしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SharingStage sharingStage = SharingStage.Instance;
serverConnection = sharingStage.Manager.GetServerConnection();
connectionAdapter = new NetworkConnectionAdapter();
connectionAdapter.MessageReceivedCallback += OnMessageReceived;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それから自分自身のユーザーIDも保存してある。これはMessageを送るときに使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localUserID = SharingStage.Instance.Manager.GetLocalUser().GetID();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に&lt;code&gt;MessageHandlers&lt;/code&gt;にnullを詰めて終わり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (byte index = (byte)TestMessageID.HeadTransform; index &amp;lt; (byte)TestMessageID.Max; index++)
{
    if (MessageHandlers.ContainsKey((TestMessageID)index) == false)
    {
        MessageHandlers.Add((TestMessageID)index, null);
    }

    serverConnection.AddListener(index, connectionAdapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後からこういう風にhandlerを設定している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomMessages.Instance.MessageHandlers[CustomMessages.TestMessageID.HeadTransform] = this.UpdateHeadTransform;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;受信&#34;&gt;受信&lt;/h3&gt;

&lt;p&gt;messageTypeに対応したhandlerに渡す。初期状態では全てnullなので何もしない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void OnMessageReceived(NetworkConnection connection, NetworkInMessage msg)
{
    byte messageType = msg.ReadByte();
    MessageCallback messageHandler = MessageHandlers[(TestMessageID)messageType];
    if (messageHandler != null)
    {
        messageHandler(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;送信&#34;&gt;送信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CustomMessages.Instance.SendStageTransform(transform.localPosition, transform.localRotation);
CustomMessages.Instance.SendHeadTransform(headPosition, headRotation);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにBroadcastしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void SendHeadTransform(Vector3 position, Quaternion rotation)
{
    // If we are connected to a session, broadcast our head info
    if (serverConnection != null &amp;amp;&amp;amp; serverConnection.IsConnected())
    {
        // Create an outgoing network message to contain all the info we want to send
        NetworkOutMessage msg = CreateMessage((byte)TestMessageID.HeadTransform);

        AppendTransform(msg, position, rotation);

        // Send the message as a broadcast, which will cause the server to forward it to all other users in the session.
        serverConnection.Broadcast(
            msg,
            MessagePriority.Immediate,
            MessageReliability.UnreliableSequenced,
            MessageChannel.Avatar);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;importexportanchormanager-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-importexportanchormanager-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/ImportExportAnchorManager.cs&#34;&gt;ImportExportAnchorManager&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オブジェクトのpositionを物理的に固定する&lt;a href=&#34;https://docs.unity3d.com/ScriptReference/VR.WSA.WorldAnchor.html&#34;&gt;WorldAnchor&lt;/a&gt;を共有する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;currentState&lt;/code&gt;は最初&lt;code&gt;AnchorStore_Initializing&lt;/code&gt;で、
&lt;code&gt;anchorStore&lt;/code&gt;が取得できたら&lt;code&gt;AnchorStore_Initialized&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ImportExportState currentState = ImportExportState.Start;

// インスタンスがロードされたときに呼ばれる。コンストラクターの代わり
protected override void Awake()
{
    base.Awake();
    Debug.Log(&amp;quot;Import Export Manager starting&amp;quot;);
    // We need to get our local anchor store started up.
    currentState = ImportExportState.AnchorStore_Initializing;
    WorldAnchorStore.GetAsync(AnchorStoreReady);
}

private void AnchorStoreReady(WorldAnchorStore store)
{
    anchorStore = store;
    currentState = ImportExportState.AnchorStore_Initialized;
}

private void Start()
{
    SharingStage.Instance.SharingManagerConnected += SharingManagerConnected;
    SharingSessionTracker.Instance.SessionJoined += Instance_SessionJoined;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SharingManagerが接続されたら、RoomManagerのインスタンスを取得して、
Anchorのダウンロードとアップロードしたときのeventをsubscribeしている。&lt;/p&gt;

&lt;p&gt;Uploaded時は&lt;code&gt;currentState&lt;/code&gt;を&lt;code&gt;Ready&lt;/code&gt;にし、
Downloaded時は&lt;code&gt;rawAnchorData&lt;/code&gt;に保存し、&lt;code&gt;currentState&lt;/code&gt;を&lt;code&gt;DataReady&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void SharingManagerConnected(object sender, EventArgs e)
{
    // Setup the room manager callbacks.
    roomManager = SharingStage.Instance.Manager.GetRoomManager();
    roomManagerCallbacks = new RoomManagerAdapter();

    roomManagerCallbacks.AnchorsDownloadedEvent += RoomManagerCallbacks_AnchorsDownloaded;
    roomManagerCallbacks.AnchorUploadedEvent += RoomManagerCallbacks_AnchorUploaded;
    roomManager.AddListener(roomManagerCallbacks);
}

private void RoomManagerCallbacks_AnchorUploaded(bool successful, XString failureReason)
{
    if (successful)
    {
        currentState = ImportExportState.Ready;
    }
    else
    {
        Debug.Log(&amp;quot;Upload failed &amp;quot; + failureReason);
        currentState = ImportExportState.Failed;
    }
}

private byte[] rawAnchorData = null;

private void RoomManagerCallbacks_AnchorsDownloaded(bool successful, AnchorDownloadRequest request, XString failureReason)
{
    // If we downloaded anchor data successfully we should import the data.
    if (successful)
    {
        int datasize = request.GetDataSize();
        Debug.Log(datasize + &amp;quot; bytes &amp;quot;);
        rawAnchorData = new byte[datasize];

        request.GetData(rawAnchorData, datasize);
        currentState = ImportExportState.DataReady;
    }
    else
    {
        // If we failed, we can ask for the data again.
        Debug.Log(&amp;quot;Anchor DL failed &amp;quot; + failureReason);
        MakeAnchorDataRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SessionJoin時には、&lt;code&gt;sharingServiceReady&lt;/code&gt;をtrueにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;InitRoomApi()&lt;/code&gt;では&lt;code&gt;currentRoom&lt;/code&gt;にJoin(あるいは新しく作る)し、Roomを代入している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;currentState&lt;/code&gt;は新しくRoomを作った場合&lt;code&gt;InitialAnchorRequired&lt;/code&gt;で、すでにあるRoomに入った場合&lt;code&gt;RoomApiInitialized&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private bool sharingServiceReady = false;
private Room currentRoom;

private void Instance_SessionJoined(object sender, SharingSessionTracker.SessionJoinedEventArgs e)
{
    SharingSessionTracker.Instance.SessionJoined -= Instance_SessionJoined;

    // ほかの処理が落ち着くまで5秒待って実行する
    Invoke(&amp;quot;MarkSharingServiceReady&amp;quot;, 5);
}

private void MarkSharingServiceReady()
{
    sharingServiceReady = true;

#if UNITY_EDITOR || UNITY_STANDALONE
    InitRoomApi();
#endif
}

private void InitRoomApi()
{
    if (roomManager.GetRoomCount() == 0)
    {
        if (LocalUserHasLowestUserId())
        {
            Debug.Log(&amp;quot;Creating room &amp;quot;);            
            currentRoom = roomManager.CreateRoom(new XString(&amp;quot;DefaultRoom&amp;quot;), roomID, false);
            currentState = ImportExportState.InitialAnchorRequired;
        }
    }
    else
    {
        Debug.Log(&amp;quot;Joining room &amp;quot;);
        currentRoom = roomManager.GetRoom(0);
        roomManager.JoinRoom(currentRoom);
        currentState = ImportExportState.RoomApiInitialized;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update。ここで&lt;code&gt;currentState&lt;/code&gt;を見ている。ここまでの&lt;code&gt;currentState&lt;/code&gt;をまとめると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AnchorStore_Initializing: 初期状態&lt;/li&gt;
&lt;li&gt;AnchorStore_Initialized: AnchorStore取得完了&lt;/li&gt;
&lt;li&gt;InitialAnchorRequired: 新しくRoomを作った(のでWorldAnchorを生成する)&lt;/li&gt;
&lt;li&gt;RoomApiInitialized: すでにあるRoomに入った&lt;/li&gt;
&lt;li&gt;Ready: Upload完了&lt;/li&gt;
&lt;li&gt;DataReady: Download完了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Update()
{
    switch (currentState)
    {
        case ImportExportState.AnchorStore_Initialized:
            if (sharingServiceReady)
            {
                InitRoomApi();
            }
            break;
        case ImportExportState.RoomApiInitialized:
            StartAnchorProcess();
            break;
        case ImportExportState.DataReady:
            // DataReady is set when the anchor download completes.
            currentState = ImportExportState.Importing;
            WorldAnchorTransferBatch.ImportAsync(rawAnchorData, ImportComplete);
            break;
        case ImportExportState.InitialAnchorRequired:
            currentState = ImportExportState.CreatingInitialAnchor;
            CreateAnchorLocally();
            break;
        case ImportExportState.ReadyToExportInitialAnchor:
            // We&#39;ve created an anchor locally and it is ready to export.
            currentState = ImportExportState.UploadingInitialAnchor;
            Export();
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Roomを新しく作ったならWorldAnchorを作成する必要がある。
&lt;a href=&#34;https://docs.unity3d.com/ScriptReference/VR.WSA.WorldAnchor-isLocated.html&#34;&gt;isLocated&lt;/a&gt;がtrueになったら
&lt;code&gt;OnTrackingChanged_InitialAnchor&lt;/code&gt;にし、AnchorをUploadする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void CreateAnchorLocally()
{
    WorldAnchor anchor = GetComponent&amp;lt;WorldAnchor&amp;gt;();
    if (anchor == null)
    {
        anchor = gameObject.AddComponent&amp;lt;WorldAnchor&amp;gt;();
    }

    if (anchor.isLocated)
    {
        currentState = ImportExportState.ReadyToExportInitialAnchor;
    }
    else
    {
        anchor.OnTrackingChanged += Anchor_OnTrackingChanged_InitialAnchor;
    }
}

private void Anchor_OnTrackingChanged_InitialAnchor(WorldAnchor self, bool located)
{
    if (located)
    {
        Debug.Log(&amp;quot;Found anchor, ready to export&amp;quot;);
        currentState = ImportExportState.ReadyToExportInitialAnchor;
    }
    else
    {
        Debug.Log(&amp;quot;Failed to locate local anchor (super bad!)&amp;quot;);
        currentState = ImportExportState.Failed;
    }

    self.OnTrackingChanged -= Anchor_OnTrackingChanged_InitialAnchor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;anchorStore&lt;/code&gt;に保存して、SerializeしてUploadする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Export()
{
    WorldAnchor anchor = GetComponent&amp;lt;WorldAnchor&amp;gt;();

    string guidString = Guid.NewGuid().ToString();
    exportingAnchorName = guidString;

    // Save the anchor to our local anchor store.
    if (anchorStore.Save(exportingAnchorName, anchor))
    {
        sharedAnchorInterface = new WorldAnchorTransferBatch();
        sharedAnchorInterface.AddWorldAnchor(guidString, anchor);
        WorldAnchorTransferBatch.ExportAsync(sharedAnchorInterface, WriteBuffer, ExportComplete);
    }
    else
    {
        Debug.Log(&amp;quot;This anchor didn&#39;t work, trying again&amp;quot;);
        currentState = ImportExportState.InitialAnchorRequired;
    }
}

public void ExportComplete(SerializationCompletionReason status)
{
    if (status == SerializationCompletionReason.Succeeded &amp;amp;&amp;amp; exportingAnchorBytes.Count &amp;gt; minTrustworthySerializedAnchorDataSize)
    {
        Debug.Log(&amp;quot;Uploading anchor: &amp;quot; + exportingAnchorName);
        roomManager.UploadAnchor(
            currentRoom,
            new XString(exportingAnchorName),
            exportingAnchorBytes.ToArray(),
            exportingAnchorBytes.Count);
    }
    else
    {
        Debug.Log(&amp;quot;This anchor didn&#39;t work, trying again&amp;quot;);
        currentState = ImportExportState.InitialAnchorRequired;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もしすでにあるRoomにJoinしている(&lt;code&gt;RoomApiInitialized&lt;/code&gt;)なら、Anchorをダウンロードし始め、&lt;code&gt;DataRequested&lt;/code&gt;になる。
ダウンロードしたら&lt;code&gt;DataReady&lt;/code&gt;になって、AnchorデータをImportする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void StartAnchorProcess()
{
    // First, are there any anchors in this room?
    int anchorCount = currentRoom.GetAnchorCount();

    // If there are anchors, we should attach to the first one.
    if (anchorCount &amp;gt; 0)
    {
        // Extract the name of the anchor.
        XString storedAnchorString = currentRoom.GetAnchorName(0);
        string storedAnchorName = storedAnchorString.GetString();

        // Attempt to attach to the anchor in our local anchor store.
        if (AttachToCachedAnchor(storedAnchorName) == false)
        {
            MakeAnchorDataRequest();
        }
    }
}

private void MakeAnchorDataRequest()
{
    if (roomManager.DownloadAnchor(currentRoom, currentRoom.GetAnchorName(0)))
    {
        currentState = ImportExportState.DataRequested;
    }
    else
    {
        Debug.Log(&amp;quot;Couldn&#39;t make the download request.&amp;quot;);
        currentState = ImportExportState.Failed;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Import完了したら&lt;code&gt;anchorStore&lt;/code&gt;に保存し、&lt;code&gt;Ready&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void ImportComplete(SerializationCompletionReason status, WorldAnchorTransferBatch wat)
{
    if (status == SerializationCompletionReason.Succeeded &amp;amp;&amp;amp; wat.GetAllIds().Length &amp;gt; 0)
    {
        Debug.Log(&amp;quot;Import complete&amp;quot;);

        string first = wat.GetAllIds()[0];
        Debug.Log(&amp;quot;Anchor name: &amp;quot; + first);

        WorldAnchor anchor = wat.LockObject(first, gameObject);
        anchorStore.Save(first, anchor);
        currentState = ImportExportState.Ready;
    }
    else
    {
        Debug.Log(&amp;quot;Import fail&amp;quot;);
        currentState = ImportExportState.DataReady;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remoteheadmanager-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-remoteheadmanager-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/RemoteHeadManager.cs&#34;&gt;RemoteHeadManager&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;他のユーザーの頭の位置にオブジェクトを表示させる。&lt;/p&gt;

&lt;p&gt;受信時のhandlerを設定し、eventをsubscribeする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Start()
{
    CustomMessages.Instance.MessageHandlers[CustomMessages.TestMessageID.HeadTransform] = this.UpdateHeadTransform;

    SharingSessionTracker.Instance.SessionJoined += Instance_SessionJoined;
    SharingSessionTracker.Instance.SessionLeft += Instance_SessionLeft;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;joinしたのが自分自身じゃないかチェック。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Instance_SessionJoined(object sender, SharingSessionTracker.SessionJoinedEventArgs e)
{
    if (e.joiningUser.GetID() != SharingStage.Instance.Manager.GetLocalUser().GetID())
    {
        GetRemoteHeadInfo(e.joiningUser.GetID());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remoteHeads&lt;/code&gt;になければ、HeadObjectを作成し、追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public RemoteHeadInfo GetRemoteHeadInfo(long userID)
{
    RemoteHeadInfo headInfo;

    // Get the head info if its already in the list, otherwise add it
    if (!this.remoteHeads.TryGetValue(userID, out headInfo))
    {
        headInfo = new RemoteHeadInfo();
        headInfo.UserID = userID;
        headInfo.HeadObject = CreateRemoteHead();

        this.remoteHeads.Add(userID, headInfo);
    }

    return headInfo;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sessionから離れたときはオブジェクトを削除し、remoteHeadsから取り除く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Instance_SessionLeft(object sender, SharingSessionTracker.SessionLeftEventArgs e)
{
    if (e.exitingUserId != SharingStage.Instance.Manager.GetLocalUser().GetID())
    {
        RemoveRemoteHead(this.remoteHeads[e.exitingUserId].HeadObject);
        this.remoteHeads.Remove(e.exitingUserId);
    }
}

void RemoveRemoteHead(GameObject remoteHeadObject)
{
    DestroyImmediate(remoteHeadObject);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;受信時のhandlerではMessageからpositionとquarternionを取得し、オブジェクトの位置を動かしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void UpdateHeadTransform(NetworkInMessage msg)
{
    // Parse the message
    long userID = msg.ReadInt64();

    Vector3 headPos = CustomMessages.Instance.ReadVector3(msg);

    Quaternion headRot = CustomMessages.Instance.ReadQuaternion(msg);

    RemoteHeadInfo headInfo = GetRemoteHeadInfo(userID);
    headInfo.HeadObject.transform.localPosition = headPos;
    headInfo.HeadObject.transform.localRotation = headRot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分の頭の位置はUpdate()で送信している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Update()
{
    // Grab the current head transform and broadcast it to all the other users in the session
    Transform headTransform = Camera.main.transform;

    // Transform the head position and rotation from world space into local space
    Vector3 headPosition = this.transform.InverseTransformPoint(headTransform.position);
    Quaternion headRotation = Quaternion.Inverse(this.transform.rotation) * headTransform.rotation;

    CustomMessages.Instance.SendHeadTransform(headPosition, headRotation);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ライセンス&#34;&gt;ライセンス&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;MIT License

Copyright (c) 2016 Microsoft Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &amp;quot;Software&amp;quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unixのパイプをmkfifo()で作ってdup2()で標準出力にコピーして書き込む</title>
          <link>http://sambaiz.net/article/87/</link>
          <pubDate>Fri, 24 Mar 2017 22:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/87/</guid>
          <description>

&lt;h2 id=&#34;パイプとは&#34;&gt;パイプとは&lt;/h2&gt;

&lt;p&gt;Unixでプロセス間通信するためのもの。シェルで使う&lt;code&gt;|&lt;/code&gt;は無名パイプ。
&lt;code&gt;mkfifo()&lt;/code&gt;システムコールで名前付きパイプを作成でき、これを読み書きすることで任意のプロセス間でやりとりできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkfifo hoge
$ ls -lh
$ prw-r--r-- ... 0B ... hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常のファイルと同様に読み書きすることができ、読み書きどちらかを行おうとすると待つことになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo hoge &amp;amp; # 読まれるまで待つ
$ cat hoge
aaaaa
[1]+  Done                    echo &amp;quot;aaaaa&amp;quot; &amp;gt; hoge

$ cat hoge &amp;amp; # 書かれるまで待つ
$ echo &amp;quot;bbbbb&amp;quot; &amp;gt; hoge
bbbbb
[1]+  Done                    cat hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルディスクリプタをコピーするシステムコール&lt;code&gt;dup2()&lt;/code&gt;でopenしたパイプを標準出力(1)にコピーしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(){
  int fd = open(&amp;quot;./hoge&amp;quot;, O_WRONLY);
  if(fd &amp;lt; 0){
    printf(&amp;quot;fail to open\n&amp;quot;);
    return 1;
  }

  printf(&amp;quot;OPEN %d \n&amp;quot;, fd);

  if(dup2(fd, 1) &amp;lt; 0){
    printf(&amp;quot;fail to dup2\n&amp;quot;);
    return 2;
  }

  printf(&amp;quot;WRITE\n&amp;quot;); // これがどこに書き込まれるか

  close(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後のprintfの内容は標準出力ではなく、パイプに書き込まれていることがわかる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a.out &amp;amp;
$ echo &amp;quot;read `cat hoge` from pipe&amp;quot;
OPEN 3 
read WRITE from pipe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%91%E3%82%A4%E3%83%97_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)#.E3.83.97.E3.83.AD.E3.82.B0.E3.83.A9.E3.83.A0.E3.81.AB.E3.82.88.E3.82.8B.E3.83.91.E3.82.A4.E3.83.97.E3.81.AE.E4.BD.9C.E6.88.90&#34;&gt;パイプ (コンピュータ) - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/richmikan@github/items/bb660a58690ac01ec295&#34;&gt;mkfifoコマンドって使ってますか？ - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/stc1988/items/9354204d3c2ff210512b&#34;&gt;リダイレクトの挙動 - Qiita&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CuratorでElasticsearchの古いindexを削除する</title>
          <link>http://sambaiz.net/article/86/</link>
          <pubDate>Wed, 22 Mar 2017 00:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/86/</guid>
          <description>

&lt;h2 id=&#34;curatorとは-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-index-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/index.html&#34;&gt;Curatorとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;indexやsnapshotを管理するのに使えるツール。&lt;/p&gt;

&lt;h2 id=&#34;インストール-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-installation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/installation.html&#34;&gt;インストール&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;インストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/yum.repos.d/curator.repo
[curator-4]
name=CentOS/RHEL 7 repository for Elasticsearch Curator 4.x packages
baseurl=http://packages.elastic.co/curator/4/centos/7
gpgcheck=1
gpgkey=http://packages.elastic.co/GPG-KEY-elasticsearch
enabled=1

$ yum install -y elasticsearch-curator
$ curator --version
curator, version 4.2.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-configfile-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/configfile.html&#34;&gt;config&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;configファイルを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client:
  hosts:
    - 127.0.0.1
  port: 9200

logging:
  loglevel: INFO
  logfile:
  logformat: default
  blacklist: [&#39;elasticsearch&#39;, &#39;urllib3&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;action-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-actions-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/actions.html&#34;&gt;action&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;今回はindexを削除するので&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/ex_delete_indices.html&#34;&gt;delete_indices&lt;/a&gt;。
対象は&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/filters.html&#34;&gt;filter&lt;/a&gt;で指定する。
logstash formatだとhogehoge-2017.01.01のようなindex名になるので&lt;code&gt;%Y.%m.%d&lt;/code&gt;。&lt;code&gt;okder than 3 days&lt;/code&gt;のものを削除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actions:
  1:
    action: delete_indices
    description: &amp;gt;-
      3日前より古いhogehoge-* indexを消す
    filters:
    - filtertype: pattern
      kind: prefix
      value: hogehoge-
    - filtertype: age
      source: name
      direction: older
      timestring: &#39;%Y.%m.%d&#39;
      unit: days
      unit_count: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-command-line-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/command-line.html&#34;&gt;実行&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;configとactionファイルを指定して実行する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curator --config curator_config.yml curator_action.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎日00:05に実行するようにしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l
5 0 * * * curator --config curator_config.yml curator_action.yml
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでRxをはじめる</title>
          <link>http://sambaiz.net/article/85/</link>
          <pubDate>Sat, 18 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/85/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;https://github.com/ReactiveX/rxjs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rx-reactivex-とは-http-reactivex-io-intro-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Rx(ReactiveX)とは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;非同期処理をうまく扱えるようにするライブラリ。いろんな言語で実装されている。
非同期処理の結果はObservableなStreamに流される。
ObservableはIteratableのように扱うことができる。&lt;/p&gt;

&lt;p&gt;Rxは&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;Observer pattern&lt;/a&gt;
を拡張したもの。
Observer patternというのは、Subjectが、Observeしている全てのObserverに対して通知を送るデザインパターン。
C#などのeventのそれ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/83/&#34;&gt;C#のdelegateとevent - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;inputのkeyupイベントのObservableを作成し、それを&lt;code&gt;subscribe()&lt;/code&gt;して出力している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input&amp;quot; /&amp;gt;

&amp;lt;script&amp;gt;

const inputForm = document.querySelector(&#39;#input&#39;);

const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err)
);

&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力するとこんなのが出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;b&amp;quot;, code: &amp;quot;KeyB&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;c&amp;quot;, code: &amp;quot;KeyC&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;observable-http-reactivex-io-rxjs-class-es6-observable-js-observable-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html&#34;&gt;Observable&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;create-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-create&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-create&#34;&gt;create&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;でObservableに値をemitし、&lt;code&gt;complete()&lt;/code&gt;で終了させる。
&lt;code&gt;error()&lt;/code&gt;でエラーをemitするとそれ以後の値はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.create(function (observer) {
    observer.next(&amp;quot;AAAAA&amp;quot;);
    observer.next(&amp;quot;BBBBB&amp;quot;);
    observer.next(&amp;quot;CCCCC&amp;quot;);
    observer.complete();
}).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;AAAA
BBBB
CCCC
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;from-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-from&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from&#34;&gt;from&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;配列などのIteratableをObservableに変換する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.from([1,2,3]).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
2
3
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fromevent-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-fromevent&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent&#34;&gt;fromEvent&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上で使ったやつ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromEvent(document.querySelector(&#39;#input&#39;), &#39;keyup&#39;).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;frompromise-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-frompromise&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromPromise&#34;&gt;fromPromise&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;PromiseもObservableに変換できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromPromise(Promise.resolve(&amp;quot;ok&amp;quot;)).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ok
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interval-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-interval&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-interval&#34;&gt;interval&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一定時間ごとにemitし続ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.interval(1000).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/100/&#34;&gt;RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest) - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;operator-http-reactivex-io-rxjs-manual-overview-html-operators&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/manual/overview.html#operators&#34;&gt;Operator&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observableのメソッド。新しいObservableを作って返す。&lt;/p&gt;

&lt;p&gt;上で試したkeyupのObservableにいろいろやってみる。&lt;/p&gt;

&lt;h3 id=&#34;pluck-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-pluck&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-pluck&#34;&gt;pluck&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;nestされたプロパティを指定する。この例だと&lt;code&gt;.target.value&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;h
ho
hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-filter&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-filter&#34;&gt;filter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;フィルタリングする。この例だと長さが2より大きいものだけがemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 );
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-map&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map&#34;&gt;map&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;map。この例だと&lt;code&gt;value: ${text}&lt;/code&gt;のフォーマットでemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;value: hog
value: hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-reduce&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce&#34;&gt;reduce&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;reduce。emitされるのはcompleteされたときなので、&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-takeUntil&#34;&gt;takeUntil()&lt;/a&gt;で
渡したObservableが何かemitしたときにcompleteさせるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .takeUntil(Rx.Observable.interval(5000))
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`)
  .reduce((acc, curr) =&amp;gt; `${acc} ${curr}`, &amp;quot;&amp;quot;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err),
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; value: aaa value: aaaa value: aaaaa value: aaaaaa value: aaaaaaa value: aaaaaaaa value: aaaaaaaaa value: aaaaaaaaaa value: aaaaaaaaaaa
 completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subject-http-reactivex-io-documentation-subject-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/documentation/subject.html&#34;&gt;Subject&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observerでもあり、Observableでもあるブリッジのようなもの。&lt;/p&gt;

&lt;p&gt;これまでのObservableはSubscribeされるまでemitしない&amp;rdquo;Cold&amp;rdquo;なものだったが、
SubjectはそんなObservableをSubscribeし、それをトリガーにemitするので、
&amp;ldquo;Cold&amp;rdquo;なObservableを常にemitし得る&amp;rdquo;Hot&amp;rdquo;なものに変えることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ColdなObservable
const cold = Rx.Observable.from([1,2,3]);

// Coldだと、いつから、何回読んでも同じ値が得られる

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data), 
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;publish-subject&#34;&gt;(Publish)Subject&lt;/h3&gt;

&lt;p&gt;Subscribeした時点からemitされたアイテムをemitする。それまでにemitされたアイテムはしない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.Subject(); 

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;) // 1: AAA

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;BBB&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
2: BBB
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asyncsubject&#34;&gt;AsyncSubject&lt;/h3&gt;

&lt;p&gt;complete時に最後にemitされた値だけをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.AsyncSubject();

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;); 
subject.next(&amp;quot;BBB&amp;quot;);

subject.complete();

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: BBB
1: completed
2: BBB
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;behaviorsubject&#34;&gt;BehaviorSubject&lt;/h3&gt;

&lt;p&gt;Subscribeしたとき、最近のアイテムをemitする。あとはSubjectと同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.BehaviorSubject(&amp;quot;ZZZ&amp;quot;)

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;CCC&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: ZZZ
1: AAA
1: BBB
2: BBB
1: CCC
2: CCC
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;replaysubject&#34;&gt;ReplaySubject&lt;/h3&gt;

&lt;p&gt;いつSubscribeしてもbufferにある全てのアイテムをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.ReplaySubject(2) // buffer size = 2

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);
subject.next(&amp;quot;CCC&amp;quot;);
subject.next(&amp;quot;DDD&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buffer size = 2 なので2がSubscribeしたときにはAAAとBBBはもうない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
1: CCC
1: DDD
2: CCC
2: DDD
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/wilfrem/tech-rxjs&#34;&gt;歌舞伎座tech発表資料 RxJSの中を追う&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>FluentdとKPL(Kinesis Producer Library)でログをまとめてスループットを稼ぐ</title>
          <link>http://sambaiz.net/article/84/</link>
          <pubDate>Wed, 15 Mar 2017 23:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/84/</guid>
          <description>

&lt;h2 id=&#34;kpl-kinesis-producer-library-とは&#34;&gt;KPL(Kinesis Producer Library)とは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/streams/latest/dev/developing-producers-with-kpl.html&#34;&gt;Developing Amazon Kinesis Streams Producers Using the Amazon Kinesis Producer Library - Amazon Kinesis Streams&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kinesisに送るとき、自動リトライしてくれたり、レコードをまとめてスループットを向上してくれたりするアプリケーション。Protobufを使っている。
普通に送るとどんなに小さくてもシャード*1000レコード/秒しか最大でPUTできないのを、KPLを使ってまとめることで増やすことができる。&lt;/p&gt;

&lt;h2 id=&#34;fluentdで送る&#34;&gt;fluentdで送る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;で&lt;code&gt;kinesis_producer&lt;/code&gt;を指定するとKPLを使って送信する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;kinesis_producer&amp;gt;&lt;/code&gt;の中にKPLの設定を書くことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;kinesis_producer&amp;gt;
    record_max_buffered_time 10
&amp;lt;/kinesis_producer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L239&#34;&gt;record_max_bufferd_time&lt;/a&gt;
はバッファされたレコードが送られるまでの最大時間(ms)。デフォルトは100ms。この時間が経つか、他のリミットに当たったらレコードは送られる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L30&#34;&gt;AggregationMaxCount&lt;/a&gt;: 一つのレコードにまとめる最大レコード数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L44&#34;&gt;AggregationMaxSize&lt;/a&gt;: まとめたレコードの最大バイト数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L54&#34;&gt;CollectionMaxCount&lt;/a&gt;: PutRecordsで送る最大アイテム数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L67&#34;&gt;CollectionMaxSize&lt;/a&gt;: PutRecordsで送るデータ量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudWatchに送る&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L158&#34;&gt;metrics_level&lt;/a&gt;はデフォルトでdetailedになっていて、
コンソールのメトリクスからstream名で検索すると
&lt;code&gt;KinesisProducerLibrary&lt;/code&gt;に&lt;code&gt;UserRecordsPerKinesisRecord&lt;/code&gt;や、&lt;code&gt;UserRecordsDataPut&lt;/code&gt;、&lt;code&gt;BufferingTime&lt;/code&gt;、&lt;code&gt;RequestTime&lt;/code&gt;などいろいろ表示される。&lt;/p&gt;

&lt;p&gt;とりあえず試しにこんな設定で送ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;match hoge.log&amp;gt;
  @type kinesis_producer
  region ap-northeast-1
  stream_name teststream
  include_time_key true

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambdaで読む&#34;&gt;Lambdaで読む&lt;/h2&gt;

&lt;p&gt;まとめられたレコードを&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation&#34;&gt;kinesis-aggregation&lt;/a&gt;で分解して読む。
今回は&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation/tree/master/node&#34;&gt;Node.js&lt;/a&gt;でやる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save aws-kinesis-agg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意する必要があるのは&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation/issues/16&#34;&gt;ドキュメントの情報が古く&lt;/a&gt;て、
関数の引数が足りないこと。第二引数のcomputeChecksumsが抜けているので気付かないと一つずつずれていくことになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const agg = require(&#39;aws-kinesis-agg&#39;);

exports.handler = (event, context, callback) =&amp;gt; {
    Promise.all(
        event.Records.map(
            (record) =&amp;gt; deaggregate(record)
        )
    ).then(
        (records) =&amp;gt; {
            // LambdaのNode.jsはまだ4.3なのでSpread operatorが使えない・・・
            // const message = `${[].concat(...records).length} came in`; 
            let sumCount = 0;
            records.forEach((r) =&amp;gt; sumCount += r.length);
            const message = `${records.length} aggregated records and ${sumCount} records come in`; 
            console.log(message);
            callback(null, message);
        },
        (err) =&amp;gt; callback(err)
    );
};

function deaggregate(record){
    return new Promise((resolve, reject) =&amp;gt; {
        agg.deaggregateSync(record.kinesis, true, (err, userRecords) =&amp;gt; {
            if (err) {
                reject(err);
            } else {
                resolve(userRecords);
            }
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;175レコードが10レコードにまとめられた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 aggregated records and 175 records come in
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/high-throughput-messaging-system-with-kinesis-kpl-fluentd-lambda/&#34;&gt;Kinesis Producer Library(KPL)とfluentdとLambdaを連携してKinesisのスループットを上げる ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>C#のdelegateとevent</title>
          <link>http://sambaiz.net/article/83/</link>
          <pubDate>Sun, 12 Mar 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/83/</guid>
          <description>

&lt;h2 id=&#34;delegate-https-msdn-microsoft-com-ja-jp-library-900fyy8e-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/900fyy8e.aspx&#34;&gt;delegate&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;カプセル化するためのdelegate(移譲)メソッドに使う型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Converter{

	private static double defaultConvert(double num){
		return num;
	}

	public delegate double Convert(double num);
	public Convert convert = defaultConvert;

	public double run(double num){
		return convert (num);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名メソッドやラムダ式を渡すこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var conv = new Converter ();

print (conv.run (2)); // 2

// 匿名メソッドの例
conv.convert = delegate(double input)
{
    return input + 1;
};
print (conv.run (2)); // 2 + 1 = 3

// ラムダ式の例
conv.convert = s =&amp;gt; s * s;
print (conv.run(2)); // 2 * 2 = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;event-https-msdn-microsoft-com-ja-jp-library-8627sbea-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/8627sbea.aspx&#34;&gt;event&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;宣言元でしか呼べないマルチキャストデリゲート。&lt;code&gt;+=&lt;/code&gt;でsubscribeして&lt;code&gt;-=&lt;/code&gt;で解除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void RunEventHandler(double num);
public event RunEventHandler RunEvent;

public double run(double num){
    if (RunEvent != null) {
        RunEvent (num);
    }
    return convert (num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subscribeしたものは全て呼ばれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void runHook(double num){
    print(&amp;quot;b: &amp;quot; +  num);
}

var conv = new Converter ();
conv.RunEvent += s =&amp;gt; print (&amp;quot;a: &amp;quot; +  s); // Subscribe a
conv.run (2); // a: 2

conv.RunEvent += runHook; // Subscribe b
conv.run (3); // a: 3, b: 3

conv.RunEvent -= runHook; // Unsubscribe b
conv.run (4); // a: 4

// error
// conv.RunEvent (); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.NET Frameworkのクラスライブラリの全てのイベントでは
&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/db0etb8x.aspx&#34;&gt;EventHandler&lt;TEventArgs&gt;&lt;/a&gt;を使っていて、
ユーザー定義のコードでもこのパターンを使うのが&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/w369ty8x.aspx&#34;&gt;推奨されている&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void EventHandler&amp;lt;TEventArgs&amp;gt;(
	object sender,
	TEventArgs e
)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのMaterial</title>
          <link>http://sambaiz.net/article/82/</link>
          <pubDate>Sat, 11 Mar 2017 20:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/82/</guid>
          <description>

&lt;h2 id=&#34;materialとshaderとtexture-https-docs-unity3d-com-550-documentation-manual-shaders-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/Shaders.html&#34;&gt;MaterialとShaderとTexture&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Materialは表面がどのようにレダリングされるかを定義するもの。
Shaderを指定し、Textureなどのパラメーターを設定する。&lt;/p&gt;

&lt;p&gt;Shaderは光と、Materialの設定から、ピクセルの色を計算するスクリプト。
大体&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/shader-StandardShader.html&#34;&gt;Standard Shader&lt;/a&gt;
で事足りるらしい。&lt;/p&gt;

&lt;p&gt;Textureはビットマップイメージ。色(Albedo)だけではなく、反射率や粗さなど、いろんな要素に使える。&lt;/p&gt;

&lt;h2 id=&#34;standard-shader&#34;&gt;Standard Shader&lt;/h2&gt;

&lt;h3 id=&#34;rendering-mode-https-docs-unity3d-com-manual-standardshadermaterialparameterrenderingmode-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/Manual/StandardShaderMaterialParameterRenderingMode.html&#34;&gt;Rendering Mode&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Albedoは(255, 255, 255, 255)で、テクスチャにはDefault Particleを指定している。
透明度はテクスチャのアルファチャンネルとAlbedoのアルファ値に基づく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-defaultparticle.png&#34; alt=&#34;Default Particle&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Opaque: デフォルト。すべて不透明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-opaque.png&#34; alt=&#34;Opaque&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CutOut: 閾値を境に、完全に透明か、不透明になる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alpha Cutoffを0.1にした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-cutout.png&#34; alt=&#34;CutOut&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transparent: 透明度が適用される。現実世界の透明なマテリアルのように、反射のハイライトは完全に表示される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-transparent.png&#34; alt=&#34;Transparent&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fade: ハイライトにも透明度を適用する。フェードイン/アウトしたいときに使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-fade.png&#34; alt=&#34;Fade&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;metallic&#34;&gt;Metallic&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/StandardShaderMaterialCharts.html&#34;&gt;マテリアルチャート&lt;/a&gt;をもとにAlbedoとMetallicとSmoothnessを設定する。&lt;/p&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Albedo: (255, 255, 255, 255)&lt;/li&gt;
&lt;li&gt;Metallic: 1&lt;/li&gt;
&lt;li&gt;Smoothness: 0.68&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を設定している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-metal.png&#34; alt=&#34;Metallic&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのUI</title>
          <link>http://sambaiz.net/article/81/</link>
          <pubDate>Wed, 08 Mar 2017 16:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/81/</guid>
          <description>

&lt;h2 id=&#34;canvas-https-docs-unity3d-com-ja-540-scriptreference-canvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/ScriptReference/Canvas.html&#34;&gt;Canvas&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;UI要素を配置するための領域。&lt;/p&gt;

&lt;h3 id=&#34;rendermode-https-docs-unity3d-com-jp-540-manual-uicanvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UICanvas.html&#34;&gt;renderMode&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Overlay: スクリーンに対してオーバーレイするように表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Camera: Cameraから指定した距離(planeDistance)離れた前方に表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;World Space 他のオブジェクトと同じように表示&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;canvas-scaler-https-docs-unity3d-com-jp-540-manual-script-canvasscaler-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/script-CanvasScaler.html&#34;&gt;Canvas Scaler&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UI Scale Mode (World Space以外)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constant Pixel Size: 画面サイズに関わらず同じピクセル数にする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scale With Screen Size: 画面サイズでスケールさせる&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Constant Physical Size 解像度や画面サイズによらず物理的に同じサイズにする&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dynami Pixels Per Unit (World Spaceのみ): Textなどの動的に生成されたビットマップの解像度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1と3でそれぞれこんな感じになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu1.png&#34; alt=&#34;Dynamic Pixels Per Unitが1のとき&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu3.png&#34; alt=&#34;Dynamic Pixels Per Unitが3のとき&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;autolayout-https-docs-unity3d-com-ja-540-manual-comp-uiautolayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/comp-UIAutoLayout.html&#34;&gt;AutoLayout&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-VerticalLayoutGroup.html&#34;&gt;Vertical Layout Group&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-GridLayoutGroup.html&#34;&gt;Grid Layout Group&lt;/a&gt;
など。これらのComponentを追加すると子要素のTransform(の一部)が自動で設定される。&lt;/p&gt;

&lt;h3 id=&#34;content-size-fitter-https-docs-unity3d-com-ja-540-manual-script-contentsizefitter-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-ContentSizeFitter.html&#34;&gt;Content Size Fitter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Layout Component要素に合うように自動で調整される。&lt;/p&gt;

&lt;h2 id=&#34;レイアウトを作る-https-docs-unity3d-com-jp-540-manual-uibasiclayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UIBasicLayout.html&#34;&gt;レイアウトを作る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;RectTool(ツールバーボタンの一番右の四角いやつ)を選択して、Pivot, Localにするとよい。
Canvasにいろいろ置いていって、Anchorを選んでRect Transformを設定していく。
あとはPrefabにしてInstantiateするなりして表示する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine.UI;

public GameObject dialogWindow;
var obj = Instantiate(obj, new Vector3(0, 0, 200), Quaternion.identity);

var hogeText = obj.transform.Find(&amp;quot;panel/hoge&amp;quot;).gameObject.GetComponent&amp;lt;Text&amp;gt;();
hogeText.text = &amp;quot;fuga&amp;quot;;

var fugaButton = obj.transform.Find(&amp;quot;panel/fuga&amp;quot;).gameObject.GetComponent&amp;lt;Button&amp;gt;();
fugaButton.onClick.AddListener (() =&amp;gt; {
    Debug.Log (&amp;quot;onClick&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのTransform</title>
          <link>http://sambaiz.net/article/80/</link>
          <pubDate>Tue, 07 Mar 2017 02:11:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/80/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&#34;&gt;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトの位置、スケール、回転を保持する。親子関係を持つ。&lt;/p&gt;

&lt;h2 id=&#34;position&#34;&gt;Position&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-position.html&#34;&gt;position&lt;/a&gt;がワールド空間の、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localPosition.html&#34;&gt;localPosition&lt;/a&gt;
が親から見た相対的なローカル空間の位置。localPositionの1unitはscaleに依存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.position = new Vector3(0, 0, 0);
transform.localPosition = new Vector3(0, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に移動するには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Translate.html&#34;&gt;Translate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;になっていて、&lt;code&gt;Space.World&lt;/code&gt;を指定するとワールド座標を基準にする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Time-deltaTime.html&#34;&gt;Time.deltaTime&lt;/a&gt;は最後のフレームを完了するのにかかった秒数。
なのでフレームレートにかかわらず同じ速度で移動させることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Translate(0, Time.deltaTime, 0, Space.World);
transform.Translate(Vector3.up * Time.deltaTime, Space.World); // 軸に沿って移動
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform); // 最後の引数のローカル座標を基準にする
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scale&#34;&gt;Scale&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localScale.html&#34;&gt;localScale&lt;/a&gt;
はローカル空間のスケール。ワールド空間のScaleはない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.localScale = new Vector3(0.1f, 1f, 1f);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rotation&#34;&gt;Rotation&lt;/h2&gt;

&lt;p&gt;ワールド空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-rotation.html&#34;&gt;rotation&lt;/a&gt;と
ローカル空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localRotation.html&#34;&gt;localRoation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Unityは&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.html&#34;&gt;Quarternion&lt;/a&gt;(四元数)で回転を持っている。
実際はQuarternionそのものを自分で計算することはなく、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.LookRotation.html&#34;&gt;Quaternion.LookRotation()&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.Euler.html&#34;&gt;Quaternion.Euler()&lt;/a&gt;などを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vector3 relativePos;
transform.rotation = Quaternion.LookRotation(relativePos); // そのPointを向くように回転
transform.localRotation = Quaternion.Euler(0, 30, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transformを向くように回転する場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.LookAt.html&#34;&gt;LookAt()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Transform target;
transform.LookAt(target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に回転させるには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Rotate.html&#34;&gt;Rotate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;で、&lt;code&gt;Space.World&lt;/code&gt;を指定すると回転の軸がワールドの軸になる。指定するのは角度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Rotate(0, Time.deltaTime, 0, Space.World);
transform.Rotate(Vector3.up, Time.deltaTime, Space.World);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ワールド座標のあるPointを中心として回転させる場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.RotateAround.html&#34;&gt;RotateAround()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.RotateAround(Vector3.zero, Vector3.up, 20 * Time.deltaTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parent-https-docs-unity3d-com-jp-current-scriptreference-transform-parent-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform-parent.html&#34;&gt;parent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;親を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fuga = GameObject.CreatePrimitive (PrimitiveType.Cube);
fuga.transform.parent = hoge.transform;
fuga.transform.parent = null; // detach
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-https-docs-unity3d-com-jp-540-scriptreference-transform-find-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Find.html&#34;&gt;Find&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;子の名前で検索する。
FindChildもあるけどドキュメントに書いてないので使わない方がよさそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var child = transform.Find(&amp;quot;hoge/fuga&amp;quot;)
if(child != null){
    child.gameObject
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでDateを任意のフォーマットの文字列にする</title>
          <link>http://sambaiz.net/article/79/</link>
          <pubDate>Mon, 06 Mar 2017 20:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/79/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://momentjs.com/&#34;&gt;Moment.js&lt;/a&gt;を使う。
相対時間(&lt;code&gt;5 years ago&lt;/code&gt;)を出したり、日付の計算(&lt;code&gt;add(3, &#39;days&#39;)&lt;/code&gt;)もできる便利なライブラリ。
ブラウザでも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install moment
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const moment = require(&#39;moment&#39;)
const jst = +9
let now = moment().utcOffset(jst).format(&amp;quot;YYYY-MM-DD HH:mm:ss.SSSZ&amp;quot;);
console.log(now);
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityと.NETとMono</title>
          <link>http://sambaiz.net/article/78/</link>
          <pubDate>Sun, 05 Mar 2017 18:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/78/</guid>
          <description>

&lt;p&gt;.NETとかよくわからなかったのでまとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;net-framework&#34;&gt;.NET Framework&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoftが開発したアプリケーション開発、実行環境。&lt;/p&gt;

&lt;p&gt;各言語のコンパイラによって言語、環境によらない共通の中間言語(CIL, Common Intermediate Language)バイナリ(exeやdll)に変換し、
実行時に共通言語基盤(CLI, Common Language Infrastructure)の仮想実行システム(VES)が環境依存の機械語を動的に生成(JIT, Just in time)する。
CLIの仕様はECMAで標準化されていて、Microsoftが実装したCLIが共通言語ランタイム(CLR)。Windowsでしか動かない。&lt;/p&gt;

&lt;h2 id=&#34;net-core&#34;&gt;.NET Core&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/magazine/mt694084.aspx&#34;&gt;.NET Core - .NET Core による .NET のクロスプラットフォームへの移行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/dotnet&#34;&gt;Microsoft/dotnet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームに対応した.NET。CoreCLRはWindowsだけではなくMacやLinuxでも動く。
.NET Frameworkと共通のAPIもあるが、GUIまわりでどちらかにしかないAPIが存在する。&lt;/p&gt;

&lt;h2 id=&#34;mono-http-www-mono-project-com&#34;&gt;&lt;a href=&#34;http://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームな.NET Framework互換ソフトウェア。C#のコンパイラとCLIが実装されている。
Unityはこれを使っているが、バージョンが古くて使えないライブラリがある。&lt;/p&gt;

&lt;h2 id=&#34;net-coreでhello-world&#34;&gt;.NET CoreでHello World&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/net/core#macos&#34;&gt;インストール手順&lt;/a&gt;に沿って
&lt;code&gt;dotnet&lt;/code&gt;コマンドを使えるようにする。&lt;/p&gt;

&lt;p&gt;Hello Worldまで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dotnet console -o hwapp
$ cd hwapp
$ ls
Program.cs	hwapp.csproj

$ dotnet restore
$ ls
Program.cs	hwapp.csproj	obj

$ ls obj
hwapp.csproj.nuget.g.props	project.assets.json
hwapp.csproj.nuget.g.targets

# dotnet build
$ dotnet run
Hello World!

$ dotnet bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に.NET CoreにしかないAPIも使っていないのでmono(.NET Framework)ででも実行できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Program.cs 
using System;

namespace hwapp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&amp;quot;Hello World!&amp;quot;);
        }
    }
}

$ mono bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/AimingStudy/unitynet&#34;&gt;Unityと.NET&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Elasticsearchで期間ごとの集計値を出す</title>
          <link>http://sambaiz.net/article/77/</link>
          <pubDate>Sun, 05 Mar 2017 01:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/77/</guid>
          <description>

&lt;p&gt;Bucket(SQLでいうGROUP BY)にまとめて(Bucket Aggreagtion)、集計(Metric Aggregation)する。&lt;/p&gt;

&lt;p&gt;使うデータは&lt;a href=&#34;http://sambaiz.net/article/76/&#34;&gt;作ったツール&lt;/a&gt;で生成したこんなの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;score&amp;quot;:82}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bucket-aggregations-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket.html&#34;&gt;Bucket Aggregations&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;date-range-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-daterange-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-daterange-aggregation.html&#34;&gt;Date Range Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;date_range&lt;/code&gt;で期間のBucketを作る。この例だと今から10分前の00秒~今の分の00秒まで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {
        &amp;quot;range_10minutes&amp;quot;: {
            &amp;quot;date_range&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;format&amp;quot;: &amp;quot;HH-mm-ssZ&amp;quot;,
                &amp;quot;ranges&amp;quot;: [                               
                    { &amp;quot;to&amp;quot;: &amp;quot;now/m&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;now-10m/m&amp;quot; }
                ]
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;range_10minutes&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;15-17+0000-15-27+0000&amp;quot;,
        &amp;quot;from&amp;quot;: 1488640620000,
        &amp;quot;from_as_string&amp;quot;: &amp;quot;15-17+0000&amp;quot;,
        &amp;quot;to&amp;quot;: 1488641220000,
        &amp;quot;to_as_string&amp;quot;: &amp;quot;15-27+0000&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 600
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;date-histogram-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-datehistogram-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-datehistogram-aggregation.html&#34;&gt;Date Histogram Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;date_histogram&lt;/code&gt;で日付の間隔でBucketを作る。この例だと1分ごとにBucketが作られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {   
        &amp;quot;histogram_1minute&amp;quot;: {                  
            &amp;quot;date_histogram&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;interval&amp;quot;: &amp;quot;1m&amp;quot;
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;histogram_1minute&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      ...
      {
        &amp;quot;key_as_string&amp;quot;: &amp;quot;1488640560&amp;quot;,
        &amp;quot;key&amp;quot;: 1488640560000,
        &amp;quot;doc_count&amp;quot;: 60
      },
      {
        &amp;quot;key_as_string&amp;quot;: &amp;quot;1488640620&amp;quot;,
        &amp;quot;key&amp;quot;: 1488640620000,
        &amp;quot;doc_count&amp;quot;: 31
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;terms-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-terms-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-terms-aggregation.html&#34;&gt;Terms Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;terms&lt;/code&gt;で値ごとにBucketを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {   
        &amp;quot;os_names&amp;quot;:{                  
            &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;os_name&amp;quot; }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;os_names&amp;quot;: {
    &amp;quot;doc_count_error_upper_bound&amp;quot;: 0,
    &amp;quot;sum_other_doc_count&amp;quot;: 0,
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;windows&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 458
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;android&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 456
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;mac&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 455
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;linux&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 447
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;ios&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 404
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-aggregations-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-metrics-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-metrics.html&#34;&gt;Metrics Aggregations&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;avg-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-metrics-avg-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-metrics-avg-aggregation.html&#34;&gt;Avg Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;avg&lt;/code&gt;で平均を出す。&lt;code&gt;max&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;sum&lt;/code&gt;も同様。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d &#39;
{
    &amp;quot;aggs&amp;quot;: {      
        &amp;quot;avg_score&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot; : &amp;quot;score&amp;quot; } }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;avg_score&amp;quot;: {
    &amp;quot;value&amp;quot;: 50.34639639639639
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;集計する&#34;&gt;集計する&lt;/h2&gt;

&lt;p&gt;aggsを組み合わせて集計する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{             
    &amp;quot;aggs&amp;quot;: {
        &amp;quot;range&amp;quot;: {
            &amp;quot;date_range&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;format&amp;quot;: &amp;quot;HH-mm-ssZ&amp;quot;,
                &amp;quot;ranges&amp;quot;: [                               
                    { &amp;quot;to&amp;quot;: &amp;quot;now/m&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;now-10m/m&amp;quot; }
                ]
            },
            &amp;quot;aggs&amp;quot;: {
                &amp;quot;histogram&amp;quot;: {                  
                    &amp;quot;date_histogram&amp;quot;: {
                        &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                        &amp;quot;interval&amp;quot;: &amp;quot;1m&amp;quot;
                    },
                    &amp;quot;aggs&amp;quot;: {
                        &amp;quot;os_names&amp;quot;:{
                            &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot; : &amp;quot;os_name&amp;quot; },
                            &amp;quot;aggs&amp;quot;: {
                                &amp;quot;avg_score&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;score&amp;quot; }}
                            }
                        }
                    }
                }
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;range&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;15-55-00+0000-16-05-00+0000&amp;quot;,
        &amp;quot;from&amp;quot;: 1488642900000,
        &amp;quot;from_as_string&amp;quot;: &amp;quot;15-55-00+0000&amp;quot;,
        &amp;quot;to&amp;quot;: 1488643500000,
        &amp;quot;to_as_string&amp;quot;: &amp;quot;16-05-00+0000&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 25,
        &amp;quot;histogram&amp;quot;: {
          &amp;quot;buckets&amp;quot;: [
            {
              &amp;quot;key_as_string&amp;quot;: &amp;quot;1488643440&amp;quot;,
              &amp;quot;key&amp;quot;: 1488643440000,
              &amp;quot;doc_count&amp;quot;: 25,
              &amp;quot;os_names&amp;quot;: {
                &amp;quot;doc_count_error_upper_bound&amp;quot;: 0,
                &amp;quot;sum_other_doc_count&amp;quot;: 0,
                &amp;quot;buckets&amp;quot;: [
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;linux&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 9,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 41.44444444444444
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;ios&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 5,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 63.6
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;mac&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 5,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 53.6
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;android&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 4,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 41.25
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;windows&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 2,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 67
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>一定間隔でjsonデータを作って送り続けるCLIツールを作った</title>
          <link>http://sambaiz.net/article/76/</link>
          <pubDate>Sat, 04 Mar 2017 23:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/76/</guid>
          <description>&lt;p&gt;Elasticsearchにリアルタイムなテストデータを投入するために、一定間隔でjsonを作って送り続けるCLIツールを作った。Go製。
&lt;a href=&#34;https://github.com/urfave/cli&#34;&gt;urfave/cli&lt;/a&gt;を使った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/sendjson&#34;&gt;sambaiz/sendjson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こんなindexにデータを入れてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT &#39;http://localhost:9200/hoge&#39; -d&#39;
{
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;test_type&amp;quot;: { 
      &amp;quot;_all&amp;quot;:       { &amp;quot;enabled&amp;quot;: false  }, 
      &amp;quot;properties&amp;quot;: { 
        &amp;quot;os_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;score&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;byte&amp;quot; },
        &amp;quot;@timestamp&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;epoch_second&amp;quot; }
      }
    }
  }
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じでキーに対してtypeと入る値を定義するとそれっぽいデータができて送られていく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install github.com/sambaiz/sendjson
$ sendjson --interval 0.5s --duration 10s --url http://localhost:9200/hoge/test_type &#39;
{
    &amp;quot;os_name&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;or&amp;quot;: [&amp;quot;windows&amp;quot;, &amp;quot;mac&amp;quot;, &amp;quot;linux&amp;quot;, &amp;quot;ios&amp;quot;, &amp;quot;android&amp;quot;]},
    &amp;quot;score&amp;quot;:  {&amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, &amp;quot;min&amp;quot;: 0, &amp;quot;max&amp;quot;: 100},
    &amp;quot;@timestamp&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;time&amp;quot;, &amp;quot;time_format&amp;quot;: &amp;quot;unix_epoch&amp;quot;}
}&#39;

{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;score&amp;quot;:82}
{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:9}
{&amp;quot;@timestamp&amp;quot;:1488635131,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:73}
{&amp;quot;@timestamp&amp;quot;:1488635131,&amp;quot;os_name&amp;quot;:&amp;quot;ios&amp;quot;,&amp;quot;score&amp;quot;:50}
{&amp;quot;@timestamp&amp;quot;:1488635132,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:69}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと入っていることを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:9200/hoge/_search | jq
{
  &amp;quot;took&amp;quot;: 2,
  &amp;quot;timed_out&amp;quot;: false,
  &amp;quot;_shards&amp;quot;: {
    &amp;quot;total&amp;quot;: 5,
    &amp;quot;successful&amp;quot;: 5,
    &amp;quot;failed&amp;quot;: 0
  },
  &amp;quot;hits&amp;quot;: {
    &amp;quot;total&amp;quot;: 29,
    &amp;quot;max_score&amp;quot;: 1,
    &amp;quot;hits&amp;quot;: [
      {
        &amp;quot;_index&amp;quot;: &amp;quot;hoge&amp;quot;,
        &amp;quot;_type&amp;quot;: &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot;: &amp;quot;AVqZpCjjFTc9Q_rmmMn7&amp;quot;,
        &amp;quot;_score&amp;quot;: 1,
        &amp;quot;_source&amp;quot;: {
          &amp;quot;@timestamp&amp;quot;: 1488636356,
          &amp;quot;os_name&amp;quot;: &amp;quot;android&amp;quot;,
          &amp;quot;score&amp;quot;: 38
        }
      },
      {
        &amp;quot;_index&amp;quot;: &amp;quot;hoge&amp;quot;,
        &amp;quot;_type&amp;quot;: &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot;: &amp;quot;AVqZpE-kFTc9Q_rmmMoN&amp;quot;,
        &amp;quot;_score&amp;quot;: 1,
        &amp;quot;_source&amp;quot;: {
          &amp;quot;@timestamp&amp;quot;: 1488636366,
          &amp;quot;os_name&amp;quot;: &amp;quot;android&amp;quot;,
          &amp;quot;score&amp;quot;: 87
        }
      },
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>H2OでHTTPS-&gt;HTTPのリバースプロキシを立てる</title>
          <link>http://sambaiz.net/article/75/</link>
          <pubDate>Thu, 02 Mar 2017 20:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/75/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://qiita.com/cubicdaiya/items/235777dc401ec419b14e&#34;&gt;良くチューニングされたNginxと同じくらい速い&lt;/a&gt;と
評判のHTTP/2サーバー&lt;a href=&#34;https://h2o.examp1e.net/&#34;&gt;H2O&lt;/a&gt;でリバースプロキシを立ててみる。
HTTP/2だけではなく1.xにも対応しているので古い環境などでも大丈夫。&lt;/p&gt;

&lt;p&gt;設定は
&lt;a href=&#34;https://github.com/h2o/h2o/wiki/Reverse-Proxy&#34;&gt;Reverse Proxy&lt;/a&gt;と
&lt;a href=&#34;https://github.com/h2o/h2o/wiki/redirect-HTTP-to-HTTPS&#34;&gt;HTTP to HTTPS&lt;/a&gt;の
サンプルをもとにして書いた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hosts:
  &amp;quot;*&amp;quot;:
    listen:
      port: 443
      ssl:
        certificate-file: /etc/h2o/oreore.crt
        key-file:         /etc/h2o/server.key
    paths:
      &amp;quot;/&amp;quot;:
        proxy.reverse.url: http://127.0.0.1:3000/

access-log: /dev/stdout
error-log: /dev/stderr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずオレオレ証明書で試してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa 2048 &amp;gt; server.key # private key
$ openssl req -new -key server.key &amp;gt; server.csr # certificate signing request 
$ openssl x509 -days 365000 -req -signkey server.key &amp;lt; server.csr &amp;gt; oreore.crt # oreore certificate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerで動かす。&lt;a href=&#34;https://github.com/lkwg82/h2o.docker&#34;&gt;lkwg82/h2o.docker&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi h2o.conf
$ docker run -v $(pwd):/etc/h2o --net=host --name h2o --restart=always -itd lkwg82/h2o-http2-server
$ curl --insecure https://127.0.0.1 # -&amp;gt; :3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromeでアクセスして、Developer ToolsのNetworkで右クリックでProtocolにチェックを入れてh2と表示されていたら
HTTP/2で通信している。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goroutineの数をworkerで抑制する</title>
          <link>http://sambaiz.net/article/74/</link>
          <pubDate>Mon, 27 Feb 2017 23:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/74/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/61/&#34;&gt;Goのnet/httpとKeep-Alive - sambaiz.net&lt;/a&gt;でやったように、
あるエンドポイントに連続してGoroutineでリクエストを投げると、リクエスト数を増やしたときにタイムアウトが頻発するようになった。&lt;/p&gt;

&lt;p&gt;まず、2000リクエストを投げてみた結果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 2000, ok: 2000, ng: 0, time(ms) 138
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一応全部捌けてはいるけど、おおよそ同時にリクエストを送っているのにタイムアウト(100ms)時間を超えてしまっている。これをさらに3000に増やしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 13, ng: 2987, time(ms) 372
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほぼ全滅してしまった・・・。時間もおかしいのでGoroutineでの処理に遅延が発生しているようだ。
そこで、都度Goroutineを生成してリクエストを投げるのではなく、
一定数のWorkerに処理させることで、同時に作られるGoroutineの数を抑制する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Req struct {
	Okch chan int
	Ngch chan int
}

func startWorker(ctx context.Context, num int) (requestch chan *Req) {

	requestch = make(chan *Req)

	for i := 0; i &amp;lt; num; i++ {
		go func() {
			for {
				select {
				case req := &amp;lt;-requestch:
					request(req.Okch, req.Ngch)
				case &amp;lt;-ctx.Done():
					return
				}
			}
		}()
	}

	return
}

func main(){
    ...
    ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	requestch := startWorker(ctx, 1000)

    requestch &amp;lt;- req
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、すべてのリクエストをタイムアウトせずに送れるようになった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 3000, ng: 0, time(ms) 157
[RESULT] request: 5000, ok: 5000, ng: 0, time(ms) 239
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上のコードではWorkerを作るにあたって単純にWorkerの数分goroutineを生成して共通のチャネルに入ってきたものを読んで処理させているが、
以下の記事のようにDispatcherを用意してWorkerPool(chan chan Job)からWorkerのjobChannel(chan Job)を取り出して送る方法も紹介されていたので
これとも比較してみた。今回は入力するチャネルだけ分けて終了方法はStartで渡したcontextに一任しているので上の方法とさほど変わらず、むしろ冗長に見えるが、
実際はWorkerそれぞれがquitするチャネルなどを持っていて、独立して終了させることができるため、Workerの数を動的にコントロールしやすいのが特長だと思う。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/&#34;&gt;Handling 1 Million Requests per Minute with Go  · marcio.io&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Dispatcher struct{
	Requestch chan *Req
	workerPool chan chan *Req
	workerNum int
}

func NewDispatcher(workerNum int) *Dispatcher{
	return &amp;amp;Dispatcher{
		Requestch: make(chan *Req),
		workerPool: make(chan chan *Req, workerNum),
		workerNum: workerNum,
	}
}


func (d *Dispatcher) Start(ctx context.Context) error{
	poolLength := len(d.workerPool)
	if poolLength != 0{
		return errors.New(&amp;quot;already started&amp;quot;)
	}
	for i := 0; i &amp;lt; d.workerNum; i++{
		startWorker(ctx, 1, d.workerPool)
	}

	go d.dispatch(ctx)

	return nil
}

func (d *Dispatcher) dispatch(ctx context.Context){
	for{
		select{
		case req := &amp;lt;- d.Requestch:
            // workerPoolからchanを取り出しreqを入れる
			worker := &amp;lt;- d.workerPool
			worker &amp;lt;- req
		case &amp;lt;-ctx.Done():
			return 
		}
	}
}

func startWorker(ctx context.Context, num int, workerPool chan chan *Req) {

	requestch := make(chan *Req)

	for i := 0; i &amp;lt; num; i++ {
		go func() {
			for {
                // workerPoolにchanを入れる(終わったらまだ戻る)
				workerPool &amp;lt;- requestch
				select {
				case req := &amp;lt;-requestch:
					request(req.Okch, req.Ngch)
				case &amp;lt;-ctx.Done():
					return
				}
			}
		}()
	}

	return
}

func main(){
    ...
    dispatcher := NewDispatcher(1000)
	if err := dispatcher.Start(ctx); err != nil{
		panic(err)
	}

    dispatcher.requestch &amp;lt;- req
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほとんど変わらず。WorkerPoolからチャネルを取り出す分、わずかに遅いかな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 3000, ng: 0, time(ms) 169
[RESULT] request: 5000, ok: 5000, ng: 0, time(ms) 246
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdでKinesis Streamsに送ってLambdaで読んでS3に保存する</title>
          <link>http://sambaiz.net/article/73/</link>
          <pubDate>Sun, 26 Feb 2017 18:56:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/73/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;でKinesis Streamsに送り、Lambdaで読んでS3に保存する。
要するにFirehoseのようなことをやりたいのだけれどTokyoリージョンにまだ来ないので自分でやる。&lt;/p&gt;

&lt;h2 id=&#34;fluentdで送る&#34;&gt;fluentdで送る&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ td-agent-gem install fluent-plugin-kinesis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;try_flush_interval&lt;/code&gt;と&lt;code&gt;queued_chunk_flush_interval&lt;/code&gt;はドキュメントには載っていないが、
以下のページによるとそれぞれqueueに次のchunkがないときとあるときのflushする間隔。
いずれもデフォルトは1だが、これを減らすことでもっと頻繁に吐き出されるようになるらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sonots/fluentd-scr/blob/master/02_out_forward_buffered.md&#34;&gt;Fluentd の out_forward と BufferedOutput&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;あとシャードに振り分けるための&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis#partition_key&#34;&gt;partition_key&lt;/a&gt;
を指定できる。デフォルトはランダム。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type tail
  path /var/log/td-agent/hoge.log
  pos_file /etc/td-agent/log.pos
  tag hoge.log
  format json

  time_key timestamp
  # 2017-01-01T01:01:01+0900
  time_format %Y-%m-%dT%H:%M:%S%z
&amp;lt;/source&amp;gt;

&amp;lt;match hoge.log&amp;gt;
  @type kinesis_streams
  region ap-northeast-1
  stream_name teststream
  include_time_key true

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつか送ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in `seq 1 1000`
do
  echo &#39;{&amp;quot;hoge&amp;quot;: &amp;quot;fuga&amp;quot;, &amp;quot;timestamp&amp;quot;: &amp;quot;2017-01-01T01:01:01+0900&amp;quot;}&#39; &amp;gt;&amp;gt; /var/log/td-agent/hoge.log
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kinesisのシャードが足りないと詰まってしまうので注意。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/84/&#34;&gt;FluentdとKPL(Kinesis Producer Library)でログをまとめてスループットを稼ぐ - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lambdaで読む&#34;&gt;Lambdaで読む&lt;/h2&gt;

&lt;p&gt;Lambdaのトリガーの設定でKinesisを選ぶと、バッチサイズや開始位置を設定できる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/73-lambda-kinesis.png&#34; alt=&#34;トリガーの設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const zlib = require(&#39;zlib&#39;);
const aws = require(&#39;aws-sdk&#39;);
const s3 = new aws.S3({ apiVersion: &#39;2006-03-01&#39; });
const BUCKET_NAME = process.env.BUCKET_NAME; // 環境変数で設定する

exports.handler = (event, context, callback) =&amp;gt; {

    const data = event.Records.map((record) =&amp;gt; new Buffer(record.kinesis.data, &#39;base64&#39;).toString()).join(&amp;quot;\n&amp;quot;);
    const key = new Date().toISOString();
    
    putS3(key, data, true).then(
        (data) =&amp;gt; callback(null, `Successfully processed ${event.Records.length} records.`),
        (err) =&amp;gt; callback(err, null)
    );
};

function putS3(key, data, gzip){    
    return new Promise((resolve, reject) =&amp;gt; {
        
        const params = {
            Bucket: BUCKET_NAME,
            Key: key
        };

        if(gzip){
            params.Body = zlib.gzipSync(data);
            params.ContentEncoding = &amp;quot;gzip&amp;quot;;
        }else{
            params.Body = data;
        }
        
        s3.putObject(params, (err, data) =&amp;gt; {
            if (err) reject(err);
            else resolve(data);
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーを有効にするとイベントが発火してS3に保存されるようになった。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AWSのAssumeRole</title>
          <link>http://sambaiz.net/article/72/</link>
          <pubDate>Sat, 25 Feb 2017 20:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/72/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_credentials_temp.html&#34;&gt;AWS Security Token Service&lt;/a&gt;による、
RoleArn(&lt;code&gt;arn:aws:iam::&amp;lt;account id&amp;gt;:role/&amp;lt;role name&amp;gt;&lt;/code&gt;)から一時的なCredentialを取得する仕組み。
前もって発行したAPIキーとは違い、有効期限が存在するため続けて呼ぶ場合は失効する前に再発行する必要がある。&lt;/p&gt;

&lt;p&gt;ではRoleArnを知っていたら誰でも取得できるかというと、もちろんそうではなく、
ロールの信頼関係、&lt;code&gt;&amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;&lt;/code&gt;のPrincipalのところで信頼する対象を設定する。
例えば、&lt;code&gt;Service&lt;/code&gt;で&lt;code&gt;ec2.amazonaws.com&lt;/code&gt;を指定してEC2がAssumeRoleするのを許可したり、
&lt;code&gt;AWS&lt;/code&gt;で(他の)アカウントやユーザーを指定してそのAPIキーでこのRoleのCredentialを取得できるようにしたりといった感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
  &amp;quot;Statement&amp;quot;: [
    {
      &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
      &amp;quot;Principal&amp;quot;: {
        &amp;quot;Service&amp;quot;: &amp;quot;ec2.amazonaws.com&amp;quot;
      },
      &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EC2にロールを設定すると、実はそのロールについてAssumeRoleして自動でCredentialを取得している。
EC2にロールを設定するにはロールとは別に
&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html&#34;&gt;インスタンスプロファイルを作成&lt;/a&gt;
する必要があるが、コンソールでEC2のサービスロールを作ると同名のインスタンスプロファイルが自動で作成される。
さらに、AssumeRoleのServiceとして&lt;code&gt;ec2.amazonaws.com&lt;/code&gt;が追加されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://169.254.169.254/latest/meta-data/iam/info
{
  &amp;quot;Code&amp;quot; : &amp;quot;Success&amp;quot;,
  &amp;quot;LastUpdated&amp;quot; : &amp;quot;2017-02-25T10:56:33Z&amp;quot;,
  &amp;quot;InstanceProfileArn&amp;quot; : &amp;quot;arn:aws:iam::*****:instance-profile/assume_role_test&amp;quot;,
  &amp;quot;InstanceProfileId&amp;quot; : &amp;quot;*****&amp;quot;
}

$ curl http://169.254.169.254/latest/meta-data/iam/security-credentials/assume_role_test
{
  &amp;quot;Code&amp;quot; : &amp;quot;Success&amp;quot;,
  &amp;quot;LastUpdated&amp;quot; : &amp;quot;2017-02-25T10:56:23Z&amp;quot;,
  &amp;quot;Type&amp;quot; : &amp;quot;AWS-HMAC&amp;quot;,
  &amp;quot;AccessKeyId&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;SecretAccessKey&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;Token&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;Expiration&amp;quot; : &amp;quot;2017-02-25T17:26:07Z&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/iam-role-and-assumerole/&#34;&gt;IAMロール徹底理解 〜 AssumeRoleの正体 ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_credentials_temp_use-resources.html&#34;&gt;一時的なセキュリティ認証情報を使用して AWS リソースへのアクセスをリクエストする - AWS Identity and Access Management&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ElasticsearchのCircuit Breaker</title>
          <link>http://sambaiz.net/article/71/</link>
          <pubDate>Fri, 24 Feb 2017 21:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/71/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/52/&#34;&gt;ElasticsearchをDockerで動かしてGrafanaで可視化する - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ESに送られるデータの量が増えてくるとGrafanaのDashboardにグラフが表示されなくなってしまった。
表示されたエラーはこういうの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;root_cause&amp;quot;: [
    {
        &amp;quot;type&amp;quot;: &amp;quot;circuit_breaking_exception&amp;quot;,
        &amp;quot;reason&amp;quot;: &amp;quot;[request] Data too large, data for [] would be larger than limit of [8998512230/8.3gb]&amp;quot;,
        &amp;quot;bytes_wanted&amp;quot;: 10464007168,
        &amp;quot;bytes_limit&amp;quot;: 8998512230
    }
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは1リクエストの集計などで使うメモリ量がしきい値をこえて
&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/circuit-breaker.html&#34;&gt;Circuit Breaker&lt;/a&gt;が発動したということ。
メモリを食いつぶしてOutOfMemoryになる前に焼き切れるようになっている。&lt;/p&gt;

&lt;p&gt;情報は&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/cluster-nodes-stats.html&#34;&gt;stats&lt;/a&gt;のapiでも取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/_nodes/stats | jq .nodes[].breakers.request
{
  &amp;quot;limit_size_in_bytes&amp;quot;: 8998512230,
  &amp;quot;limit_size&amp;quot;: &amp;quot;8.3gb&amp;quot;,
  &amp;quot;estimated_size_in_bytes&amp;quot;: 10348347504,
  &amp;quot;estimated_size&amp;quot;: &amp;quot;9.6gb&amp;quot;,
  &amp;quot;overhead&amp;quot;: 1,
  &amp;quot;tripped&amp;quot;: 470
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回ひっかかったのは&lt;code&gt;indices.breaker.request.limit&lt;/code&gt;。デフォルトではJVMのヒープメモリの60%になっているが、
これを80%にまで緩和する。併せてparent-levelのbreakerも上げる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT localhost:9200/_cluster/settings -d &#39;{
    &amp;quot;persistent&amp;quot; : {
        &amp;quot;indices.breaker.request.limit&amp;quot;: &amp;quot;80%&amp;quot;,
        &amp;quot;indices.breaker.total.limit&amp;quot;: &amp;quot;80%&amp;quot;
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT localhost:9200/_cluster/settings -d &#39;{
    &amp;quot;persistent&amp;quot; : {
        &amp;quot;indices.breaker.request.limit&amp;quot;: &amp;quot;80%&amp;quot;,
        &amp;quot;indices.breaker.total.limit&amp;quot;: &amp;quot;80%&amp;quot;
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必要なメモリ量を上回ったのでひとまずは返せるようになった。
これは一時しのぎで、定常的に大量にメモリが必要なリクエストを処理する必要があるなら、そもそもメモリが足りないので増やさなければならない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/_nodes/stats | jq .nodes[].breakers.request
{
  &amp;quot;limit_size_in_bytes&amp;quot;: 11998016307,
  &amp;quot;limit_size&amp;quot;: &amp;quot;11.1gb&amp;quot;,
  &amp;quot;estimated_size_in_bytes&amp;quot;: 10473078896,
  &amp;quot;estimated_size&amp;quot;: &amp;quot;9.7gb&amp;quot;,
  &amp;quot;overhead&amp;quot;: 1,
  &amp;quot;tripped&amp;quot;: 470
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>crontabのメモ</title>
          <link>http://sambaiz.net/article/70/</link>
          <pubDate>Fri, 24 Feb 2017 21:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/70/</guid>
          <description>

&lt;p&gt;各ユーザーごとのcron設定。&lt;code&gt;crontab -e&lt;/code&gt;でも編集できるけど、間違えて&lt;code&gt;-r&lt;/code&gt;にすると全部消えてしまうのでこういう風に一旦取り出してから編集すると安全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l &amp;gt; ~/crontab
$ echo &amp;quot;*/1 * * * * /hoge/fuga.sh&amp;quot; &amp;gt;&amp;gt; ~/crontab
$ crontab &amp;lt; ~/crontab
$ crontab -l
*/1 * * * * /hoge/fuga.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://vividcode.hatenablog.com/entry/man-cron-and-crontab&#34;&gt;cron 設定ファイル (crontab ファイル) の置き場所と書式について - ひだまりソケットは壊れない&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Cookieのメモ</title>
          <link>http://sambaiz.net/article/69/</link>
          <pubDate>Wed, 22 Feb 2017 20:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/69/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レスポンスに&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーが含まれていればブラウザはcookieに保存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエスト時には&lt;code&gt;Cookie&lt;/code&gt;ヘッダーにcookieを入れて送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CookieにExpire(ある期間まで有効)またはMax-Age(特定の期間の間有効)を設定するとPermanent cookieとなる。
いずれも設定しなかった場合Session cookieとなり、ブラウザを閉じると削除されることになっているが、
ブラウザのセッション復元機能が有効になっていれば永続化される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secureを付けるとHTTPSでのみ送られる。
また、HttpOnlyはjsから&lt;code&gt;document.cookie&lt;/code&gt;などでアクセスすることができなくなる。
サイトにXSSの脆弱性があるとき、cookieが盗まれてしまうのを防ぐことができるので問題なければ設定するべき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Domainを指定するとそのドメインとサブドメインへのリクエストのときに送られる。しないとそのドメインだけ。Pathも指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Domain=example.com; Path=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエストが飛び、&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーを受け取ればCookieに書かれるので、アクセスしたサイトのドメイン以外のCookieが書かれることがある。
このようなCookieを3rd party cookieといって、広告のトラッキングによく使われるが、
Safariなどのデフォルト設定では書き込めなくなっている。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ELBのスケーリングとsurge queue</title>
          <link>http://sambaiz.net/article/68/</link>
          <pubDate>Tue, 21 Feb 2017 19:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/68/</guid>
          <description>

&lt;p&gt;バックエンドだけではなくELB自体もスケーリングし、内部node数はdigで調べることができる。
このnode数は自分ではコントロールできず、基本的に意識することはない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dig ****.ap-northeast-1.elb.amazonaws.com

;; ANSWER SECTION:
*****.elb.amazonaws.com. 60 IN A xxx.xxx.xxx.xxx
*****.elb.amazonaws.com. 60 IN A yyy.yyy.yyy.yyy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodeが増えるのにはある程度時間がかかるので、
アクセスが急増(5分間で50%以上のトラフィック増加が&lt;a href=&#34;http://aws.typepad.com/sajp/2015/05/aws-black-belt-elb.html&#34;&gt;目安&lt;/a&gt;)
したら捌ききれず、503を返すことがある。
前もって多量のアクセスが来ることが分かっていて、
&lt;a href=&#34;https://aws.amazon.com/jp/premiumsupport/signup/&#34;&gt;AWSサポート&lt;/a&gt;がBusiness以上なら
pre-warming申請することでnodeが増えた状態で待ち構えられる。&lt;/p&gt;

&lt;p&gt;バックエンドのアプリケーションがリクエストを処理できない場合、ELBのsurge queueに溜まっていく。
この数はCloudWatchのSurgeQueueLength(キュー長の急増)メトリクスで確認できる。
また、SurgeQueueLengthの最大値1024を超えるとリクエストは拒否され、その数はSpoiloverCount(過剰数)メトリクスに出る。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/elb-and-cloudwatch-metrics-in-depth/&#34;&gt;ELBの挙動とCloudWatchメトリクスの読み方を徹底的に理解する ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/premiumsupport/knowledge-center/elb-latency-troubleshooting/&#34;&gt;Elastic Load Balancing でのレイテンシーのトラブルシューティング&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Kinesis Streams/Firehose/Analyticsを試す</title>
          <link>http://sambaiz.net/article/67/</link>
          <pubDate>Mon, 20 Feb 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/67/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/&#34;&gt;https://aws.amazon.com/jp/kinesis/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;リアルタイムのストリーミングデータを扱うサービス群。
いまのところTokyoリージョンではKinesis Streamsしか使えない。&lt;/p&gt;

&lt;h3 id=&#34;kinesis-firehose-https-aws-amazon-com-jp-kinesis-firehose&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/&#34;&gt;Kinesis Firehose&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;AWSのデータストアに送るストリーム。自分でデータを読む処理を書かなくてよく、スケーリングも勝手にやってくれるので簡単に使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/faqs/&#34;&gt;https://aws.amazon.com/jp/kinesis/firehose/faqs/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Q: 送信先とは何ですか?
送信先はデータが配信されるデータストアです。Amazon Kinesis Firehose では、
現在送信先として Amazon S3、Amazon Redshift、Amazon Elasticsearch Service がサポートされています。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/pricing/&#34;&gt;料金&lt;/a&gt;は取り込まれたデータ量による。&lt;/p&gt;

&lt;p&gt;今回はS3に送ってみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-firehose.png&#34; alt=&#34;firehose作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;圧縮方法を設定したり、Lambdaを噛ませたりすることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-firehose2.png&#34; alt=&#34;firehose作成2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;StatusがActiveになったら&lt;a href=&#34;http://docs.aws.amazon.com/firehose/latest/dev/writing-with-agents.html&#34;&gt;Kinesis Agent&lt;/a&gt;で送ってみる。
CloudWatchとFirehoseにPutする権限が必要。Firehoseはkinesis:ではなくfirehose:なので注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum install –y aws-kinesis-agent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/aws-kinesis/agent.json&lt;/code&gt;を編集する。リージョンごとのエンドポイントは
&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#fh_region&#34;&gt;ここ&lt;/a&gt;
にある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;awsAccessKeyId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;awsSecretAccessKey&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;firehose.endpoint&amp;quot;: &amp;quot;https://firehose.us-east-1.amazonaws.com&amp;quot;, 
    &amp;quot;flows&amp;quot;: [
        {
            &amp;quot;filePattern&amp;quot;: &amp;quot;/tmp/hoge.log&amp;quot;, 
            &amp;quot;deliveryStream&amp;quot;: &amp;quot;hogefugastream&amp;quot;
        }
    ] 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service aws-kinesis-agent start
$ sudo chkconfig aws-kinesis-agent on
$ echo &amp;quot;aaa&amp;quot; &amp;gt;&amp;gt; /tmp/hoge.log
$ tail /var/log/aws-kinesis-agent/aws-kinesis-agent.log
com.amazon.kinesis.streaming.agent.Agent [INFO] Agent: Progress: 2 records parsed (168 bytes), 
and 2 records sent successfully to destinations. Uptime: 300044ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;S3に保存されているのを確認。&lt;/p&gt;

&lt;h3 id=&#34;kinesis-streams-https-aws-amazon-com-jp-kinesis-streams&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/streams/&#34;&gt;Kinesis Streams&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;用途を制限しないストリーム。データは保持期間の間、何度でも読むことができるので、
とりあえず必要なだけシャードを増やしてデータを入れておけばどうにかなる。
データを扱う側はそれぞれ独立に必要なタイミングで必要なだけpullするため、スケールするにあたってその先は別に考えることができ、
高負荷なシステムのlog aggregatorとして使われる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/streams/pricing/&#34;&gt;料金&lt;/a&gt;は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;時間単位のシャード速度： 1シャードは最大1000件/秒の1MB/秒の入力と2MB/秒の出力能力がある。&lt;/li&gt;
&lt;li&gt;PUTペイロードユニット: 追加する25KBのチャンクの数。5KBでも1チャンク。&lt;/li&gt;
&lt;li&gt;データ保持期間: デフォルトで24時間。7日まで延長可能。シャード時間ごとに課金。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;による。&lt;/p&gt;

&lt;p&gt;ストリーム作成時はシャード数を入れる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-streams.png&#34; alt=&#34;streams作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Firehoseと同じくKinesis Agentで送ってみる。
エンドポイントは&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#ak_region&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;awsAccessKeyId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;awsSecretAccessKey&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;kinesis.endpoint&amp;quot;: &amp;quot;https://kinesis.us-east-1.amazonaws.com&amp;quot;, 
    &amp;quot;flows&amp;quot;: [
        {
            &amp;quot;filePattern&amp;quot;: &amp;quot;/tmp/hoge.log&amp;quot;, 
            &amp;quot;kinesisStream&amp;quot;: &amp;quot;fugafugastream&amp;quot;
        }
    ] 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aws-cliでデータを&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/streams/latest/dev/fundamental-stream.html#get-records&#34;&gt;取得する&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;まず、シャードイテレーターを取得する。有効時間は300秒。
&lt;a href=&#34;http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#API_GetShardIterator_RequestSyntax&#34;&gt;TRIM_HORIZON&lt;/a&gt;
で最も古い方からデータを取得していく。SequenceNumberを指定して途中から読むこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aws kinesis get-shard-iterator --shard-id shardId-000000000000 --shard-iterator-type TRIM_HORIZON --stream-name fugafugastream
{
    &amp;quot;ShardIterator&amp;quot;: &amp;quot;AAAAAAAAAAFjKI0neNqY2N5HzGljYFCzoFqpQsdncdC6xE+ylnqvZpmusNfyViY3hBSS8WQXa67gvtkF0f2eKzxQ/Fd7SXZG8Inkb8l1UDF5t+jHgErA28gVSWyT4uYxTzzbnhm9AhcbztyQrjqehYcjEfpWIz5XmhY9K3Kjp0Crygy+OYNSS5PoQFcB1PZ7xMFE8zLTxJXLv1ANRu0Q+1m/JFxKQ3WS&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このシャードイテレータを使ってget-recordsする。データはBase64で入っているのでデコードして確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aws kinesis get-records --shard-iterator AAAAAAAAAAFjKI0neNqY2N5HzGljYFCzoFqpQsdncdC6xE+ylnqvZpmusNfyViY3hBSS8WQXa67gvtkF0f2eKzxQ/Fd7SXZG8Inkb8l1UDF5t+jHgErA28gVSWyT4uYxTzzbnhm9AhcbztyQrjqehYcjEfpWIz5XmhY9K3Kjp0Crygy+OYNSS5PoQFcB1PZ7xMFE8zLTxJXLv1ANRu0Q+1m/JFxKQ3WS
{
    &amp;quot;Records&amp;quot;: [
        {
            &amp;quot;Data&amp;quot;: &amp;quot;YWFhCg==&amp;quot;, 
            &amp;quot;PartitionKey&amp;quot;: &amp;quot;999679.8130737302&amp;quot;, 
            &amp;quot;ApproximateArrivalTimestamp&amp;quot;: 1487082145.518, 
            &amp;quot;SequenceNumber&amp;quot;: &amp;quot;49570460043263608661463102123405561406360875697772167170&amp;quot;
        }, 
        ...
    ], 
    &amp;quot;NextShardIterator&amp;quot;: &amp;quot;AAAAAAAAAAE08GRdLF1d76L1wCyLIiuAgpSEkKZSkUEO0VdUt3EOfdm1oOSXA1Xc4+tJPkSmB8g5NaQqDPRS/67u5IXermTUiAj6g2lgvDCGCqWFcYMAxIwIKZjKluCPQjL9kRaUqfVAaElRoKjp4Gv7JmuBDjKpxsbF2yk4uJJDAcevqH/VVkala8UbdhTweGyFgf9VhP/ljzXlrqkZ8wbD0eFwtZ3x&amp;quot;, 
    &amp;quot;MillisBehindLatest&amp;quot;: 0
}

$ echo &amp;quot;YWFhCg==&amp;quot; | base64 -d
aaa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kinesis-analytics-https-aws-amazon-com-jp-kinesis-analytics&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/analytics/&#34;&gt;Kinesis Analytics&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SourceとなるKinesis Streamsか、Firehoseを指定し、SQLを実行できる。そして必要なら次のストリームに入れることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-analytics.png&#34; alt=&#34;analytics作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はSourceとしてjsonで株価のデータが入っているDemo streamを使う。
いくつかSQLテンプレートが用意されていて、その中のContinuous Filterを選択。
Streamに入ってきたものをTECHで絞って出力する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- ** Continuous Filter ** 
-- Performs a continuous filter based on a WHERE condition.
--          .----------.   .----------.   .----------.              
--          |  SOURCE  |   |  INSERT  |   |  DESTIN. |              
-- Source--&amp;gt;|  STREAM  |--&amp;gt;| &amp;amp; SELECT |--&amp;gt;|  STREAM  |--&amp;gt;Destination
--          |          |   |  (PUMP)  |   |          |              
--          &#39;----------&#39;   &#39;----------&#39;   &#39;----------&#39;               
-- STREAM (in-application): a continuously updated entity that you can SELECT from and INSERT into like a TABLE
-- PUMP: an entity used to continuously &#39;SELECT ... FROM&#39; a source STREAM, and INSERT SQL results into an output STREAM
-- Create output stream, which can be used to send to a destination
CREATE OR REPLACE STREAM &amp;quot;DESTINATION_SQL_STREAM&amp;quot; (ticker_symbol VARCHAR(4), sector VARCHAR(12), change REAL, price REAL);
-- Create pump to insert into output 
CREATE OR REPLACE PUMP &amp;quot;STREAM_PUMP&amp;quot; AS INSERT INTO &amp;quot;DESTINATION_SQL_STREAM&amp;quot;
-- Select all columns from source stream
SELECT STREAM ticker_symbol, sector, change, price
FROM &amp;quot;SOURCE_SQL_STREAM_001&amp;quot;
-- LIKE compares a string to a string pattern (_ matches all char, % matches substring)
-- SIMILAR TO compares string to a regex, may use ESCAPE
WHERE sector SIMILAR TO &#39;%TECH%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-run-analytics.png&#34; alt=&#34;analytics実行&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdのmonitor_agentのデータをGoでGoogle Stackdriverに送って監視する</title>
          <link>http://sambaiz.net/article/66/</link>
          <pubDate>Sun, 19 Feb 2017 23:55:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/66/</guid>
          <description>

&lt;h2 id=&#34;fluentdのmonitor-agent-http-docs-fluentd-org-v0-12-articles-monitoring&#34;&gt;&lt;a href=&#34;http://docs.fluentd.org/v0.12/articles/monitoring&#34;&gt;fluentdのmonitor_agent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;メトリクスをjsonで返すAPIを提供する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type monitor_agent
  bind 0.0.0.0
  port 24220
&amp;lt;/source&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:24220/api/plugins.json | jq
{
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590d8c250&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;input&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;forward&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;forward&amp;quot;,
        &amp;quot;port&amp;quot;: &amp;quot;24222&amp;quot;,
        &amp;quot;bind&amp;quot;: &amp;quot;0.0.0.0&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: false,
      &amp;quot;retry_count&amp;quot;: null
    },
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590d894c4&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;input&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;monitor_agent&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;monitor_agent&amp;quot;,
        &amp;quot;bind&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
        &amp;quot;port&amp;quot;: &amp;quot;24220&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: false,
      &amp;quot;retry_count&amp;quot;: null
    },
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590dc1f2c&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;file&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;file&amp;quot;,
        &amp;quot;path&amp;quot;: &amp;quot;/var/log/td-agent/hoge.log&amp;quot;,
        &amp;quot;buffer_path&amp;quot;: &amp;quot;/var/log/td-agent/hoge.log.*&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: true,
      &amp;quot;buffer_queue_length&amp;quot;: 0,
      &amp;quot;buffer_total_queued_size&amp;quot;: 0,
      &amp;quot;retry_count&amp;quot;: 0
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとにStackdriverで異常を検知できるようにする。&lt;/p&gt;

&lt;h2 id=&#34;google-stackdriver-https-cloud-google-com-stackdriver&#34;&gt;&lt;a href=&#34;https://cloud.google.com/stackdriver/&#34;&gt;Google Stackdriver&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GoogleがStackdriverを買収して改造したもの。GCPだけではなくAWSのリソースも監視できる。
まだBeta。&lt;/p&gt;

&lt;h2 id=&#34;ec2インスタンスを監視する-https-cloud-google-com-monitoring-quickstart-aws-configure-sd-acct&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/quickstart-aws#configure-sd-acct&#34;&gt;EC2インスタンスを監視する&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GCPのメニューのSTACKDRIVER -&amp;gt; モニタリングで、プロジェクトを指定してStackdriverアカウントを作成する。&lt;/p&gt;

&lt;p&gt;今回はEC2で動いているfluentdを監視するので指示に従ってクロスアカウントアクセスのロールを作成、
Role ARNを入力してAWSアカウントと接続すると、
StackdriverのResouces-&amp;gt;InstancesでCPUの使用率などは確認できるが、
EC2にAgentを入れると詳細な情報を取得できる。&lt;/p&gt;

&lt;p&gt;GCPのメニューのサービスアカウントから接続したAWSアカウントを選択し、
Project-&amp;gt;編集者とLogging-&amp;gt;ログ書き込みロールのサービスアカウントを作成する。
新しい秘密鍵の提供にチェックを入れて、JSONのキーをダウンロードする。
これをEC2の&lt;code&gt;/etc/google/auth/application_default_credentials.json&lt;/code&gt;に置いて
&lt;code&gt;chown root:root&lt;/code&gt;、&lt;code&gt;chmod 400&lt;/code&gt;する。&lt;/p&gt;

&lt;p&gt;Monitoring AgentとLogging Agentをインストールし、
&lt;code&gt;stackdriver-collectd&lt;/code&gt;と&lt;code&gt;google-fluentd&lt;/code&gt;のプロセスがあれば正常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://repo.stackdriver.com/stack-install.sh
sudo bash stack-install.sh --write-gcm

curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh
sudo bash install-logging-agent.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリの使用量やTCPコネクション数などがとれていることを確認する。
Googleのドキュメントには見つからなかったけど、
旧Stackdriverと同様、&lt;code&gt;stackdriver_monitor: false&lt;/code&gt;のタグを付けると
&lt;a href=&#34;https://support.stackdriver.com/customer/portal/articles/1491785-collecting-data-from-specific-resources-only&#34;&gt;監視対象から外れる&lt;/a&gt;
っぽい。&lt;/p&gt;

&lt;h2 id=&#34;カスタムメトリクスを送る-https-cloud-google-com-monitoring-custom-metrics&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/&#34;&gt;カスタムメトリクスを送る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;MetricDescriptorを作成し、これにTimeSeriesデータを書き込んでいく。&lt;/p&gt;

&lt;h3 id=&#34;metricdescriptorの作成-https-cloud-google-com-monitoring-custom-metrics-creating-metrics-monitoring-create-metric-protocol&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#monitoring-create-metric-protocol&#34;&gt;MetricDescriptorの作成&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors&#34;&gt;MetricDescriptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;typeは&lt;code&gt;custom.googleapis.com/&lt;/code&gt;
から&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom_metric_names&#34;&gt;始める&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind&#34;&gt;metricKind&lt;/a&gt;
にはGAUGEのほかに変化量をとるDELTA、累積するCUMULATIVEを指定できる。&lt;/p&gt;

&lt;p&gt;labelはフィルタリングのためのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;fluentd buffer_queue_length&amp;quot;,
  &amp;quot;displayName&amp;quot;: &amp;quot;fluentd-buffer_queue_length&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
  &amp;quot;metricKind&amp;quot;: &amp;quot;GAUGE&amp;quot;,
  &amp;quot;valueType&amp;quot;: &amp;quot;INT64&amp;quot;,
  &amp;quot;labels&amp;quot;: [
    {
      &amp;quot;key&amp;quot;: &amp;quot;plugin_type&amp;quot;,
      &amp;quot;valueType&amp;quot;: &amp;quot;STRING&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The type of the plugin&amp;quot;
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをGoで登録する。&lt;/p&gt;

&lt;p&gt;gcpのほうのprojectでProject-&amp;gt;編集者のサービスアカウントを作成してパスを
環境変数&lt;code&gt;GOOGLE_APPLICATION_CREDENTIALS&lt;/code&gt;に入れて
&lt;a href=&#34;https://developers.google.com/identity/protocols/application-default-credentials&#34;&gt;Default Credential&lt;/a&gt;
にする。&lt;/p&gt;

&lt;p&gt;必要なパッケージをgo get。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get google.golang.org/api/monitoring/v3
$ go get golang.org/x/oauth2/google
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		panic(err)
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		panic(err)
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/*****&amp;quot;

		requestBody = &amp;amp;monitoring.MetricDescriptor{
			Description: &amp;quot;fluentd buffer_queue_length&amp;quot;,
			DisplayName: &amp;quot;fluentd-buffer_queue_length&amp;quot;,
			Type:        &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
			MetricKind:  &amp;quot;GAUGE&amp;quot;,
			ValueType:   &amp;quot;INT64&amp;quot;,
			Labels: []*monitoring.LabelDescriptor{
				&amp;amp;monitoring.LabelDescriptor{
					Key:         &amp;quot;plugin_type&amp;quot;,
					ValueType:   &amp;quot;STRING&amp;quot;,
					Description: &amp;quot;The type of the plugin&amp;quot;,
				},
			},
		}
	)

	response, err := client.Projects.MetricDescriptors.Create(name, requestBody).Context(ctx).Do()
	if err != nil {
		panic(err)
	}

	fmt.Println(&amp;quot;done&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登録されたことをlistで確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response, err := client.Projects.MetricDescriptors.List(name).Context(ctx).Do()
if err != nil {
  panic(err)
}

for _, v := range response.MetricDescriptors {
  fmt.Println(v.DisplayName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;API Request Count
Agent Memory Usage
Stream Space Used
...
fluentd-buffer_queue_length
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;timeseriesの書き込み-https-cloud-google-com-monitoring-custom-metrics-creating-metrics-monitoring-write-timeseries-protocol&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#monitoring-write-timeseries-protocol&#34;&gt;TimeSeriesの書き込み&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/TimeSeries&#34;&gt;TimeSeries&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;metricのtypeはMetricDescriptorのtypeと対応する。
pointsのendTimeはRFC3339のUTC文字列で渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
 &amp;quot;timeSeries&amp;quot;: [
  {
   &amp;quot;metric&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
    &amp;quot;labels&amp;quot;: {
     &amp;quot;plugin_type&amp;quot;: &amp;quot;file&amp;quot;
    }
   },
   &amp;quot;resource&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;aws_ec2_instance&amp;quot;,
    &amp;quot;labels&amp;quot;: {
     &amp;quot;project_id&amp;quot;: &amp;quot;*****&amp;quot;,
     &amp;quot;instance_id&amp;quot;: &amp;quot;*****&amp;quot;,
     &amp;quot;region&amp;quot;: &amp;quot;aws:ap-northeast-1&amp;quot;,
     &amp;quot;aws_account&amp;quot;: &amp;quot;*****&amp;quot;
    }
   },
   &amp;quot;points&amp;quot;: [
    {
     &amp;quot;interval&amp;quot;: {
      &amp;quot;endTime&amp;quot;: &amp;quot;2016-06-01T10:00:00-04:00&amp;quot;
     },
     &amp;quot;value&amp;quot;: {
      &amp;quot;int64Value&amp;quot;: 0
     }
    }
   ]
  }
 ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;resourceのtypeは
&lt;a href=&#34;https://cloud.google.com/logging/docs/reference/v2/rest/v2/monitoredResourceDescriptors/list#MonitoredResourceDescriptor&#34;&gt;MonitoredResourceDescriptor&lt;/a&gt;
と対応していて、
&lt;a href=&#34;https://cloud.google.com/logging/docs/reference/v2/rest/v2/monitoredResourceDescriptors/list&#34;&gt;list&lt;/a&gt;で確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
 &amp;quot;resourceDescriptors&amp;quot;: [
   {
   &amp;quot;type&amp;quot;: &amp;quot;aws_ec2_instance&amp;quot;,
   &amp;quot;displayName&amp;quot;: &amp;quot;Amazon EC2 Instance&amp;quot;,
   &amp;quot;description&amp;quot;: &amp;quot;A VM instance in Amazon EC2.&amp;quot;,
   &amp;quot;labels&amp;quot;: [
    {
     &amp;quot;key&amp;quot;: &amp;quot;project_id&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The identifier of the GCP project under which data is stored for the AWS account specified in the aws_account label (e.g., my-project).&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;instance_id&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The VM instance identifier assigned by AWS.&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;region&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The AWS region in which the VM is running. Supported AWS region values are listed by service at http://docs.aws.amazon.com/general/latest/gr/rande.html. The value supplied for this label must be prefixed with &#39;aws:&#39; (for example, &#39;aws:us-east-1&#39; is a valid value while &#39;us-east-1&#39; is not).&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;aws_account&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The AWS account number under which the VM is running.&amp;quot;
    }
   ]
  },
  ...
 ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;書くコード。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func writeFluentdBufferQueueLength() error {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		return err
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		return err
	}

	now := time.Now().UTC().Format(time.RFC3339)

	resource := &amp;amp;monitoring.MonitoredResource{
		Type: &amp;quot;aws_ec2_instance&amp;quot;,
		Labels: map[string]string{
			&amp;quot;project_id&amp;quot;:  &amp;quot;*****&amp;quot;,
			&amp;quot;instance_id&amp;quot;: &amp;quot;*****&amp;quot;,
			&amp;quot;region&amp;quot;:      &amp;quot;aws:ap-northeast-1&amp;quot;,
			&amp;quot;aws_account&amp;quot;: &amp;quot;*****&amp;quot;,
		},
	}

	metrics, err := fetchFluentdMetrics()
	if err != nil {
		return err
	}

	timeSeries := []*monitoring.TimeSeries{}

	for _, v := range metrics.Plugins {
		if v.OutputPlugin {

			fmt.Printf(&amp;quot;send %s\n&amp;quot;, v.Type)

			timeSeries = append(
				timeSeries,
				&amp;amp;monitoring.TimeSeries{
					Metric: &amp;amp;monitoring.Metric{
						Type: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
						Labels: map[string]string{
							&amp;quot;plugin_type&amp;quot;: v.Type,
						},
					},
					Resource: resource,
					Points: []*monitoring.Point{
						&amp;amp;monitoring.Point{
							Interval: &amp;amp;monitoring.TimeInterval{
								EndTime: now,
							},
							Value: &amp;amp;monitoring.TypedValue{
								Int64Value: int64p(v.BufferQueueLength),
							},
						},
					},
				},
			)
		}
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/try-stackdriver-159110&amp;quot;

		requestBody = &amp;amp;monitoring.CreateTimeSeriesRequest{
			TimeSeries: timeSeries,
		}
	)

	_, err = client.Projects.TimeSeries.Create(name, requestBody).Context(ctx).Do()
	if err != nil {
		return err
	}

	fmt.Println(&amp;quot;done&amp;quot;)

	return nil
}

const fluentdMonitorEndpoint = &amp;quot;http://localhost:24220/api/plugins.json&amp;quot;

type fluentdMetrics struct {
	Plugins []fluentdMetricsPlugin `json:&amp;quot;plugins&amp;quot;`
}
type fluentdMetricsPlugin struct {
	Type              string `json:&amp;quot;type&amp;quot;`
	OutputPlugin      bool   `json:&amp;quot;output_plugin&amp;quot;`
	BufferQueueLength int64  `json:&amp;quot;buffer_queue_length&amp;quot;`
}

// monitor_agentからfluentdのメトリクスを取得する
func fetchFluentdMetrics() (*fluentdMetrics, error) {

	resp, err := http.Get(fluentdMonitorEndpoint)
	if err != nil {
		return nil, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var ret fluentdMetrics

	if err := json.Unmarshal(body, &amp;amp;ret); err != nil {
		return nil, err
	}

	return &amp;amp;ret, nil
}

// int64 -&amp;gt; *int64
func int64p(n int64) *int64 {
	return &amp;amp;n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;a href=&#34;https://github.com/jasonlvhit/gocron&#34;&gt;gocron&lt;/a&gt;などで定期的に実行させる。&lt;/p&gt;

&lt;p&gt;読むコード。確認用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func readFluentdBufferQueueLength() error {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		return err
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		return err
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/*****&amp;quot;
	)

	start := time.Now().Add(time.Hour * -3).UTC().Format(time.RFC3339)
	now := time.Now().UTC().Format(time.RFC3339)

	filter := &amp;quot;metric.type = \&amp;quot;custom.googleapis.com/fluentd/buffer_queue_length\&amp;quot;&amp;quot;
	resp, err := client.Projects.TimeSeries.List(name).
		IntervalStartTime(start).
		IntervalEndTime(now).
		Filter(filter).Context(ctx).Do()
	if err != nil {
		return err
	}

	for _, v := range resp.TimeSeries {
		fmt.Println(v.Metric.Type)
		for _, p := range v.Points {
			fmt.Println(*(p.Value.Int64Value))
		}
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと届いていれば
Resource-&amp;gt;Metrics Explorerでもcustom/fluentd/buffer_queue_lengthを確認できる。&lt;/p&gt;

&lt;p&gt;これでAlertを設定できるようになった。TargetのResource TypeはCustom Metrics。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/66.png&#34; alt=&#34;Alertの設定&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのselectの中断処理(close, context)</title>
          <link>http://sambaiz.net/article/65/</link>
          <pubDate>Thu, 16 Feb 2017 20:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/65/</guid>
          <description>

&lt;h2 id=&#34;close-chan&#34;&gt;close(chan)&lt;/h2&gt;

&lt;p&gt;closeしたチャネルを読むとゼロ値になるので、selectで待っているやつにまとめて送れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	done := make(chan bool)

	wg := new(sync.WaitGroup)

	waitTillDone(wg, done)
	waitTillDone(wg, done)

    // こんなことしなくていい
	// done &amp;lt;- true
	// done &amp;lt;- true

	close(done)

	wg.Wait()
}

func waitTillDone(wg *sync.WaitGroup, done &amp;lt;-chan bool) {
	wg.Add(1)
	go func() {
		select {
		case v := &amp;lt;-done:
			fmt.Println(v) // false (ゼロ値)
			wg.Done()
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;context-https-godoc-org-golang-org-x-net-context&#34;&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;context&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;key-valueの値を渡せるほかにキャンセルやタイムアウトの仕組みをもつ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ctx := context.Background() // empty context
ctx, cancel = context.WithCancel(ctx)
ctx, cancel = context.WithDeadline(ctx, time.Now().Add(time.Second * 10))
ctx, cancel = context.WithTimeout(ctx, time.Second * 10)
ctx = context.WithValue(ctx, key, value)
ctx.Value(key).(Data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さっきdoneで待ってたところを&lt;code&gt;ctx.Done()&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	finished := make(chan interface{})
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // キャンセルしないとリークする

	go func() {
		if err := f1(ctx); err != nil {
			fmt.Printf(&amp;quot;main: %s\n&amp;quot;, err)
		} else {
			fmt.Println(&amp;quot;ok&amp;quot;)
		}
		close(finished)
	}()

	fmt.Println(&amp;quot;I will cancel!&amp;quot;)
	cancel()

	select {
	case &amp;lt;-finished:
		fmt.Println(&amp;quot;finished&amp;quot;)
	}
}

func f1(ctx context.Context) error {
	f2(ctx)
	select {
	case &amp;lt;-ctx.Done():
		fmt.Printf(&amp;quot;f1: %s\n&amp;quot;, ctx.Err())
		return ctx.Err()
	}
}

func f2(ctx context.Context) error {
	select {
	case &amp;lt;-ctx.Done():
		fmt.Printf(&amp;quot;f2: %s\n&amp;quot;, ctx.Err())
		return ctx.Err()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;I will cancel!
f2: context canceled
f1: context canceled
main: context canceled
finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、key-valueを受けわたすために使う場合は
type-safeにするために
NewContextで値を詰めて、FromContextで値を取り出すということがコメントに書いてある。
また、Contextはctxという名前で第一引数として渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
	name string
}

type key int

var userKey key = 0

func NewContext(ctx context.Context, u *User) context.Context {
	return context.WithValue(ctx, userKey, u)
}

func FromContext(ctx context.Context) (*User, bool) {
	u, ok := ctx.Value(userKey).(*User)
	return u, ok
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.golang.org/pipelines&#34;&gt;Go Concurrency Patterns: Pipelines and cancellation - The Go Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/07/22/context/&#34;&gt;Go1.7のcontextパッケージ | SOTA&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentd自身のログを拾う</title>
          <link>http://sambaiz.net/article/64/</link>
          <pubDate>Tue, 14 Feb 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/64/</guid>
          <description>

&lt;p&gt;fluentdは自身のログも&lt;code&gt;fluent.error&lt;/code&gt;のようなタグでイベントとして流す。&lt;/p&gt;

&lt;p&gt;バッファを0にして意図的にエラーを発生させてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

# throw away
&amp;lt;match fluent.info&amp;gt;
  @type null
&amp;lt;/match&amp;gt;

&amp;lt;match fluent.**&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;

# error!
&amp;lt;match **&amp;gt;
  @type file
  path /var/log/td-agent/hoge.log
  buffer_chunk_limit 0
  buffer_queue_limit 0
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、こんなのがtd-agent.logに出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluent.error: {&amp;quot;error&amp;quot;:&amp;quot;#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt;&amp;quot;,&amp;quot;error_class&amp;quot;:&amp;quot;Fluent::BufferQueueLimitError&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;forward error error=#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt; error_class=Fluent::BufferQueueLimitError&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、これだとaggregatorに集めたときにどのサーバーのfluentdに問題が発生してるのか分からない。
そこでホスト名を追加する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/55/&#34;&gt;fluentdのrecord_transformerでログを加工する - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter fluent.**&amp;gt;
  @type record_transformer
  enable_ruby

  &amp;lt;record&amp;gt;
    hostname &amp;quot;#{Socket.gethostname}&amp;quot;
    tag ${tag}
  &amp;lt;/record&amp;gt;
&amp;lt;/filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;fluent.error: {&amp;quot;error&amp;quot;:&amp;quot;#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt;&amp;quot;,&amp;quot;error_class&amp;quot;:&amp;quot;Fluent::BufferQueueLimitError&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;forward error error=#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt; error_class=Fluent::BufferQueueLimitError&amp;quot;,
&amp;quot;hostname&amp;quot;:&amp;quot;*****&amp;quot;,&amp;quot;tag&amp;quot;:&amp;quot;fluent.error&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://chopl.in/post/2013/04/27/fluentd_internal_log/&#34;&gt;fluentd自身のログにまつわるノウハウ - still deeper&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
