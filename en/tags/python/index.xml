<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on sambaiz-net</title>
    <link>https://www.sambaiz.net/en/tags/python/</link>
    <description>Recent content in python on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Thu, 09 Mar 2023 23:55:00 +0900</lastBuildDate><atom:link href="https://www.sambaiz.net/en/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Expresses a strength of the correlation between a categorical variable and a objective variable with the correlation ratio</title>
      <link>https://www.sambaiz.net/en/article/441/</link>
      <pubDate>Thu, 09 Mar 2023 23:55:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/441/</guid>
      <description>Pearson&amp;rsquo;s Product-Moment Correlation coefficient, calculated from the covariance \(\mathrm{Cov}(x,y) = E[(x - \bar{x})(y - \bar{y})]\) and the standard deviation \(\sigma_x = \sqrt{E[(x-\bar{x})^2]}\), is usually used for expressing the correlation. $$ \rho_{xy} = \frac{\mathrm{Cov}(x,y)}{\sigma_x \sigma_y} $$ However, since this coefficient expresses linear correlation between quantitative variables, it cannot be used for categorical variables, which are qualitative variables. The correlation between a qualitative and a quantitative variable can be expressed as the</description>
    </item>
    
    <item>
      <title>Python&#39;s built-in containers and collections.deque</title>
      <link>https://www.sambaiz.net/en/article/436/</link>
      <pubDate>Mon, 09 Jan 2023 16:32:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/436/</guid>
      <description>(C)Python has deque in the collections module in addition to build-in containers such as list, tuple, dict and set. $ python3 --version Python 3.10.7 list list is implemented with not linked-list but variable-length arrays. C++ STLのContainersとAlgorithms - sambaiz-net a = [&amp;#39;d&amp;#39;, &amp;#39;ae&amp;#39;, &amp;#39;ff&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] print(a[2:-1])</description>
    </item>
    
    <item>
      <title>Treat Spark struct as map to expand to multiple rows with explode</title>
      <link>https://www.sambaiz.net/en/article/384/</link>
      <pubDate>Wed, 13 Oct 2021 02:30:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/384/</guid>
      <description>When you read data without specifying schema in Spark, the schema is automatically determined from the input as follows. Why can Athena v2 fail to query map columns in parquet source tables - sambaiz-net # {&amp;#34;aaa&amp;#34;:123,&amp;#34;ccc&amp;#34;:[123],&amp;#34;eee&amp;#34;:{&amp;#34;fff&amp;#34;:123},&amp;#34;hhh&amp;#34;:null} df = spark.read.json(&amp;#34;s3://hogefuga/testjson/&amp;#34;) df.printSchema() &amp;#39;&amp;#39;&amp;#39; root |-- aaa: long (nullable = true) |-- ccc: array (nullable = true) | |-- element: long (containsNull = true) |-- eee: struct (nullable = true) | |-- fff:</description>
    </item>
    
    <item>
      <title>Enable Job Bookmark of AWS Glue to process from the records following ones executed previously</title>
      <link>https://www.sambaiz.net/en/article/333/</link>
      <pubDate>Fri, 16 Apr 2021 20:00:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/333/</guid>
      <description>Job Bookmark of AWS Glue is a feature that saves what records are processed, and prevent it from being executed next time. Parquet and ORC, which were not supported before 1.0, are now supported. AWS GlueでCSVを加工しParquetに変換してパーティションを切りA</description>
    </item>
    
    <item>
      <title>Python with structural subtyping by Protocol</title>
      <link>https://www.sambaiz.net/en/article/325/</link>
      <pubDate>Fri, 12 Feb 2021 02:53:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/325/</guid>
      <description>In Python that has no interface syntax, it can assure that the function can be called by checking the function existance with hasattr(). However, this method needs to insert asserting each time and the error cannot be known until runtime. class ImplClass(): def foo(self): print(&amp;#34;ok&amp;#34;) class NoImplClass(): pass def call(d): assert hasattr(d, &amp;#39;foo&amp;#39;) d.foo() if __name__ == &amp;#34;__main__&amp;#34;: call(ImplClass()) # =&amp;gt; ok call(NoImplClass()) # =&amp;gt; AssertionError If you describe Type</description>
    </item>
    
  </channel>
</rss>
