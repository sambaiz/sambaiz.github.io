<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on sambaiz-net</title>
    <link>https://www.sambaiz.net/en/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Sat, 04 Dec 2021 22:38:00 +0900</lastBuildDate><atom:link href="https://www.sambaiz.net/en/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implement Rabin–Karp algorithm in C&#43;&#43;</title>
      <link>https://www.sambaiz.net/en/article/387/</link>
      <pubDate>Sat, 04 Dec 2021 22:38:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/387/</guid>
      <description>Rabin–Karp algorithm is a string-searching algorithm using rolling hash. Rolling hash can be made with O(1) by removing a first element from the previous hash and add next element to it.
class rolling_hash { string str; int window_length = 0; long hash = 0; int head_idx = 0; long tail_pow; const int base = 128; public: rolling_hash(string str, int window_length) { this-&amp;gt;str = str; this-&amp;gt;window_length = window_length; long pow = 1; for (int i = 0; i &amp;lt; window_length; i++) { hash += str[i] * pow; pow *= base; } tail_pow = pow / base; } int get() { return hash; } // a_0 * base^0 + a_1 * base^1 + .</description>
    </item>
    
    <item>
      <title>struct and class in C&#43;&#43;</title>
      <link>https://www.sambaiz.net/en/article/385/</link>
      <pubDate>Tue, 30 Nov 2021 18:12:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/en/article/385/</guid>
      <description>class and struct in C++ are functionally equivalent but class is private by default as opposed to struct being public. class is used for encapsulation and if it has public fields and few methods, it seems that struct is used generally.
#include &amp;lt;iostream&amp;gt;using namespace std; class C { int value; public: C(int value) { this-&amp;gt;value = value; } int func() { return value; }; }; struct S { S(int value) { this-&amp;gt;value = value; } int value; private: int func() { return value; }; }; struct C2: S{ public: C2(int value) : S(value) { this-&amp;gt;value *= value; } int func2() { return value; } }; int main () { (new C(1))-&amp;gt;value; // member &amp;#34;C::value&amp;#34; (declared at line 2) is inaccessible  (new C(1))-&amp;gt;func(); (new S(1))-&amp;gt;value; (new S(1))-&amp;gt;func(); // function &amp;#34;S::func&amp;#34; (declared at line 18) is inaccessible  cout &amp;lt;&amp;lt; C2{9}.</description>
    </item>
    
  </channel>
</rss>
