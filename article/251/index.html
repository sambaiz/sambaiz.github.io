<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.79.1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/destyle.css">
  <style>
    body {
        background-color: #f1f1f1;
        line-height: 1.3;
        font-family: -apple-system, "BlinkMacSystemFont", "Helvetica Neue", "Yu Gothic", YuGothic, Verdana, Meiryo, sans-serif;
    }

    header {
        margin-block-start: 1.875rem;
        margin-block-end: 1.875rem;
    }

    header>.title {
        font-size: 1.875rem;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .sns {
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .sns-item {
        display: inline-block;
        margin: 3px;
    }

    .filmarks {
        display: inline-block;
        width: 30px;
        height: 30px;
        margin-top: 3px;
        background: url(/image/filmarks.svg) no-repeat;
        background-size: 450%;
    }

    header>.tags {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        max-width: 1000px;
        margin: auto;
        padding: 0 20px;
    }

    header>.tags .others {
        font-weight: bold;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
    }

    .nl {
        display: inline-block;
    }

    .cell {
        background-color: #fff;
        border-radius: 5px;
        padding: 10px;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px rgba(0, 0, 0, 0.1) inset;
    }

    time {
        color: #333;
    }

    .tag {
        color: #3a9240;
        margin: 0 5px;
    }

    .tag:hover {
        text-decoration: underline;
    }

     
    .paging {
        display: inline-block;
        font-size: 1.25rem;
        margin: 10px 10px;
    }

    .paging.next {
        float: right;
    }


     
    .list>.title {
        font-size: 1.75rem;
        margin: 0 0 10px 10px;
    }

     
    .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(262px, 1fr));
        gap: 20px;
        margin: 0 10px;
    }

    .grid-nl {
        width: 100%;
    }

    .grid-cell {
        height: 11.25rem;
        overflow: hidden;
        box-sizing: content-box;
    }

    .grid-cell>.title {
        font-size: 1.5rem;
        word-wrap: break-word;
    }

     
    .single {
        margin: 0 10px 10px 10px;
        line-height: 1.5;
    }

    @media screen and (min-width: 768px) {
        .single .cell {
            padding: 10px 20px;
        }
    }

    .single-header {
        margin-block-start: 1.875rem;
        margin-block-end: 1.875rem;
        line-height: 1.3;
    }

    .single-header h1 {
        font-size: 2rem;
        font-weight: bold;
    }

    .single h2 {
        font-size: 1.8rem;
        border-bottom: 1px solid #ddd;
        margin-block-start: 1.875rem;
    }

    .single h3 {
        font-size: 1.5rem;
        margin-block-start: 1.5rem;
    }

    .single h4 {
        font-size: 1.2rem;
        margin-block-start: 1rem;
    }

    .single a {
        color: #3a9240;
    }

    .single a:hover {
        text-decoration: underline;
    }

    .single p {
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single p>code {
        background-color: #eee;
        color: #333;
        padding: 0 0.2rem;
        display: inline-block;
        overflow: auto;
        max-width: 100%;
        vertical-align: bottom;
    }

    .single .highlight {
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px rgba(0, 0, 0, 0.1) inset;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single .highlight>pre {
        padding: 10px;
        overflow-x: auto;
    }

    .single img {
        max-width: 100%;
    }

    .single blockquote {
        border-left: 5px solid #ddd;
        color: #777;
        padding: 1rem 0 1rem 1rem;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single hr {
        color: #bbb;
        margin-block-start: 1.5rem;
        margin-block-end: 1.5rem;
    }

    .single ul {
        list-style-type: disc;
        padding-left: 1.5em;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }
</style>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.sambaiz.net/index.xml">
  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">

  <meta name="theme-color" content="#41a248">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@sambaiz">
  
  <title>動的計画法(DP)で計算結果を再利用して計算量を減らす - sambaiz-net</title>
  <meta name="twitter:title" content="動的計画法(DP)で計算結果を再利用して計算量を減らす - sambaiz-net">
  <meta property='og:title' content="動的計画法(DP)で計算結果を再利用して計算量を減らす - sambaiz-net">
  <meta property="og:type" content="article">
  
  <meta name="description" content="動的計画法(DP)">
  <meta name="twitter:description" content="動的計画法(DP)">
  
  

  <meta property="og:url" content="https://www.sambaiz.net/article/251/">
  <meta property="og:image" content="https://www.sambaiz.net/images/my_l.jpg">
  <meta name="twitter:image" content="https://www.sambaiz.net/images/my.jpg" />
  <meta name="google-site-verification" content="CEqNYjzc4Y7hb3FY7uUkmllGzeDc40brBwQJixeH61Q" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https:\/\/www.sambaiz.net\/"
    },
    "headline": "動的計画法(DP)で計算結果を再利用して計算量を減らす - sambaiz-net",
    "datePublished": "2019-12-30T19:28:00JST",
    "dateModified": "2019-12-30T19:28:00JST",
    "author": {
      "@type": "Person",
      "name": "sambaiz",
      "image": "https:\/\/www.sambaiz.net\/images/my.jpg"
    },
    "publisher": {
      "@type": "Person",
      "name": "sambaiz-net",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/www.sambaiz.net\/images/my.jpg",
        "height": 60,
        "width": 60
      }
    },
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/www.sambaiz.net\/images/my.jpg",
      "height": 138,
      "width": 138
    },
    "description": "動的計画法(DP)"
  }
</script>
</head>

<body>
  <div>
    <header>
      <div class="title">
        <img src="https://www.sambaiz.net/images/my.png" width="60px" height="60px" alt="アイコン" />
        <a class="nl" href="https://www.sambaiz.net/">
          <h1>sambaiz-net</h1>
        </a>
      </div>

      <div class="sns">
        <div class="sns-item">
          <a class="nl" href="https://twitter.com/sambaiz">
            <img src="//www.sambaiz.net/image/twitter.png" width="30px" height="30px" alt="twitter">
          </a>
        </div>
        <div class="sns-item">
          <a class="nl" href="https://github.com/sambaiz">
            <img src="//www.sambaiz.net/image/github.png" width="30px" height="30px" alt="github">
          </a>
        </div>
        <div class="sns-item">
          <a href="https://filmarks.com/users/sambaiz" class="filmarks" aria-label="filmarks"></a>
        </div>
      </div>
      <div class="tags">
        <div>
          
          <a class="tag" href="/tags/aws/">
            aws</a>
          
          <a class="tag" href="/tags/golang/">
            golang</a>
          
          <a class="tag" href="/tags/machinelearning/">
            machinelearning</a>
          
          <a class="tag" href="/tags/python/">
            python</a>
          
          <a class="tag" href="/tags/kubernetes/">
            kubernetes</a>
          
          <a class="tag" href="/tags/log/">
            log</a>
          
          <a class="tag" href="/tags/docker/">
            docker</a>
          
          <a class="tag" href="/tags/gcp/">
            gcp</a>
          
          <a class="tag" href="/tags/infra/">
            infra</a>
          
          <a class="tag" href="/tags/tensorflow/">
            tensorflow</a>
          
          <a class="tag others" href="/tags/">...</a>
        </div>
      </div>
    </header>

<div class="container">
  <article class="single">
    <div class="cell">
      <div class="single-header">
        <h1>動的計画法(DP)で計算結果を再利用して計算量を減らす</h1>
        <time>2019-12-30</time>
        <a class="tag" href="/tags/c&#43;&#43;/">c&#43;&#43;</a><a class="tag" href="/tags/algorithm/">algorithm</a>
      </div>
      <p>動的計画法(DP, Dynamic Programming)は記録した計算結果を、帰納的に求められるより大きな計算で利用するアルゴリズムの総称。
例えば、フィボナッチ数列の項<code>f(x)</code>を求めるのに、<code>f(x-1)</code>と<code>f(x-2)</code>の結果を記録しておけばそれらを足すだけで済む。</p>
<p>いくつか問題を解いてみる。</p>
<h2 id="longest-common-subsequencehttpsleetcodecomproblemslongest-common-subsequence"><a href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common Subsequence</a></h2>
<p>最長共通部分列問題。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">Given two strings text1 and text2, return the length of their longest common subsequence.

Example 1:

Input: text1 = &#34;abcde&#34;, text2 = &#34;ace&#34; 
Output: 3  
Explanation: The longest common subsequence is &#34;ace&#34; and its length is 3.
</code></pre></div><p>単純に毎回一から探索するとO(n^3)になるが、text1のi番目までとtext2のj番目までの共通部分列の長さを<code>DP[i-1][j-1]</code>に記録しておくと、
ヒントにあるように、それぞれの文字列に1文字足したときに
それが同じ文字ならその分伸ばした <code>DP[i - 1][j - 1] + 1</code> となり
違う文字ならそのまま <code>max(DP[i - 1][j], DP[i][j - 1])</code> となる
ことに気付けると毎回探索しなくてよくなりO(n^2)にできる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">int</span> longestCommonSubsequence(string text1, string text2) {
        vector<span style="color:#ff79c6">&lt;</span>vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;&gt;</span> DP(text1.length()<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>); <span style="color:#6272a4">// [i][j] = length
</span><span style="color:#6272a4"></span>        vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;</span> tmp(text2.length()<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">0</span>);
        DP[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> tmp;
        <span style="color:#ff79c6">for</span>(<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> text1.length(); i<span style="color:#ff79c6">++</span>) {
            vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;</span> tmp(text2.length()<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">0</span>);
            DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> tmp;
            <span style="color:#ff79c6">for</span>(<span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; j <span style="color:#ff79c6">&lt;</span> text2.length(); j<span style="color:#ff79c6">++</span>) {
                <span style="color:#ff79c6">if</span> (text1[i] <span style="color:#ff79c6">==</span> text2[j]) {
                    DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][j<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> DP[i][j] <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>;
                } <span style="color:#ff79c6">else</span> {
                    DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][j<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> max(DP[i][j<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>], DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][j]);
                }
            }
        }
        <span style="color:#ff79c6">return</span> DP[text1.length()][text2.length()];
    }
};
</code></pre></div><h2 id="longest-palindromic-substring---leetcodehttpsleetcodecomproblemslongest-palindromic-substring"><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring - LeetCode</a></h2>
<p>文字列に含まれる最長の回文を返す問題。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:
Input: &#34;babad&#34;
Output: &#34;bab&#34;
Note: &#34;aba&#34; is also a valid answer.
</code></pre></div><p>最初に書いたコードはこれ。オーダーは部分文字列を網羅するのにO(n^2)＊回文かチェックするのにO(n)=O(n^3)で、タイムアウトしてしまう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
    <span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">isPalindromic</span>(string s) {
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> (s.length() <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>; i<span style="color:#ff79c6">++</span>) {
            <span style="color:#ff79c6">if</span> (s[i] <span style="color:#ff79c6">!=</span> s[s.length() <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">-</span> i]) {
                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
            }
        }
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
    }
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    string longestPalindrome(string s) {
        string ret <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;&#34;</span>;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> s.length(); i<span style="color:#ff79c6">++</span>) {
            <span style="color:#ff79c6">if</span> (ret.length() <span style="color:#ff79c6">&gt;=</span> s.length() <span style="color:#ff79c6">-</span> i) {
                <span style="color:#ff79c6">break</span>;
            }
            <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> s.length(); j <span style="color:#ff79c6">&gt;=</span> i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>; j<span style="color:#ff79c6">--</span>) {
                <span style="color:#ff79c6">if</span> (ret.length() <span style="color:#ff79c6">&gt;=</span> j <span style="color:#ff79c6">-</span> i) {
                    <span style="color:#ff79c6">break</span>;
                }
                string substr <span style="color:#ff79c6">=</span> s.substr(i, j <span style="color:#ff79c6">-</span> i);
                <span style="color:#ff79c6">if</span> (isPalindromic(substr)) {
                    ret <span style="color:#ff79c6">=</span> substr;
                    <span style="color:#ff79c6">break</span>;
                }
            }
        }
        <span style="color:#ff79c6">return</span> ret;
    }
};
</code></pre></div><p>今回の問題ではある文字列<code>S</code>が回文なら、その両端に同じ文字<code>c</code>が付いた文字列<code>cSc</code>も回文であることを利用し、
中央の文字を決めて、回文である限り範囲を両端に伸ばしていくことで、回文判定が両端の文字の一致だけのO(1)でできるようになった。
これにより全体のオーダーがO(n^2)に改善され、タイムアウトしなくなった。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
    <span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">isPalindromic</span>(string s) {
        <span style="color:#ff79c6">return</span> s[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> s[s.length() <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>];
    }
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    string longestPalindrome(string s) {
        string ret <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;&#34;</span>;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> s.length(); i<span style="color:#ff79c6">++</span>) {
            <span style="color:#ff79c6">if</span> (ret.length() <span style="color:#ff79c6">&gt;=</span> min(i<span style="color:#ff79c6">*</span><span style="color:#bd93f9">2</span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">2</span>, <span style="color:#8be9fd">int</span>(s.length()<span style="color:#ff79c6">-</span>i)<span style="color:#ff79c6">*</span><span style="color:#bd93f9">2</span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">2</span>)) {
                <span style="color:#ff79c6">break</span>;
            }
            <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; j <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">2</span>; j<span style="color:#ff79c6">++</span>) {
                <span style="color:#ff79c6">if</span>(i<span style="color:#ff79c6">+</span>j <span style="color:#ff79c6">&gt;</span> s.length()) {
                    <span style="color:#ff79c6">break</span>;
                }
                string substr <span style="color:#ff79c6">=</span> s.substr(i, j);
                <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>isPalindromic(substr)) {
                    <span style="color:#ff79c6">break</span>;
                }
                <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> k <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; k <span style="color:#ff79c6">&lt;=</span> i; k<span style="color:#ff79c6">++</span>) {
                    <span style="color:#ff79c6">if</span> (i<span style="color:#ff79c6">+</span>j<span style="color:#ff79c6">+</span>k <span style="color:#ff79c6">&gt;</span> s.length()) {
                        <span style="color:#ff79c6">break</span>;
                    }
                    substr <span style="color:#ff79c6">=</span> s.substr(i<span style="color:#ff79c6">-</span>k, j<span style="color:#ff79c6">+</span>k<span style="color:#ff79c6">*</span><span style="color:#bd93f9">2</span>);
                    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>isPalindromic(substr)) {
                        <span style="color:#ff79c6">break</span>;
                    }
                    <span style="color:#ff79c6">if</span> (ret.length() <span style="color:#ff79c6">&lt;</span> substr.length()) {
                        ret <span style="color:#ff79c6">=</span> substr;
                    }
                }
            }
        }
        <span style="color:#ff79c6">return</span> ret;
    }
};
</code></pre></div><h2 id="maximum-sum-circular-subarray---leetcodehttpsleetcodecomproblemsmaximum-sum-circular-subarray"><a href="https://leetcode.com/problems/maximum-sum-circular-subarray">Maximum Sum Circular Subarray - LeetCode</a></h2>
<p>最大部分配列問題の配列が循環する版。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
</code></pre></div><p>最大部分配列問題を<code>O(n)</code>で解く方法として<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm">Kadane&rsquo;s algorithm</a>というのがあって、
配列Aのn番目の要素<code>A[n]</code>を末尾とする部分配列のうち最大のものの和<code>S_n</code>は <code>max(S_{n-1} + A[n], A[n])</code> となるので、これを配列の始めから順に計算することでSが最大となる最大部分配列を探すことができる。</p>
<p>この問題では配列が循環しているので <code>[10, -5, 10]</code> のような場合、末尾と先頭の10を部分配列として扱わなければいけない。
そこで、始まりのindexをずらしてローテーションしたのが次の実装。ただこれだとタイムアウトしてしまう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">int</span> maxSubarraySumCircular(vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;&amp;</span> A) {
        <span style="color:#8be9fd">int</span> ret <span style="color:#ff79c6">=</span> INT_MIN;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> A.size(); i<span style="color:#ff79c6">++</span>) {
            <span style="color:#8be9fd">int</span> S <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
            <span style="color:#ff79c6">for</span>(<span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; j <span style="color:#ff79c6">&lt;</span> A.size(); j<span style="color:#ff79c6">++</span>) {
                S <span style="color:#ff79c6">=</span> max(S<span style="color:#ff79c6">+</span>A[(j<span style="color:#ff79c6">+</span>i) <span style="color:#ff79c6">%</span> A.size()], A[(j<span style="color:#ff79c6">+</span>i) <span style="color:#ff79c6">%</span> A.size()]);
                ret <span style="color:#ff79c6">=</span> max(ret, S);
            }
        }
        <span style="color:#ff79c6">return</span> ret;
    }
};
</code></pre></div><p>そこで両端またぎのケースは最小の部分を探して総和から引くようにしたのが次の実装。これで<code>O(n)</code>になり通るようになった。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">int</span> maxSubarraySumCircular(vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;&amp;</span> A) {
        <span style="color:#6272a4">// case 1. [... --answer-- ...]
</span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">long</span> maxsub <span style="color:#ff79c6">=</span> A[<span style="color:#bd93f9">0</span>];
        <span style="color:#8be9fd">long</span> sum <span style="color:#ff79c6">=</span> A[<span style="color:#bd93f9">0</span>];
        <span style="color:#8be9fd">long</span> S <span style="color:#ff79c6">=</span> A[<span style="color:#bd93f9">0</span>];
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; i <span style="color:#ff79c6">&lt;</span> A.size(); i<span style="color:#ff79c6">++</span>) {
            S <span style="color:#ff79c6">=</span> max(S<span style="color:#ff79c6">+</span>A[i], <span style="color:#8be9fd">long</span>(A[i]));
            maxsub <span style="color:#ff79c6">=</span> max(maxsub, S);
            sum <span style="color:#ff79c6">+=</span> A[i];
        }
        
        <span style="color:#6272a4">// case 2. [wer-- ...... --ans]
</span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">long</span> minsub <span style="color:#ff79c6">=</span> A[<span style="color:#bd93f9">0</span>];
        S <span style="color:#ff79c6">=</span> A[<span style="color:#bd93f9">0</span>];
        <span style="color:#8be9fd">bool</span> isSubarray <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">false</span>;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>; i <span style="color:#ff79c6">&lt;</span> A.size(); i<span style="color:#ff79c6">++</span>) {
            <span style="color:#ff79c6">if</span> (S<span style="color:#ff79c6">+</span>A[i] <span style="color:#ff79c6">&gt;=</span> A[i]){
                isSubarray <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">true</span>;
                S <span style="color:#ff79c6">=</span> A[i];
            } <span style="color:#ff79c6">else</span> {
                S <span style="color:#ff79c6">+=</span> A[i];
            }
            minsub <span style="color:#ff79c6">=</span> min(minsub, S);
        }
        
        <span style="color:#ff79c6">if</span> (isSubarray) {
            <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">max</span>(maxsub, sum <span style="color:#ff79c6">-</span> minsub);
        } <span style="color:#ff79c6">else</span> {
            <span style="color:#ff79c6">return</span> maxsub;
        }
    }
};
</code></pre></div><h2 id="ugly-number-ii---leetcodehttpsleetcodecomproblemsugly-number-ii"><a href="https://leetcode.com/problems/ugly-number-ii/">Ugly Number II - LeetCode</a></h2>
<p>2, 3, 5のみで素因数分解できるn番目の正数を返す問題。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">Write a program to find the n-th ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. 

Example:
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
</code></pre></div><p>Nが条件を満たすなら、<code>N*2</code>, <code>N*3</code>, <code>N*5</code>も条件を満たすので、これらの値を重複しないように記録していく。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">int</span> nthUglyNumber(<span style="color:#8be9fd">int</span> n) {
        <span style="color:#ff79c6">if</span> (n <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span>) {
            <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
        }
        <span style="color:#ff79c6">if</span> (n <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>) {
            <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>;
        }
        
        vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">int</span><span style="color:#ff79c6">&gt;</span> U;
        U.push_back(<span style="color:#bd93f9">1</span>);
        <span style="color:#8be9fd">int</span> idx2 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, idx3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>, idx5 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>; i <span style="color:#ff79c6">&lt;=</span> n; i<span style="color:#ff79c6">++</span>) {
            <span style="color:#8be9fd">int</span> next <span style="color:#ff79c6">=</span> min(U[idx2] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span>, min(U[idx3] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">3</span>, U[idx5] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">5</span>));
            U.push_back(next);
            <span style="color:#ff79c6">while</span> (U[idx2] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">&lt;=</span> next) idx2<span style="color:#ff79c6">++</span>;
            <span style="color:#ff79c6">while</span> (U[idx3] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">&lt;=</span> next) idx3<span style="color:#ff79c6">++</span>;
            <span style="color:#ff79c6">while</span> (U[idx5] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">5</span> <span style="color:#ff79c6">&lt;=</span> next) idx5<span style="color:#ff79c6">++</span>;
        }
        <span style="color:#ff79c6">return</span> U[U.size() <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>];
    }
};
</code></pre></div><p>対象の素数が引数で渡される<a href="https://leetcode.com/problems/super-ugly-number/">Super Ugly Number - LeetCode</a>も同様に解ける。</p>
<h2 id="interleaving-string---leetcodehttpsleetcodecomproblemsinterleaving-string"><a href="https://leetcode.com/problems/interleaving-string/">Interleaving String - LeetCode</a></h2>
<p>2つの文字列を順番を変えずに組み合わせてある文字列が作れるかを判定する問題。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">Given s1, s2, and s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:
Input: s1 = &#34;aabcc&#34;, s2 = &#34;dbbca&#34;, s3 = &#34;aadbbcbcac&#34;
Output: true
</code></pre></div><p>基本的な戦略としてはs1かs2の先頭一文字を取り出すのを繰り返しs3の完成を目指すというものだが、
次のような再帰で解くと、2つの文字列が長く共通文字が多い場合にタイムアウトしてしまう。
一見<code>O(n^2)</code>に見えるが、どちらから取っても良い場合に両方の場合を探索してしまうので、最悪の場合は<code>O(2^n)</code>になってしまう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">bool</span> isInterleave(string s1, string s2, string s3) {
        <span style="color:#ff79c6">if</span> (s3.size() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
            <span style="color:#ff79c6">if</span> (s1.size() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> s2.size() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
            } <span style="color:#ff79c6">else</span> {
                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
            }
        }
        <span style="color:#8be9fd">bool</span> b <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">false</span>;
        <span style="color:#ff79c6">if</span> (s1.size() <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> s3[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> s1[<span style="color:#bd93f9">0</span>]) {
            b <span style="color:#ff79c6">=</span> b <span style="color:#ff79c6">||</span> isInterleave(s1.substr(<span style="color:#bd93f9">1</span>), s2, s3.substr(<span style="color:#bd93f9">1</span>));
        }
        <span style="color:#ff79c6">if</span> (s2.size() <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> s3[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> s2[<span style="color:#bd93f9">0</span>]) {
            b <span style="color:#ff79c6">=</span> b <span style="color:#ff79c6">||</span> isInterleave(s1, s2.substr(<span style="color:#bd93f9">1</span>), s3.substr(<span style="color:#bd93f9">1</span>));
        }
        <span style="color:#ff79c6">return</span> b;
    }
};
</code></pre></div><p>ということで次のようなテーブルで重複しないように探索し <code>O(n^2)</code> になるようにした。</p>
<p><img src="https://www.sambaiz.net/images/251-interleaving.png" alt="テーブル"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Solution</span> {
<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
    <span style="color:#8be9fd">bool</span> isInterleave(string s1, string s2, string s3) {
        <span style="color:#ff79c6">if</span> (s3.size() <span style="color:#ff79c6">!=</span> s1.size() <span style="color:#ff79c6">+</span> s2.size()) {
            <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
        }
        vector<span style="color:#ff79c6">&lt;</span>vector<span style="color:#ff79c6">&lt;</span><span style="color:#8be9fd">bool</span><span style="color:#ff79c6">&gt;&gt;</span> table;
        <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> s1.size()<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>; i<span style="color:#ff79c6">++</span>) {
            table.push_back({});
            <span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; j <span style="color:#ff79c6">&lt;</span> s2.size()<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>; j<span style="color:#ff79c6">++</span>) {
                <span style="color:#ff79c6">if</span> (i <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> j <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
                    table[i].push_back(<span style="color:#8be9fd;font-style:italic">true</span>);
                } <span style="color:#ff79c6">else</span> <span style="color:#50fa7b">if</span> (i <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
                    table[i].push_back(table[i][j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">&amp;&amp;</span> s2[j<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> s3[i <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>]);
                } <span style="color:#ff79c6">else</span> <span style="color:#50fa7b">if</span> (j <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
                    table[i].push_back(table[i <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>][j] <span style="color:#ff79c6">&amp;&amp;</span> s1[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> s3[i <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>]);
                } <span style="color:#ff79c6">else</span> {
                    table[i].push_back(
                        (table[i <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>][j] <span style="color:#ff79c6">&amp;&amp;</span> s1[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> s3[i <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>]) <span style="color:#ff79c6">||</span>
                        (table[i][j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">&amp;&amp;</span> s2[j<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> s3[i <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>]));
                }
            }
        }
        <span style="color:#ff79c6">return</span> table[s1.size()][s2.size()];
    }
};
</code></pre></div><h2 id="個数制限なしナップザック問題">個数制限なしナップザック問題</h2>
<p>通常のナップザック問題は、重さ<code>w_i</code>で価値<code>v_i</code>のナップザックがN個あり、重さの和がWを超えないように選んだときの価値の和の最大値を求める問題。値は全て正の整数。
単純に総当たりすると<code>O(2^N)</code>となりNが大きいとうまくいかない。
DPを用いてi番目以降のナップザックから重さがWを超えないように選んだ時の価値の和の最大値を返す関数<code>f(i, W)</code>の値を<code>DP[i][W]</code>に記録しておくと、この関数は次の漸化式の値を返すだけで引数のパターンは<code>N*W</code>しかないので<code>O(NW)</code>で実行できる。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">f</span>(<span style="color:#8be9fd">int</span> i, W) {
    <span style="color:#ff79c6">return</span> max(DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][W], DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][W<span style="color:#ff79c6">-</span>w[i]] <span style="color:#ff79c6">+</span> v[i]); 
}
</code></pre></div><p>なお、Wがとても大きいとタイムアウトする可能性があるが、その場合i番目以降のナップザックから価値の和vとなるように選んだ時の重さの最小値 <code>f(i, v)</code> を記録し、<code>DP[i][v] &lt;= W</code> となる最大のvを返すようにすることでオーダーをWに依存しない <code>O(N Σv)</code> にすることができる。</p>
<p>個数制限なしナップザック問題は同じナップザックを複数個選ぶことができるようにしたもの。
次のようにループで個数kを探索すると、<code>w[i]=1, W=0</code>のときにW回ループするので<code>O(NW^2)</code>となってしまう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cpp" data-lang="cpp"><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">f</span>(<span style="color:#8be9fd">int</span> i, W) {
    <span style="color:#8be9fd">int</span> m <span style="color:#ff79c6">=</span> DP[i <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>][W];
    <span style="color:#8be9fd">int</span> k <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
    <span style="color:#ff79c6">while</span>(<span style="color:#8be9fd;font-style:italic">true</span>) {
        k<span style="color:#ff79c6">++</span>;
        <span style="color:#ff79c6">if</span> (W <span style="color:#ff79c6">-</span> k <span style="color:#ff79c6">*</span> w[i] <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>) {
            <span style="color:#ff79c6">break</span>;
        }
        m <span style="color:#ff79c6">=</span> max(m, DP[i<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>][W <span style="color:#ff79c6">-</span> k <span style="color:#ff79c6">*</span> w[i]] <span style="color:#ff79c6">+</span> k <span style="color:#ff79c6">*</span> v[i]);
    }
    <span style="color:#ff79c6">return</span> m;
}
</code></pre></div><p><code>f(i, W)</code>でk(&gt;=1)個選んだときに価値が最大となる場合、その値は <code>f(i, W - k * w[i]) + k * v[i]</code> と等しくなる。
そのkを探すために結局 <code>f(i, W - 1 * w[i])</code>, <code>f(i, W - 2 * w[i])</code> &hellip; を見ていくことになりそうだが、
<code>f(i, W - 1 * w[i])</code> で既に　<code>f(i, W - 2 * w[i])</code>, <code>f(i, W - 3 * w[i])</code>, &hellip; を見ているので、1個分Wが小さいときの値だけ見ればkの探索は不要であることが分かる。
したがって、<code>f(i, W) = max(f(i+1, W), f(i, W - w[i]) + v[i]) (if W - w[i] &gt;= 0)</code> となり <code>O(NW)</code> にすることができる。</p>
<h2 id="参考">参考</h2>
<p><a href="https://book.mynavi.jp/ec/products/detail/id=22672">プログラミングコンテストチャレンジブック [第2版]</a></p>

    </div>
  </article>
</div>

</div>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
      m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-39190067-3', 'auto');
  ga('send', 'pageview');
</script>


</body>

</html>