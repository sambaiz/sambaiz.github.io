<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>http://sambaiz.net/article/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>2017-06-15 00:17:00 &#43;0900 JST</updated>

    
      
        <item>
          <title>NorikraでログをJOINする</title>
          <link>http://sambaiz.net/article/111/</link>
          <pubDate>Thu, 15 Jun 2017 00:17:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/111/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/109/&#34;&gt;NorikraとFluentdで流れてきたログをリアルタイムに集計する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;適当なログを出すコードを書いた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/lottery-log&#34;&gt;sambaiz/lottery-log&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これは以下のようなlottery.logを出力し続け、数秒後に一定確率で同じuidのreceived.logを出力するもの。
広告的に言えば、lotteryがimpで、receivedがclickといった感じかな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// lottery.log
{&amp;quot;ts&amp;quot;:1497453504.6818597,&amp;quot;uid&amp;quot;:&amp;quot;b18c0d98-19b2-4e37-8fc4-6b00a4b728c3&amp;quot;,&amp;quot;prize&amp;quot;:855,&amp;quot;isWin&amp;quot;:true}
// received.log
{&amp;quot;ts&amp;quot;:1497453515.932101,&amp;quot;uid&amp;quot;:&amp;quot;bc4f578f-4a5f-47f1-a4e0-1ef0b43c316e&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリはこんな感じ。一つはlotteryログとreceivedログをuidでJOINするもので、
もう一つはJavaの関数でboolを0/1にして平均をとることでisWinがtrueである割合を出している。
received_rateも出したかったのだけど、うまい書き方が思いつかなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker exec norikra norikra-client query add lottery_agg &#39;SELECT COUNT(*) as received_count, AVG(prize) as prize_avg, SUM(prize) as prize_sum FROM lottery.win:time_batch(1 min).std:unique(uid) as a, received.win:time_batch(1 sec).std:unique(uid) as b WHERE a.uid = b.uid&#39;

$ docker exec norikra norikra-client query add lottery_win_rate &#39;SELECT avg(Boolean.compare(isWin, false)) as win_rate FROM lottery.win:time_batch(1 sec)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、このクエリの結果をElasticsearchに送って可視化してみたのがこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type tail
  path /var/log/lottery.log
  pos_file /etc/td-agent/log.pos
  tag event.lottery
  format json
&amp;lt;/source&amp;gt;

&amp;lt;source&amp;gt;
  @type tail
  path /var/log/received.log
  pos_file /etc/td-agent/log.pos
  tag event.received
  format json
&amp;lt;/source&amp;gt;

&amp;lt;match event.*&amp;gt;
  @type   norikra
  norikra localhost:26571
  
  remove_tag_prefix event # event.*の部分が
  target_map_tag    yes   # targetになる

  &amp;lt;default&amp;gt;
    auto_field false 
  &amp;lt;/default&amp;gt;
&amp;lt;/match&amp;gt;

&amp;lt;source&amp;gt;
  @type   norikra
  norikra localhost:26571
  &amp;lt;fetch&amp;gt;
    method   event
    target   lottery_agg
    tag      string data.lottery_agg
    interval 1m
  &amp;lt;/fetch&amp;gt;
  &amp;lt;fetch&amp;gt;
    method   event
    target   lottery_win_rate
    tag      string data.lottery_win_rate
    interval 1m
  &amp;lt;/fetch&amp;gt;
&amp;lt;/source&amp;gt;

&amp;lt;match data.lottery_agg&amp;gt;
  @type elasticsearch
  host 172.31.5.20
  port 9200
  logstash_prefix lottery
  type_name lottery_agg
  logstash_format true
&amp;lt;/match&amp;gt;

&amp;lt;match data.lottery_win_rate&amp;gt;
  @type elasticsearch
  host 172.31.5.20
  port 9200
  logstash_prefix lottery
  type_name lottery_win_rate
  logstash_format true
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/111v.png&#34; alt=&#34;可視化したもの&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>VSでのネイティブプラグインのビルドからUnityでのWSAのビルドまでをバッチでする</title>
          <link>http://sambaiz.net/article/110/</link>
          <pubDate>Tue, 13 Jun 2017 00:32:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/110/</guid>
          <description>

&lt;h2 id=&#34;vsでのネイティブプラグインのビルド&#34;&gt;VSでのネイティブプラグインのビルド&lt;/h2&gt;

&lt;p&gt;VSが使っているビルドツール
&lt;a href=&#34;https://docs.microsoft.com/ja-jp/visualstudio/msbuild/msbuild&#34;&gt;MSBuild&lt;/a&gt;を使う。
VSのプロジェクトファイルにはMSBuildのXMLが含まれている。
これ自体はVSに依存していないため、単体で動かすこともできる。&lt;/p&gt;

&lt;p&gt;パスが通ってなかったらパスを通す。管理者権限が必要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild
&#39;MSBuild&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;別プロセスから適用されるので立ち上げ直すとパスが通っていることを確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild /version
Microsoft (R) Build Engine バージョン 15.1.1012.6693
Copyright (C) Microsoft Corporation.All rights reserved.

15.1.1012.6693
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドして&lt;code&gt;Assets\Plugins&lt;/code&gt;に配置する。これは前作ったBLEのネイティブプラグインのもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105/&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; git clone git@github.com:sambaiz/UnityBLE_UWP.git
&amp;gt; cd UnityBLE_UWP
&amp;gt; MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
&amp;gt; MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
&amp;gt; copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
&amp;gt; copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
&amp;gt; cd ..
&amp;gt; rmdir /S /Q UnityBLE_UWP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなエラーが出てきたらmscorlib.dllをインポートできていないのが原因のようで、
restoreしたらうまくいった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error CS0518: 定義済みの型 &#39;System.Object&#39; は定義、またはインポートされていません
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unityでのwsaのビルド&#34;&gt;UnityでのWSAのビルド&lt;/h2&gt;

&lt;p&gt;同様にUnityもパスが通ってなかったら通す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity
&#39;Unity&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files\Unity\Editor&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/BuildPipeline.BuildPlayer.html&#34;&gt;スクリプト&lt;/a&gt;
をAssets/Editorの中に置く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEditor;

public class Build {

    static void PerformBuild()
    {
        string[] scenes = { &amp;quot;Assets/main.unity&amp;quot; };
        BuildPipeline.BuildPlayer(scenes, &amp;quot;build&amp;quot;,
            BuildTarget.WSAPlayer, BuildOptions.None);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このstaticメソッドを&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/CommandLineArguments.html&#34;&gt;executeMethod&lt;/a&gt;
で渡してビルドする。Unityを開いたままだと失敗するので閉じる必要がある。&lt;/p&gt;

&lt;p&gt;この例だとbuildディレクトリに出力される。もし出力されなかったらEditorログを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity -quit -batchmode -executeMethod Build.PerformBuild
&amp;gt; type C:\Users\(username)\AppData\Local\Unity\Editor\Editor.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめたもの&#34;&gt;まとめたもの&lt;/h2&gt;

&lt;p&gt;ということでこんなバッチをUnityプロジェクトの直下に置いておくことにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:sambaiz/UnityBLE_UWP.git
cd UnityBLE_UWP
MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
cd ..
rmdir /S /Q UnityBLE_UWP

rmdir /S /Q build
Unity -quit -batchmode -executeMethod Build.PerformBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://sh-yoshida.hatenablog.com/entry/2017/05/27/012755&#34;&gt;MSBuildでコマンドラインからビルドする - 1.21 jigowatts&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>NorikraとFluentdで流れてきたログをリアルタイムに集計する</title>
          <link>http://sambaiz.net/article/109/</link>
          <pubDate>Sat, 10 Jun 2017 12:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/109/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://norikra.github.io/&#34;&gt;Norikra&lt;/a&gt;はTD社の&lt;a href=&#34;https://github.com/tagomoris&#34;&gt;tagomoris&lt;/a&gt;氏が作った、
スキーマレスのストリーミングデータを処理するOSS。&lt;/p&gt;

&lt;p&gt;モチベーションとしてはfluentdでElasticsearchにログを送って可視化していたのだけど、
流量が増えてきてピーク帯に耐えられなくなってしまったため、前もって集計してから送ることで流量を減らそうというもの。&lt;/p&gt;

&lt;h2 id=&#34;norikraを立ち上げてクエリを実行する&#34;&gt;Norikraを立ち上げてクエリを実行する&lt;/h2&gt;

&lt;p&gt;公式で紹介されているDockerイメージがあったのでこれで動かしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -e &amp;quot;TZ=Asia/Tokyo&amp;quot; -p 26578:26578 -p 26571:26571 -v `pwd`:/var/tmp/norikra:rw -d myfinder/docker-norikra norikra start --stats /var/tmp/norikra/stats.json -l /var/tmp/norikra 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公式サイトの例に従ってクライアントからデータを入れてクエリを実行してみる。&lt;/p&gt;

&lt;p&gt;まずはtargetをopenする。targetというのはスキーマレスのイベントストリームのこと。
ここで定義したフィールドは必須になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client target open www path:string status:integer referer:string agent:string userid:integer
$ norikra-client target list
TARGET	AUTO_FIELD
www	true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にクエリを追加する。一見普通のSQLのように見えるけど、Norikraのコアエンジンで使われているOSSの
&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E8%A4%87%E5%90%88%E3%82%A4%E3%83%99%E3%83%B3%E3%83%88%E5%87%A6%E7%90%86&#34;&gt;CEP&lt;/a&gt;
(Complex event processing)エンジン、
&lt;a href=&#34;http://www.espertech.com/products/esper.php&#34;&gt;Esper&lt;/a&gt;のクエリ、EPL(Event Processing Language)。
ただしSELECTしか使えないのも含めてクエリにいくらかの制限がある。&lt;/p&gt;

&lt;p&gt;このクエリでは&lt;code&gt;win:time_batch&lt;/code&gt;で10秒のWindowを定義し、eventをgroup byして、その数をeventとして出力する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client query add www.toppageviews &#39;SELECT count(*) AS cnt FROM www.win:time_batch(10 sec) WHERE path=&amp;quot;/&amp;quot; AND status=200&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eventを流す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/login&amp;quot;, &amp;quot;status&amp;quot;:301, &amp;quot;referer&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリの値をfetchする。送るのが遅くてgroup byされなかったけどこんな感じ。
eventがこなかったはじめのWindowは0が出力されるが、それ以降のWindowでは出力されない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ norikra-client event fetch www.toppageviews
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 20:58:13&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:42:33&amp;quot;,&amp;quot;cnt&amp;quot;:1}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:42:43&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:13&amp;quot;,&amp;quot;cnt&amp;quot;:1}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:23&amp;quot;,&amp;quot;cnt&amp;quot;:0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 21:43:33&amp;quot;,&amp;quot;cnt&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとWeb-uiが用意されていて、クエリを追加したり、targetやクエリの一覧、メモリの使用量やサーバーログなどが取得できる。デフォルトでは26578ポート。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/109-norikra.png&#34; alt=&#34;web-ui&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;クエリ-epl-http-norikra-github-io-query-html&#34;&gt;&lt;a href=&#34;http://norikra.github.io/query.html&#34;&gt;クエリ(EPL)&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;windowなし&#34;&gt;Windowなし&lt;/h3&gt;

&lt;p&gt;上の例では&lt;code&gt;time_batch&lt;/code&gt;でWindowを定義したけど、定義しないクエリを追加してみる。
以下のようなクエリを登録し、再びeventを流してfetchすると流した分が全てとれる。
ただし、このようなクエリはfetchされないと大量のoutput eventが溜まる可能性がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT path, status AS cnt FROM www WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-nowin
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 23:06:12&amp;quot;,&amp;quot;cnt&amp;quot;:200,&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/07 23:09:10&amp;quot;,&amp;quot;cnt&amp;quot;:200,&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-time-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-time-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-time-batch&#34;&gt;win:time_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10 sec&lt;/code&gt;のように秒以外にも&lt;code&gt;msec&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;hour&lt;/code&gt;、どう使うか想像できないけど&lt;code&gt;year&lt;/code&gt;まで指定でき、
&lt;code&gt;10 minutes 30 seconds&lt;/code&gt;みたいに組み合わせることも&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl_clauses.html#epl-syntax-time-periods&#34;&gt;できる&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;また、第二引数にミリ秒を渡すと出力するタイミングを指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT count(*) AS cnt FROM www.win:time_batch(1min, 0L) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-tb-opts
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 00:43:00&amp;quot;,&amp;quot;cnt&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-ext-timed-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-ext-time-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-ext-time-batch&#34;&gt;win:ext_timed_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;来た時間ではなくフィールドのUNIXミリ秒を参照するWindow。時系列順にソートされている必要があって、
tagomoris氏いわく&lt;a href=&#34;https://twitter.com/tagomoris/status/486851407140507648&#34;&gt;おすすめしない&lt;/a&gt;とのこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT count(*) AS cnt FROM www.win:ext_timed_batch(timestamp, 1 min) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3, &amp;quot;timestamp&amp;quot;:1496852100000 }&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3, &amp;quot;timestamp&amp;quot;:1496852200000 }&#39; | norikra-client event send www
$ norikra-client event fetch www.toppageviews-ext_timed
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 01:19:02&amp;quot;,&amp;quot;cnt&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-length-batch-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-length-batch&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-length-batch&#34;&gt;win:length_batch&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;event数のWindow。毎回渡した数ずつ集計できると思いきや、数が集まらなければfetchできず、
それ以上集まったらfetchできるようだ。使いづらいような気がする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT avg(userid) as nosense FROM www.win:length_batch(2) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat

$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat

$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:2}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-lenbat
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:42:20&amp;quot;,&amp;quot;nosense&amp;quot;:2.0}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;win-length-http-www-espertech-com-esper-release-5-2-0-esper-reference-html-epl-views-html-view-win-length&#34;&gt;&lt;a href=&#34;http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl-views.html#view-win-length&#34;&gt;win:length&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;こっちは渡した数スライドして集計するもの。Windowなしのときと同様、大量に溜まる可能性がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT avg(userid) as nosense FROM www.win:length(2) WHERE path=&amp;quot;/&amp;quot; AND status=200
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:3}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:1}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:5}&#39; | norikra-client event send www
$ echo &#39;{&amp;quot;path&amp;quot;:&amp;quot;/&amp;quot;, &amp;quot;status&amp;quot;:200, &amp;quot;referer&amp;quot;:&amp;quot;&amp;quot;, &amp;quot;agent&amp;quot;:&amp;quot;MSIE&amp;quot;, &amp;quot;userid&amp;quot;:4}&#39; | norikra-client event send www
$ norikra-client event fetch www.length-len
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:11&amp;quot;,&amp;quot;nosense&amp;quot;:3.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:22&amp;quot;,&amp;quot;nosense&amp;quot;:2.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:32&amp;quot;,&amp;quot;nosense&amp;quot;:3.0}
{&amp;quot;time&amp;quot;:&amp;quot;2017/06/08 20:58:45&amp;quot;,&amp;quot;nosense&amp;quot;:4.5}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもいろいろあるし、JOINやサブクエリも使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/111/&#34;&gt;NorikraでログをJOINする - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;fluentdとやり取りする&#34;&gt;fluentdとやり取りする&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/norikra/fluent-plugin-norikra&#34;&gt;fluent-plugin-norikra&lt;/a&gt;でNorikraサーバーにeventを送り、
eventを受け取ってファイルに出力する。&lt;/p&gt;

&lt;p&gt;c4.large(2コア,メモリ3.75GiB)でDockerでNorikraを立ち上げ、以下の設定でtd-agentを実行した。
&lt;code&gt;auto_field&lt;/code&gt;は来たeventのフィールドを自動でtargetに登録するかの設定で、
true(デフォルト)にするとどんなフィールドが来ているかNorikra上で確認することができる。
falseにしてもクエリで使う分は自動で登録される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type dummy
  dummy {&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;}
  tag event.dummy
  rate 1000
&amp;lt;/source&amp;gt;
   
&amp;lt;match event.*&amp;gt;
  @type   norikra
  norikra localhost:26571
  
  remove_tag_prefix event # event.*の部分が
  target_map_tag    yes   # targetになる

  &amp;lt;default&amp;gt;
    auto_field false 
  &amp;lt;/default&amp;gt;
&amp;lt;/match&amp;gt;

&amp;lt;source&amp;gt;
  @type   norikra
  norikra localhost:26571
  &amp;lt;fetch&amp;gt;
    method   event
    # norikra-client query add dummy_count_1sec &#39;SELECT COUNT(*) AS count FROM dummy.win:time_batch(1 sec)&#39;
    target   dummy_count_1sec
    tag      string data.dummy_count_1sec
 #  tag      field FIELDNAME : tag by value with specified field name in output event
    interval 1m
  &amp;lt;/fetch&amp;gt;
&amp;lt;/source&amp;gt;

&amp;lt;match data.*&amp;gt;
  @type file
  path /var/log/td-agent/dummy_count
  time_slice_format %Y%m%d%H
  time_slice_wait 10s
  time_format %Y%m%dT%H%M%S%z
  compress gzip
  symlink_path /var/log/td-agent/dummy_count
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Norikraのスループットは以下の要素が影響する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;number of targets
number of queries
how complex queries are
how complex UDFs are
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、目安としてはこんな感じらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 queries
2,000 events per seconds
5% usage of 4core CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1target、単純な1クエリなら秒間10000送ってみても問題なかった。
あまり現実的なケースではないけど限界を目指してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f dummy_count
20170609T212717+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212718+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212719+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212720+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212721+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212722+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212723+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212724+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212725+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
20170609T212726+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:10000}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 8256 root      20   0 1878m 249m  19m S 29.3  6.6   6:46.94 java
 9812 root      20   0  296m  68m 6288 S 20.0  1.8   2:38.08 ruby  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;秒間40000送ってみるとカウントがおかしい。
dummyの方の限界かと思ってnorikraを外してみたらおおよそ数が合ったので
Norikraサーバーかやり取りの部分で処理が追いついていないようだ。
一旦rateを下げてみたところ20000あたりを境目にこうなってしまった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail -f dummy_count
20170609T222018+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:31248}
20170609T222019+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:27468}
20170609T222020+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:35309}
20170609T222021+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:31944}
20170609T222022+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:22805}
20170609T222023+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:30716}
20170609T222024+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:33617}
20170609T222025+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:28740}
20170609T222026+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:32058}
20170609T222027+0900	data.dummy_count_1sec	{&amp;quot;count&amp;quot;:27253}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CPUの使用量をみてみると、ほぼ限界まで使用されていた。
fluentdはrubyの&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%97%E3%83%AA%E3%82%BF%E3%83%AD%E3%83%83%E3%82%AF&#34;&gt;GIL&lt;/a&gt;
(Global Interpreter Lock = GVL(Giant VM Lock))のため同時に&lt;a href=&#34;https://docs.ruby-lang.org/ja/2.3.0/doc/spec=2fthread.html&#34;&gt;1ネイティブスレッドしか動かせず&lt;/a&gt;、1コアしかCPUを使えないが、
jrubyで動くNorikraは残りのコアを使うことができる。
今回はtargetもクエリも一つだし、データ量も小さいためかメモリにはまだ余裕があった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
11378 root      20   0  350m 111m 6336 S 96.1  3.0   1:53.03 ruby
8256 root      20   0 1892m 642m  19m S 84.2 17.1  34:36.38 java   
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HEAP MEMORY USED: 244MB (55.8%), COMMITTED: 437MB, MAX: 437MBStorm
NON-HEAP MEMORY USED: 51MB (23.8%), COMMITTED: 81MB, MAX: 214MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1Gbps、1Mevent/sを超えるような高トラフィックではStormなどのフレームワークを使えとのこと。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdでKinesis streamsに送るときの性能確認</title>
          <link>http://sambaiz.net/article/108/</link>
          <pubDate>Mon, 05 Jun 2017 23:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/108/</guid>
          <description>

&lt;h2 id=&#34;localでのstreamsとproducerのbenchmark&#34;&gt;localでのstreamsとproducerのbenchmark&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;の
&lt;code&gt;make benchmark&lt;/code&gt;はlocalにDummyServerを&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis/blob/v1.1.3/benchmark/task.rake#L18&#34;&gt;立ち上げて&lt;/a&gt;送っている。&lt;/p&gt;

&lt;p&gt;空でもいいのでroleをつけておく必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/awslabs/aws-fluent-plugin-kinesis.git
$ cd aws-fluent-plugin-kinesis
$ yum install -y ruby-devel gcc
$ echo &#39;gem &amp;quot;io-console&amp;quot;&#39; &amp;gt;&amp;gt; Gemfile
$ make
$ make benchmark
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATEを指定しなければデフォルトで&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis/blob/v1.1.3/benchmark/task.rake#L19&#34;&gt;秒間1000レコード&lt;/a&gt;が送られる設定。
fluentdを起動してから10秒後にプロセスをkillし、そのレコード数などを出力している。&lt;/p&gt;

&lt;p&gt;t2.microでデフォルト(RATE=1000)で実行した結果がこれ。
固める分producerの方はややパフォーマンスが落ちる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 20, raw_records: 9400, records: 9400
bundle exec rake benchmark TYPE=producer
Results: requets: 14, raw_records: 1005, records: 8900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATE=3000のとき。producerではraw_recordsが1/100、リクエスト数は1/5。
streamsだとシャードを増やしていく必要があるけど、producerの方は当分大丈夫そうだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 57, raw_records: 27600, records: 27600
bundle exec rake benchmark TYPE=producer
Results: requets: 12, raw_records: 241, records: 25200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RATE=10000のとき。raw_records, requestの圧縮率はさらに上がり、
パフォーマンスの差が大きくなってきている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle exec rake benchmark TYPE=streams
Results: requets: 177, raw_records: 88000, records: 88000
bundle exec rake benchmark TYPE=producer
Results: requets: 26, raw_records: 385, records: 75000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実際にkinesis-streamsに送ってみる&#34;&gt;実際にkinesis streamsに送ってみる&lt;/h2&gt;

&lt;p&gt;ap-northeast-1でシャードは3のKinesis streamsにt2.microインスタンス1台から送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type dummy
  dummy {&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;}
  tag dummy
  rate 1000
&amp;lt;/source&amp;gt;

&amp;lt;source&amp;gt;
  @type monitor_agent
  bind 0.0.0.0
  port 24220
&amp;lt;/source&amp;gt;

&amp;lt;match **&amp;gt;
  @type kinesis_streams
  region ap-northeast-1
  stream_name test

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;秒間3000まではほとんどキューにたまらず送れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:24220/api/plugins.json | jq
{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 0,
      &amp;quot;buffer_total_queued_size&amp;quot;: 17500,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4000にするとそのうちretryが発生してしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
     &amp;quot;buffer_queue_length&amp;quot;: 60,
      &amp;quot;buffer_total_queued_size&amp;quot;: 56544178,
      &amp;quot;retry_count&amp;quot;: 5,
      &amp;quot;retry&amp;quot;: {
        &amp;quot;steps&amp;quot;: 5,
        &amp;quot;next_time&amp;quot;: &amp;quot;2017-06-05 14:05:38 +0000&amp;quot;
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;たしかにスループットが超過している。スペック通りだ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/108.png&#34; alt=&#34;書き込みスループットの超過&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に30シャードにしてみる。一度にシャード数は倍から半分にしかできないので作り直し。&lt;/p&gt;

&lt;p&gt;これに秒間30000を送ってみると、キューにいくらか溜まった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 7,
      &amp;quot;buffer_total_queued_size&amp;quot;: 7752600,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに倍にして60シャード。これに秒間60000で送ってみる。キューに溜まるものの増え続けはしないのでなんとか送れてそうだ。
td-agentのプロセスがCPUを99%使っているので、このインスタンスではこの辺が限界かもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 15,
      &amp;quot;buffer_total_queued_size&amp;quot;: 16105807,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ついでにus-east-1にも30シャードのStreamsを作成して30000送ってみたところ、キューに溜まる量が格段に増えた。
早くFirehoseやAnalyticsが東京リージョンにも来てほしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  ...
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3fc0dfac66a8&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;kinesis_streams&amp;quot;,
      ...
      &amp;quot;buffer_queue_length&amp;quot;: 50,
      &amp;quot;buffer_total_queued_size&amp;quot;: 52432436,
      &amp;quot;retry_count&amp;quot;: 0,
      &amp;quot;retry&amp;quot;: {}
  ]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>td-agent2.3.5のfluentdが0.14系になってしまっているのでソースからビルドする</title>
          <link>http://sambaiz.net/article/107/</link>
          <pubDate>Sun, 04 Jun 2017 23:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/107/</guid>
          <description>&lt;pre&gt;&lt;code&gt;$ curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent2.sh | sh
$ td-agent --version
td-agent 0.14.16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0.12系じゃない！？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum list installed | grep td-agent
td-agent.x86_64                       2.3.5-0.el2017               @treasuredata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どうやら2.3.5では0.14系になってしまっているよう。
そのあとにリリースされた2.3.5-1では直ってるみたいだけど、現時点ではrpmリポジトリに上がっていない。&lt;/p&gt;

&lt;p&gt;しょうがないのでソースからビルドすることにした。
いずれにせよ各環境で同じバージョンのビルドに合わせるべきだとは思う。
Beanstalk環境の場合、AMIに固めていたとしても非Beanstalk AMIではyum updateされてしまうので注意が必要だ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/106/&#34;&gt;BeanstalkでのパッケージのバージョンがAMIでのバージョンと異なる原因 - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前UbuntuでやったようにDockerでビルドする。今回はAmazon Linux向け。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/32/&#34;&gt;td-agentをビルドしてfluentdのバージョンを上げる - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/sambaiz/docker-td-agent-build-amazon-linux/&#34;&gt;https://hub.docker.com/r/sambaiz/docker-td-agent-build-amazon-linux/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM amazonlinux:2017.03

WORKDIR /tmp

RUN yum -y update &amp;amp;&amp;amp; \
    yum groupinstall -y &amp;quot;Development Tools&amp;quot; &amp;amp;&amp;amp; \
    yum install -y ruby23 ruby23-devel &amp;amp;&amp;amp; \
    gem install bundler io-console &amp;amp;&amp;amp; \
    git clone https://github.com/treasure-data/omnibus-td-agent

WORKDIR /tmp/omnibus-td-agent

RUN bundle install --binstubs &amp;amp;&amp;amp; \
    bin/gem_downloader core_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader plugin_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader ui_gems.rb &amp;amp;&amp;amp; \
    mkdir -p /opt/td-agent /var/cache/omnibus &amp;amp;&amp;amp; \
    bin/omnibus build td-agent2 &amp;amp;&amp;amp; \
    mv ./pkg/*.rpm /
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t amazon-linux-td-agent .
$ docker run --name altd -itd amazon-linux-td-agent sh
$ docker cp altd:/td-agent-2.3.5-1.el2017.x86_64.rpm .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはこれをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install -y redhat-lsb-core
$ rpm -ivh td-agent-2.3.5-1.el2017.x86_64.rpm 
$ td-agent --version
td-agent 0.12.36
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>BeanstalkでのパッケージのバージョンがAMIでのバージョンと異なる原因</title>
          <link>http://sambaiz.net/article/106/</link>
          <pubDate>Sun, 04 Jun 2017 23:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/106/</guid>
          <description>

&lt;h2 id=&#34;user-dataとは-http-docs-aws-amazon-com-ja-jp-awsec2-latest-userguide-user-data-html&#34;&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/user-data.html&#34;&gt;User-Dataとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;EC2インスタンス起動時に、シェルスクリプトを走らせたりcloud-initディレクティブを適用できる機能。
コンソールではインスタンスの詳細の設定の、高度な詳細のところから設定できる。&lt;/p&gt;

&lt;h2 id=&#34;beanstalkでのuser-data&#34;&gt;BeanstalkでのUser-Data&lt;/h2&gt;

&lt;p&gt;実はBeanstalkでも使われていて、CloudFormationで設定されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;    /bin/bash /tmp/ebbootstrap.sh &amp;quot;,

...

&amp;quot;Fn::FindInMap&amp;quot;: [
    &amp;quot;AWSEBOptions&amp;quot;,
    &amp;quot;options&amp;quot;,
    &amp;quot;UserDataScript&amp;quot;
]
&amp;quot; &amp;gt; /tmp/ebbootstrap.sh &amp;quot;,

...

&amp;quot;AWSEBOptions&amp;quot;: {
    &amp;quot;options&amp;quot;: {
        &amp;quot;UserDataScript&amp;quot;: &amp;quot;https://s3-ap-northeast-1.amazonaws.com/elasticbeanstalk-env-resources-ap-northeast-1/stalks/eb_node_js_4.0.1.90.2/lib/UserDataScript.sh&amp;quot;,
        &amp;quot;guid&amp;quot;: &amp;quot;f08557fc43ac&amp;quot;,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このshellの中では、時計を同期させたり、awsebユーザーを作成したりするほかに、
非Beanstalk AMI(is_baked=false)ではyum updateが走るようになっている。
そのため、AMIでのバージョンとBeanstalkで立ち上がったときのバージョンが異なることがある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GUID=$7

function update_yum_packages
{
  if is_baked update_yum_packages_$GUID; then
    log yum update has already been done.
  else
    log Updating yum packages.
    yum --exclude=aws-cfn-bootstrap update -y || echo Warning: cannot update yum packages. Continue...
    mark_installed update_yum_packages_$GUID

    # Update system-release RPM package will reset the .repo files
    # Update the mirror list again after yum update
    update_mirror_list

    log Completed updating yum packages. 
  fi
}

function is_baked
{
	if [[ -f /etc/elasticbeanstalk/baking_manifest/$1 ]]; then
    true
	else
    false
	fi
}

function mark_installed
{
    mkdir -p /etc/elasticbeanstalk/baking_manifest/
    echo `date -u` &amp;gt; /etc/elasticbeanstalk/baking_manifest/$1-manifest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Beanstalk AMIでのログ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /var/log/messages | grep yum
[eb-cfn-init]: yum repo has already been locked to f08557fc43ac.
[eb-cfn-init]: yum update has already been done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非Beanstalk AMIでのログ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /var/log/messages | grep yum
[eb-cfn-init]: Completed yum repo version locking.
[eb-cfn-init]: Updating yum packages.
yum[1597]: Updated: *****
...
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unity/UWPでBLEを扱うプラグインを作る</title>
          <link>http://sambaiz.net/article/105/</link>
          <pubDate>Sun, 04 Jun 2017 11:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/105/</guid>
          <description>&lt;p&gt;コードは&lt;a href=&#34;https://github.com/sambaiz/UnityBLE_UWP&#34;&gt;ここ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/aonishi/2013/12/04/unity-on-windows-8-1/&#34;&gt;この動画&lt;/a&gt;の
50:00あたりから説明があるように、
ビルドされたWSAが読むUWPのdllのほかに、
Unityエディタ上から読むための.NET Framework3.5のdllを用意する。
こうすることで実行環境ごとの違いをUnityコード上で気にしなくてもよくなる。&lt;/p&gt;

&lt;p&gt;新しいプロジェクトで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Visual C# から.NET Framework 3.5にしてクラスライブラリ(.NET Framework)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visual C# -&amp;gt;　Windows -&amp;gt; ユニバーサルからクラスライブラリ(ユニバーサルWindows)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのプロジェクトを同じソリューションに作成する。
VS2017で.NET Frameworkのクラスライブラリプロジェクトを作成するためには
Visual Studio Installerで.NET Coreのワークロードをインストールする必要がある。
また、これとは別に動作確認用のUWPアプリケーションプロジェクトを作成した。&lt;/p&gt;

&lt;p&gt;UWPの方のプロジェクトにあるClass1.csを削除し、追加 -&amp;gt; 既存の項目から、
もう片方のClass1.csをリンクとして追加して、この共通のcsにUWPのコードを書いていくんだけど、
そのまま書くと当然.NET Frameworkの方でビルドできないので
実装部分を&lt;a href=&#34;https://docs.unity3d.com/Manual/PlatformDependentCompilation.html&#34;&gt;#if WINDOWS_UWP ~ #endif&lt;/a&gt;
で囲む。UWPの方のプロジェクトにはプロパティ -&amp;gt; ビルドの条件付きコンパイルにWINDOWS_UWPが含まれているので有効になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void Start()
{
#if WINDOWS_UWP
    ...
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UWPでBLEを扱うのは前書いた通り。
ただし、なぜかXAMLに依存しているようでD3Dビルドすると失敗する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/101&#34;&gt;UWPでBLEデバイスとペアリングして値を取得する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ビルドするとdllができるので.NET Frameworkの方をAssets/Pluginsに置いてInspectorからEditorにだけチェックを入れる。
UWPの方は&lt;a href=&#34;https://docs.unity3d.com/Manual/PluginInspector.html&#34;&gt;Assets/Plugins/WSA&lt;/a&gt;に置くとWSA Playerにだけチェックが入る。&lt;/p&gt;

&lt;p&gt;あとは普通にusingして使うだけ。Bluetoothのcapabilityを有効にするのを忘れずに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityBLE;
  
public class BLE : MonoBehaviour {

    string value = &amp;quot;no connection&amp;quot;;

    public GameObject text;

    private string serviceUUID = &amp;quot;***&amp;quot;;
    private string characteristicUUID = &amp;quot;***&amp;quot;;

    void Start() {
        var ble = new UnityBLE.BLE();
        ble.DeviceAdded += (sender, obj) =&amp;gt; {
            value = &amp;quot;DeviceID: &amp;quot; + obj.DeviceID;
            ble.Listen(obj.DeviceID, serviceUUID, characteristicUUID);
            ble.Stop();
        };
        ble.CharacteristicReceived += (sender, obj) =&amp;gt;
        {
            if (sender == ble)
            {
                if (obj.ex == null)
                {
                    value = Encoding.UTF8.GetString(obj.Value);
                }
                else
                {
                    value = obj.ex.Message;
                }
            }
        };
        ble.Start();
    }

    void Update() {
        text.GetComponent&amp;lt;TextMesh&amp;gt;().text = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Golangの高速なロガーzapとlumberjackでログを出力してrotateさせる</title>
          <link>http://sambaiz.net/article/104/</link>
          <pubDate>Sat, 27 May 2017 16:35:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/104/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap&#34;&gt;https://github.com/uber-go/zap&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u go.uber.org/zap
$ go get -u gopkg.in/natefinch/lumberjack.v2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;速さの秘訣&#34;&gt;速さの秘訣&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://techblog.ca-reward.co.jp/2016/06/post-33.html&#34;&gt;Go言語のLogger「zap」は何故高速に構造化されたログを出力する事が出来るのか｜株式会社CAリワード&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;reflectionとallocationの回避。&lt;/p&gt;

&lt;p&gt;一度allocateしたBufferやEncoderは
&lt;a href=&#34;https://golang.org/pkg/sync/#Pool&#34;&gt;sync.Pool&lt;/a&gt;で使い回している。
このPoolはまさにallocateされたアイテムを再利用するためのもので、GCの負担を緩和させることができる。
Poolのアイテムは勝手に削除されることがあり、もし参照しか持っていなかったらそのままdeallocateされる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap/blob/v1.4.0/buffer/pool.go#L34&#34;&gt;https://github.com/uber-go/zap/blob/v1.4.0/buffer/pool.go#L34&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewPool() Pool {
	return Pool{p: &amp;amp;sync.Pool{
		New: func() interface{} {
			return &amp;amp;Buffer{bs: make([]byte, 0, _size)}
		},
	}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;現状ドキュメントが乏しいのでコードから探っていく必要がある。
まずはQuick Startから。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zap.NewProduction()&lt;/code&gt;は&lt;code&gt;NewProductionConfig().Build(options...)&lt;/code&gt;の&lt;a href=&#34;https://github.com/uber-go/zap/blob/master/logger.go#L87&#34;&gt;ショートカット&lt;/a&gt;。
ConfigをBuildしてLoggerを取得し、InfoやErrorで書く流れ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logger, _ := zap.NewProduction()
defer logger.Sync()
logger.Info(&amp;quot;Hoge&amp;quot;,
  // Structured context as strongly-typed Field values.
  zap.Int(&amp;quot;attempt&amp;quot;, 3),
  zap.Duration(&amp;quot;backoff&amp;quot;, time.Second),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;ts&amp;quot;:1495870212.3378785,&amp;quot;caller&amp;quot;:&amp;quot;zap-log/main.go:36&amp;quot;,&amp;quot;msg&amp;quot;:&amp;quot;Hoge&amp;quot;,&amp;quot;attempt&amp;quot;:3,&amp;quot;backoff&amp;quot;:1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewProductionConfig()&lt;/code&gt;の内容はこんな感じ。ここからOutputPathを書き換えるとファイルに出力されるようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config := zap.Config{
    Level:       zap.NewAtomicLevelAt(zap.ErrorLevel),
    Development: false,
    Sampling: &amp;amp;zap.SamplingConfig{
        Initial:    100,
        Thereafter: 100,
    },
    Encoding: &amp;quot;json&amp;quot;,
    EncoderConfig: zapcore.EncoderConfig{
        TimeKey:        &amp;quot;ts&amp;quot;,
        LevelKey:       &amp;quot;level&amp;quot;,
        NameKey:        &amp;quot;logger&amp;quot;,
        CallerKey:      &amp;quot;caller&amp;quot;,
        MessageKey:     &amp;quot;msg&amp;quot;,
        StacktraceKey:  &amp;quot;stacktrace&amp;quot;,
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    zapcore.LowercaseLevelEncoder,
        EncodeTime:     zapcore.EpochTimeEncoder,
        EncodeDuration: zapcore.SecondsDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
    },
    OutputPaths:      []string{&amp;quot;stderr&amp;quot;},
    ErrorOutputPaths: []string{&amp;quot;stderr&amp;quot;},
}
config.OutputPaths = []string{&amp;quot;./aaaa.log&amp;quot;}
logger, _ = config.Build()
defer logger.Sync()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Buildの引数にも渡せるOptionというのは&lt;code&gt;apply(logger)&lt;/code&gt;でloggerを操作するインタフェース。
&lt;a href=&#34;https://github.com/uber-go/zap/blob/74ca5ef91c08e5eafb5ab9739df05d66f1b5d8da/options.go#L55&#34;&gt;zap.Fields&lt;/a&gt;は
フィールドを追加するもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logger = logger.WithOptions(zap.Fields(zap.String(&amp;quot;hoge&amp;quot;, &amp;quot;fuga&amp;quot;)))
defer logger.Sync()
logger.Error(&amp;quot;aaa&amp;quot;,
    zap.String(&amp;quot;eee&amp;quot;, &amp;quot;eee&amp;quot;),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap/blob/v1.4.0/config.go#L154&#34;&gt;Build&lt;/a&gt;の実装をみると、
中では&lt;code&gt;zapcore.NewCore(enc, sink, cfg.Level)&lt;/code&gt;とOptionを引数として取る&lt;code&gt;New()&lt;/code&gt;でloggerを生成している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enc, err := cfg.buildEncoder()
if err != nil {
    return nil, err
}

sink, errSink, err := cfg.openSinks()
if err != nil {
    return nil, err
}

log := New(
    zapcore.NewCore(enc, sink, cfg.Level),
    cfg.buildOptions(errSink)...,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このsinkは&lt;code&gt;io.Writer&lt;/code&gt;をwrapした&lt;a href=&#34;https://github.com/uber-go/zap/blob/179e456766f6ba6d1006f432f90d52ecb6296e84/zapcore/write_syncer.go#L32&#34;&gt;WriteSyncer&lt;/a&gt;
で、&lt;code&gt;AddSync(w io.Writer)&lt;/code&gt;で変換できる。
これに&lt;a href=&#34;https://github.com/natefinch/lumberjack&#34;&gt;lumberjack&lt;/a&gt;を渡してやるとrotateできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config := zap.NewProductionConfig()
enc := zapcore.NewJSONEncoder(config.EncoderConfig)
sink := zapcore.AddSync(
    &amp;amp;lumberjack.Logger{
        Filename:   &amp;quot;./aaaa.log&amp;quot;,
        MaxSize:    500, // megabytes
        MaxBackups: 3,
        MaxAge:     28, //days
    },
)
logger := zap.New(
    zapcore.NewCore(enc, sink, config.Level),
)
defer logger.Sync()
logger.Error(&amp;quot;aaa&amp;quot;,
    zap.String(&amp;quot;eeef&amp;quot;, &amp;quot;eefe&amp;quot;),
)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>夜のNY郊外を無一文で彷徨い、Google I/OとMaker Faire Bay Areaに行ってきた</title>
          <link>http://sambaiz.net/article/103/</link>
          <pubDate>Mon, 22 May 2017 23:44:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/103/</guid>
          <description>

&lt;p&gt;Googleが毎年やっているイベント、Google I/Oのチケットが当たったのでアメリカに行ってきた。
海外に行くのはこれが3回目でアメリカははじめて。一人での海外もはじめて。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;p&gt;チケットが当たってからExpediaで航空券やホテルを取った。航空券の流れで保険にも加入した。
アメリカの医療費は相当高いそうなので何かしらの保険に入っておかないと不安だ。&lt;/p&gt;

&lt;p&gt;会期中は会場近辺のサンフランシスコ/マウンテンビューのホテルがとんでもなく値上がりしている模様。
多分通常の倍ぐらいにはなっているので早めに取っておくとよいと思われる。&lt;/p&gt;

&lt;p&gt;GoogleI/Oは週末にかけての3日間だったので、その前の週末から出発し、前半はニューヨークに行くことにして、
マンハッタンに宿を取った。&lt;/p&gt;

&lt;p&gt;アメリカに入国するのには&lt;a href=&#34;https://esta.cbp.dhs.gov/esta/application.html&#34;&gt;ESTA&lt;/a&gt;を申請する必要がある。
申請自体は72時間以内に通るのだけど、パスポート番号が必要がなので持っていなければ先に作っておく必要がある。
ESTAが通っていないと本当に入れないらしい。怖い。&lt;/p&gt;

&lt;p&gt;現地での通信手段はT-mobileの&lt;a href=&#34;https://prepaid-phones.t-mobile.com/prepaid-international-tourist-plan&#34;&gt;Tourist plan&lt;/a&gt;($30プリペイドでSIM+2GB LTE+国内通話+SMS)
を購入することにした。
日本にはsimを送ってくれないので現地で調達する必要がある。モバイルルータはちょっと高いような気がして借りなかった。&lt;/p&gt;

&lt;p&gt;あとは英語力をなんとかしようと付け焼刃でDMM英会話をはじめてみたが、準備期間が短すぎたかなと思う。&lt;/p&gt;

&lt;h2 id=&#34;出国&#34;&gt;出国&lt;/h2&gt;

&lt;p&gt;チェックインの締め切りが出発の1時間前だったので、
余裕を持って2時間前ぐらいには着くはずだったんだけど、こんなときに限って財布を落とすわ成田エクスプレスは突然運休するわで大ピンチ。
日暮里から京急のスカイライナーに乗ってスーツケースをかついで走ってなんとか飛行機には間に合ったが、
両替などする時間はなく、財布に1000円しか入っていない状態で出発することになってしまった。&lt;/p&gt;

&lt;p&gt;距離にして11000km、12時間のフライトの末、ニューヨークのジョン・F・ケネディ国際空港(JFK)に到着。
時差で-13時間になるため出発よりも早い時刻に到着することになって得した気分だ。
ついにアメリカに来た。&lt;/p&gt;

&lt;h2 id=&#34;ニューヨーク&#34;&gt;ニューヨーク&lt;/h2&gt;

&lt;p&gt;当初はニューヨーク観光しつつ、アムトラック(電車)でワシントンD.C.にも行っちゃおうかと考えてチケットまで買っていた。
しかし現実は厳しい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;現地に到着し、通信手段を調達するためT-mobileのショップに向かおうとしたが、肝心のショップの場所がわからない。
もちろん日本のsimカードはすでに機能停止しているので空港のWifiで調べたところ、そこから一番近いところでも数km離れていることがわかった。
タイムズスクエアの近くにはあるようだったので、まずはなんとかしてホテルに向かうことにしたが、
JFKからマンハッタンまでは直線距離で20km以上離れている。ホテルの送迎サービスはなかった。
それでもGoogle mapに従って、途中free wifiを乗り継いでいけばこのときはなんとかなるかなと思っていた。&lt;/p&gt;

&lt;p&gt;空港から電車で行こうと思っていたところ、うかつにも謎タクシーに誘導されて乗ってしまった。
47ドルでホテルまで行ってくれると思いきや、それはJamaica駅までの料金で、ホテルまでは100ドルという。調べていた相場の倍だ。
傷口を広げないようJamaicaで降ろしてもらうことにした。
乗る前に現金はないからクレジットカードで払う旨を伝えたのだけど、
支払いの段になってクレジットカードの機械が壊れたから現金でと言い出して困った。なにせ1ドルも持っていないのだから。
近くのATMで現金を下ろすよう言われたのでクレジットカードを入れたのだけれど
2枚ともアウト。そこからどうやって払うんだって問いつめられるもののどうしようもない。
結局解放してもらえたが、初っ端からほとんど心が折れてしまって国に帰りたかった。&lt;/p&gt;

&lt;p&gt;それでもなんとかしてホテルにはたどり着かなくてはならないので、LIRRという電車でJamaicaからWoodside駅に向かった。
空港で調べたGoogle mapの経路に出たからそうしたのだけど、
マンハッタンにあるハブ駅、Pensilvania(Penn) stationまで行くほうが行き先表示に出ているので分かりやすかった。
改札はなくて切符は車内で確認される。&lt;/p&gt;

&lt;p&gt;案内の人に聞いて電車に乗ったんだけど、切符の確認の際にこの電車ではないと言われる。
乗り間違えると、引き返すためにホームで割と長く待つことになる。5月も半ばなのに白い息が出るぐらい寒い。
Googleで調べようにも、駅にあるWifiはどうも契約していないと使えなさそうなものしかなかった。
地下鉄にはfree wifiが通っていたが、それも全ての駅で使えるというわけではなさそうだった。&lt;/p&gt;

&lt;p&gt;Woodsideからは地下鉄に乗るのだけれど、この券売機がなぜかクレジットカードのPINをうけつけてくれずチケットを買えなかった。
カードが止まったかと思い、しょうがないので6kmほど歩いてマンハッタンまで向かうことにした。雨が降っていて、寒くて泣きたくなった。
空港でマップのデータを読んでいたのでGPSと合わせればオフラインでも自分の位置はわかるのが唯一の救いだ。
電話もなかったので、道中あったスタバなどのfree wifiを外から使わせてもらって、
家族に連絡をとって日本からクレジットカード会社に問い合わせてもらったが、
本人からの連絡じゃないとだめとのことでどうしようもなかった。&lt;/p&gt;

&lt;p&gt;マンハッタンに行くためにはイースト川を越える必要があったので、
地図上で橋になっているところを順番に見てまわったが、車や電車でないとだめなところばかりで暗雲がただこめる。
あとから調べたら、マンハッタンの南側、ブルックリンとマンハッタン橋は歩いて渡れたらしい。
あの向こうがマンハッタンなのになと沿岸を眺めながら、この時点で夜中の0時を回っていて、野宿の可能性を考え始める。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-manhattan.jpg&#34; alt=&#34;マンハッタンを眺める&#34; /&gt;&lt;/p&gt;

&lt;p&gt;途方に暮れて彷徨っていたところ、歩いていたおじさんとたまたま目が合って、
お金がなくて電車には乗れないんだけど、徒歩でマンハッタンに渡る方法はあるか聞いたら、
なんと地下鉄の駅まで案内してくれて運賃を出してくれた。
お礼するために連絡先を聞こうとしたのにすぐいなくなってしまわれた。命の恩人だ。&lt;/p&gt;

&lt;p&gt;なんとかホテルに到着し、電話を借りてカード会社に連絡したところ、
カードは普通に使える状態で電車の明細はこちらには届いていない、キャッシングは枠がないからできない、
というまさかの事実が発覚した。
カードが使えるとはいえ現金がないと困ることが分かったので、キャッシング枠の審査を急いでもらうよう頼んでみた。&lt;/p&gt;

&lt;p&gt;もはや遠出する気が全くなくなったのでアムトラックのチケットをキャンセルしようと思ったら、システムメンテナンスでできずに諦める。
雨の中歩き回ったのでスーツケースの中の服はほとんどびしょ濡れだった。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;次の日は昼をまわったころ目覚めて、だらだらして風呂に入ってT-mobileのショップに向かってsimを購入。
設定は向こうの人がやってくれるので、言語を英語にしておくとスムーズだ。
念願の通信手段を得て、Google mapがいつでも使えるようになった。つまり無敵。
とはいえ、いまだ現金がないのでマンハッタンの中で過ごすことにした。&lt;/p&gt;

&lt;p&gt;マンハッタンは高いビルが多く、GPSが大きくずれる。縦横のStreetとAvenueに番号が振られているのでそれに従うと動きやすかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-stav.jpg&#34; alt=&#34;StreetとAvenueの表示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Shake Shackのハンバーガーを食べて、チェルシーマーケットでロブスターを食べた。これでもsmall。
身はぎっしり入っていてレモンをかけて食べるとおいしい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-bigebi.jpg&#34; alt=&#34;チェルシーマーケットのロブスター&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それと、なぜかカードが使えなかった地下鉄に再チャレンジしてみた。
問題になったのはこういう券売機。クレジットカードを抜き差し(dip)してPINを入力する。やっぱり買えない。
いろいろ試して見たところPINを入力せずにENTERだけ押したら買えることがわかった。意味わからん・・・。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ny-subway-machine.jpg&#34; alt=&#34;NYの地下鉄の券売機&#34; /&gt;&lt;/p&gt;

&lt;p&gt;夜にキャッシングができるようになったのでタクシードライバーに連絡をとって代金を支払って2日目も終わり。
3日目は空港に向かう日なので、これがNY滞在の全て。次来るときはもう少しなんとかしたい。&lt;/p&gt;

&lt;p&gt;到着はJFKだったけど、出発はニューアーク・リバティー空港(EWR)からで、Penn stationからNJ TRANSIT(電車)一本で行ける。
Penn stationは上にも書いたとおりハブ駅で、アムトラック、LIRR、NJ TRANSITの駅が入っている。
ワシントンD.C.に行くときもこの駅から出るはずだった。
最初、画面にTrack(ホーム)が書いてなくてちょっと焦ったが、STATUSがBOARDINGになると表示される。&lt;/p&gt;

&lt;p&gt;EWRの飲食店にはタブレットが置いてあって、そこで注文しカードを通すと注文される。現金は使えない。
最初にboarding passのバーコードをかざすと乗る便の情報が表示されるので乗り遅れる心配がない。乗り遅れるどころか2時間遅延してたけど。
終わったらtabをcloseする。チップの割合も選択できるようになっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ewr.jpg&#34; alt=&#34;EWRの飲食店のタブレット&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここから西海岸、サンフランシスコへ。
国内ながら3時間の時差があって、6時間のフライトなのに3時間しか進まない。&lt;/p&gt;

&lt;h2 id=&#34;googlei-o&#34;&gt;GoogleI/O&lt;/h2&gt;

&lt;p&gt;I/Oに参加する同僚2人と合流した。一人でないのは心強い限りだ。&lt;/p&gt;

&lt;p&gt;GoogleI/O自体は3日間なのだけれど、前日に登録ができ、先着順でKeynoteの前の方の席が割り当てられる。
今年の会場は去年と同じマウンテンビューのShoreline Amphitheatreというところで、Googleの近くにある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-shoreline.jpg&#34; alt=&#34;Shoreline Amphitheatre&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サンフランシスコからもサンノゼからもそれなりに離れていて、最寄りの電車の駅も少し離れているので、バスか車で来ることになると思う。
同僚がレンタカーを借りてくれていたのでそれで向かったが、フリーウェイの、特に出口が渋滞して結構時間がかかる。
駐車場が一杯なのではないか心配していたけど、普通の駐車場の他に滅茶苦茶広いオーバーフロー駐車場があるので問題なかった。
どこまで駐車場なのかわからないぐらい広い。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-parking.jpg&#34; alt=&#34;オーバーフロー駐車場&#34; /&gt;&lt;/p&gt;

&lt;p&gt;受付を済ませると首からかけるバッジと、水筒、日焼け止め、Tシャツ、サングラスがもらえた。
会場は基本屋外なのでかなり実用的なセットだ。一方夜は相当寒いので上着を持っていったほうがよい。
バッジはNFCタグになっていて、セッション予約の確認に使われる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-ioset.jpg&#34; alt=&#34;もらったもの&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ついでに近くのGoogleも見にいってきた。ショップがある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-google.jpg&#34; alt=&#34;Google&#34; /&gt;&lt;/p&gt;

&lt;p&gt;その後サンフランシスコ市内の北、フィッシャーマンズワーフのBOUDINという店でパンの器のクラムチャウダーを食べた。
おいしかった。海の方を眺めるとアルカトラズが見える。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-boudin.jpg&#34; alt=&#34;クラムチャウダー&#34; /&gt;&lt;/p&gt;

&lt;p&gt;夜はIntel&amp;rsquo;s Google I/O Day Zero Partyという非公式の前夜祭みたいなのに行ってきた。
I/Oに比べると規模はそんなに大きくはないけど、それでも多くの人が集まっていて、日本勢にも出会った。
飲み放題食べ放題で、IntelやGoogleのテクノロジーに絡んだデモが行われている。
体験したりしてトークンを集めることで賞品と交換でき、アンドロイドのTシャツをもらった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-zero-day.jpg&#34; alt=&#34;アンドロイドのTシャツ&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Keynoteは一番広いアンフィシアターで行われ、内側の椅子エリアと外側の芝のエリアがある。
遅れてしまったため芝エリアしか入れなくて午前中はそこで聞くことしたら、暑いけど寝転がりながら聞くことができるので案外悪くなかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-keynote.jpg&#34; alt=&#34;芝席&#34; /&gt;&lt;/p&gt;

&lt;p&gt;食事は指定の場所で配られているので取っていって適当な場所で食べる。
朝食も含めて食事や飲み物やお菓子は全て提供されるが、朝食は数がそんなに多くないのか、遅い時間に行くとなくなっていることがあった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-food.jpg&#34; alt=&#34;食事のリスト&#34; /&gt;&lt;/p&gt;

&lt;p&gt;午後のDeveloper Keynoteでは主な新機能などがざっくり発表されて、What&amp;rsquo;s newなどのセッションではそれが詳細に説明されたりする形になっている。&lt;/p&gt;

&lt;p&gt;Androidは、GooglePlay Protectや、地味に長いブート時間が2倍速くなったりするAndroid Oが発表された。あと、嬉しそうにもう一つあるよって言い出して
何かなと思ったらKotlin公式サポート。Android勢歓喜。よかったね。&lt;/p&gt;

&lt;p&gt;Daydream(VR)はスマホ不要のStandaloneヘッドセットと、位置トラッキングのWorldSense。
Tango(AR)はGPSに対して、室内で位置を知ることができるVPS(Visual Positioning Service)というのが発表されていた。これを使うと店内でナビできるすごく便利そうなやつだ。
VR/ARは教育分野、&lt;a href=&#34;https://edu.google.com/expeditions/&#34;&gt;Google Expeditions&lt;/a&gt;でも使われているらしい。
ARで教室に火山や竜巻を出したりできる。後のセッションで言っていたのは、どこにでもVRで行って何でもARで見れるだったかな。&lt;/p&gt;

&lt;p&gt;あとはGoogle photoのサジェスト機能や、なんかすごいGoogle lensなどなど。
Keynoteを通して、Googleっていろんなことをやっていて、世界が便利になるイメージが湧いた。&lt;/p&gt;

&lt;p&gt;最後に突然のGoogle Home+GCPクレジット配布の発表。うれしい。
日本での発売も発表されたが、一足早く手に入れることができた。何か作ってみたい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-home.jpg&#34; alt=&#34;Google Home&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Keynoteが終わると並行してセッション、展示やオフィスアワーなどが行われる。
セッションは1時間区切りになっていて、移動の時間が用意されていないように見えるが、
実際は30~40分ほどで終わるので一杯に入れても問題はない。
ただ、一日中ずっとセッションを聞いているというのも疲れるので、
割とみんなその辺りにある椅子や芝生に座ったり寝転がったりしてPCを開いてたり、歓談してたりする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-relax.jpg&#34; alt=&#34;会場風景&#34; /&gt;&lt;/p&gt;

&lt;p&gt;セッションはAR(Tango)/VR(Daydream)、Firebase、Android Thingsなどいろいろな種類のを聞きにいった。
全てのセッションはライブストリーミングされているので日本でも聞けるけど、
現地だと会場の雰囲気を楽しめるのはもちろん、しなかったけどセッションの後やオフィスアワーで質問したりすることができる。
次来るときは質問できるぐらい使い込んでいきたい。&lt;/p&gt;

&lt;p&gt;Firebaseもいくつか機能追加があって、そのうちの一つがPhone number auth。早速ためしてみた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/102/&#34;&gt;io17で発表されたFirebaseのphone number authをwebで試してみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AndroidThingsはIoTのためのOS。
Androidのエコシステムに乗れることと、プロトタイプから本番までのスケーリングしやすさ、セキュリティが特長として挙げられていた。
せっかくなのでcodelabsで触ってきた。codelabsでは、Googleのテクノロジーのチュートリアルのコースを質問しながら進められる。
Android端末など必要な機材は用意されているので、それらを持っていなくても問題ない。IoTはなかなかの人気コンテンツで2時間待つことになった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-codelabs.jpg&#34; alt=&#34;IOT codelab&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コースを最後まで終えるとAndroid Things対応のハードウェアセットがもらえた。
codelabsはwebに&lt;a href=&#34;https://codelabs.developers.google.com/io2017&#34;&gt;公開されている&lt;/a&gt;ので家でも試すことができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-iot-omiyage.jpg&#34; alt=&#34;IOTおみやげ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;1,2日目のセッションが終わるとAfter Hourというパーティーがある。
朝から夜まで楽しめる、とても良いイベントだった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-party.jpg&#34; alt=&#34;After Hour&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;maker-faire-bay-area&#34;&gt;Maker Faire Bay Area&lt;/h2&gt;

&lt;p&gt;Google I/Oが終わった翌日、同僚を空港で見送ってSan mateoで行われるMaker Faire Bay Areaにいってきた。&lt;/p&gt;

&lt;p&gt;Maker Faireは、ものづくりが好きな人たちが集まり、作ったものを展示発表したり体験したりするお祭り。
このBay Areaからはじまり、世界中に広がっている。
東京でも行われているんだけど、行ったことがないためこれが初参加。&lt;/p&gt;

&lt;p&gt;空港から会場のSan Mateo Event Centerまではバス(SamTrans)で向かった。
運賃は現金で払うこともできるけど、Clipperという日本のSuicaみたいなやつがあると便利。空港のInformationで買えた。
バスの運賃は2ドルちょっと。&lt;/p&gt;

&lt;p&gt;バス停は柱の上の方にある行き先が書いてある札が目印。待合所があるところもあれば、ただの柱にくっついているところもあってちょっと気づきにくい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-busstop.jpg&#34; alt=&#34;バス停&#34; /&gt;&lt;/p&gt;

&lt;p&gt;乗ったらClipperをピッとやって席に座り、降りたければ黄色い紐を引くとSTOP REQUESTEDされる。
バス停に近づいても特にアナウンスなく通過してしまうのでGPSの位置を注意して見ていた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-stop-requested.jpg&#34; alt=&#34;STOP REUESTEDの紐&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;会場はとても広い。何も考えずにうろうろしていたのだけど、あとでマップを見返したら、見てない場所とかがあったりしたので、最初にマップで行く場所に目星をつけておいたほうがよいと思う。
展示のジャンルごとにテントがあって、ほかにはアクティビティやステージ、食べ物の屋台、体験コーナーなどがある。
屋台は基本現金払いだけど、ATMが会場内にもある。
子供連れもたくさんいて、大人子供ともに楽しめるイベントになっていた。&lt;/p&gt;

&lt;p&gt;展示物は、子供が作ったものから、こんなの個人で作れるのかというようなものまで、ジャンルも電子工作からガーデニングまでいろいろ。
日本から出している人もいて、ロボットのところにデイリーポータルZや個人のブースがいくつかあった。&lt;/p&gt;

&lt;p&gt;すごい勢いで燃えながら回転する球。日本だと消防法的にまずそう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-burning.jpg&#34; alt=&#34;燃える球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自転車をこいで電力を賄うステージ。ステージもいくつかあって、他では化学の実験をやっていた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-you-are-the-power.jpg&#34; alt=&#34;YOU ARE THE POWER!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アクティビティをやるには自己責任的な誓約書にサインしてリストバンドをもらう必要がある。
これは音楽に合わせて対応するところを踏んだり引いたりするゲーム。アクションは5つしかないんだけど、なかなか難しかった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-make-act.jpg&#34; alt=&#34;音ゲー&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ドローンレースをやっているテントもあった。モニターにはドローン視点の映像が流れていて迫力がある。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-drone.jpg&#34; alt=&#34;ドローンレース&#34; /&gt;&lt;/p&gt;

&lt;p&gt;R2D2がいた。もちろん動く。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/104-r2d2.jpg&#34; alt=&#34;R2D2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;せっかくAndroid Thingsのハードウェアも手に入ったことだし、何か作って出展してみたい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これでアメリカでの予定も終わり。
9日間ながら内容が濃い滞在だった。また行きたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>io17で発表されたFirebaseのphone number authをwebで試してみた</title>
          <link>http://sambaiz.net/article/102/</link>
          <pubDate>Wed, 17 May 2017 23:34:00 -0700</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/102/</guid>
          <description>&lt;p&gt;今日のdeveloper keynoteで発表されたphone number authを試してみた。
Firebaseだと他にはPerformance Monitoringも発表されている。
あとSDKをオープンソースにするとか。&lt;/p&gt;

&lt;p&gt;firebase-toolsを最新版にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# npm install -g firebase-tools
$ firebase -V
3.9.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FirebaseUIを使う場合、これも最新版にしないと出てこない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://cdn.firebase.com/libs/firebaseui/2.0.0/firebaseui.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.firebase.com/libs/firebaseui/2.0.0/firebaseui.css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;firebase.auth.PhoneAuthProvider.PROVIDER_ID&lt;/code&gt;がphone number authの
&lt;a href=&#34;https://github.com/firebase/firebaseui-web#starting-the-sign-in-flow&#34;&gt;オプション&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const uiConfig = {
    signInOptions: [
        firebase.auth.PhoneAuthProvider.PROVIDER_ID
    ],
    ...
}

const ui = new firebaseui.auth.AuthUI(firebase.auth());
ui.start(&#39;#firebaseui-auth-container&#39;, uiConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなボタンを押すと&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-1.png&#34; alt=&#34;ボタン&#34; /&gt;&lt;/p&gt;

&lt;p&gt;電話番号とCAPTCHAが入り、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-2.png&#34; alt=&#34;電話番号とCAPTCHA&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SMSに書かれた番号を入力すると認証される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/102-3.png&#34; alt=&#34;番号入力&#34; /&gt;&lt;/p&gt;

&lt;p&gt;二段階認証のようなものだと思っていたけど、そうではないみたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UWPでBLEデバイスとペアリングして値を取得する</title>
          <link>http://sambaiz.net/article/101/</link>
          <pubDate>Sat, 13 May 2017 10:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/101/</guid>
          <description>

&lt;p&gt;ManifestからBluetoothを許可しておく。&lt;/p&gt;

&lt;h2 id=&#34;bleデバイスを見つける-https-github-com-microsoft-windows-universal-samples-blob-dev-samples-bluetoothleclient-cs-scenario1-discoverserver-xaml-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/Windows-universal-samples/blob/dev/Samples/BluetoothLEClient/cs/Scenario1_DiscoverServer.xaml.cs&#34;&gt;BLEデバイスを見つける&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CreateWatcher&lt;/code&gt;にBluetooth LEプロトコルの&lt;a href=&#34;https://docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/aep-service-class-ids&#34;&gt;AEP(Association EndPoint)サービスクラスID&lt;/a&gt;と
requestPropaertiesで必要なデバイス情報を渡している。
最後の&lt;code&gt;AssociationEndpoint&lt;/code&gt;は&lt;code&gt;System.Devices.Aep.ProtocolId&lt;/code&gt;のAepと&lt;a href=&#34;https://docs.microsoft.com/ja-jp/windows/uwp/devices-sensors/enumerate-devices-over-a-network&#34;&gt;対応している&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Windows.Devices.Enumeration;

string[] requestedProperties = { &amp;quot;System.Devices.Aep.DeviceAddress&amp;quot;, &amp;quot;System.Devices.Aep.IsConnected&amp;quot; };

deviceWatcher = DeviceInformation.CreateWatcher(
                        &amp;quot;(System.Devices.Aep.ProtocolId:=\&amp;quot;{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\&amp;quot;)&amp;quot;,
                        requestedProperties,
                        DeviceInformationKind.AssociationEndpoint);

deviceWatcher.Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;deviceWatcher.Added += DeviceWatcher_Added;
deviceWatcher.Removed += DeviceWatcher_Removed;
deviceWatcher.Updated += DeviceWatcher_Updated;
/*
deviceWatcher.EnumerationCompleted += DeviceWatcher_EnumerationCompleted;
deviceWatcher.Stopped += DeviceWatcher_Stopped;
*/

Dictionary&amp;lt;string, DeviceInformation&amp;gt; deviceInfos = new Dictionary&amp;lt;string, DeviceInformation&amp;gt;();

private void DeviceWatcher_Added(DeviceWatcher sender, DeviceInformation deviceInfo)
{

    if (sender == deviceWatcher)
    {
        if (deviceInfo.Name != string.Empty)
        {
            deviceInfos.Add(deviceInfo.Id, deviceInfo);   
        }
    }
}

private void DeviceWatcher_Updated(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
{
    if (sender == deviceWatcher)
    {
        deviceInfos[deviceInfoUpdate.id].Update(deviceInfoUpdate);
    }
}

 private void DeviceWatcher_Removed(DeviceWatcher sender, DeviceInformationUpdate deviceInfoUpdate)
{
    if (sender == deviceWatcher)
    {
        deviceInfos.Remove(deviceInfoUpdate.id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ペアリング&#34;&gt;ペアリング&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DevicePairingResult result = await deviceInfo.Pairing.PairAsync();
if (result.Status == DevicePairingResultStatus.Paired || result.Status == DevicePairingResultStatus.AlreadyPaired){
    // success
} else{
    // fail
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなウィンドウが出てくる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/101.png&#34; alt=&#34;ペアリング確認&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OSの設定からペアリングすることもできる。&lt;/p&gt;

&lt;h2 id=&#34;serviceのcharacteristicを取得する&#34;&gt;serviceのcharacteristicを取得する&lt;/h2&gt;

&lt;p&gt;ペアリングしたらこんな感じで値を取得できる。
&lt;code&gt;GetGattServicesForUuidAsyc&lt;/code&gt;などはCreaters Updateから追加されたAPI。
deviceの値が取得できない場合はBluetoothが許可されているか確認する。
あと、characteristicが一つも取れない場合、他のアプリケーションからアクセスしていないか注意。
ドキュメントにも書いてあるけど、一つのサービスには一つのアプリケーションしかアクセスできない。
そもそも接続できない場合、一旦お互いの接続設定を消して再ペアリングするとよくなることがある。
ペアリングもできないようだったらBluetoothをオフにしてみるとか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var device = await BluetoothLEDevice.FromIdAsync(deviceInfo.Id);

var services = await device.GetGattServicesForUuidAsync(serviceUUID);

var characteristics = await services.Services[0].GetCharacteristicsForUuidAsync(characteristicUUID);

characteristics.Characteristics[0].ValueChanged += characteristicChanged;

await characteristics.Characteristics[0].WriteClientCharacteristicConfigurationDescriptorAsync(
    GattClientCharacteristicConfigurationDescriptorValue.Notify
);

void characteristicChanged(
    GattCharacteristic sender,
    GattValueChangedEventArgs eventArgs
){
    byte[] data = new byte[eventArgs.CharacteristicValue.Length];
    Streams.DataReader.FromBuffer(eventArgs.CharacteristicValue).ReadBytes(data);
    var str = System.Text.Encoding.ASCII.GetString(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest)</title>
          <link>http://sambaiz.net/article/100/</link>
          <pubDate>Tue, 09 May 2017 20:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/100/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;merge-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-merge&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge&#34;&gt;merge&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;2つのstreamの両方の値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.merge(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`merge ${data}`),
  err =&amp;gt; console.log(`merge ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;forkjoin-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-forkjoin&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin&#34;&gt;forkJoin&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;completeしたときの最後の値を配列としてemitする。
非同期で一つ値をemitするようなstreamで、Promise.allのようなことをしたいときはこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.forkJoin(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`      forkJoin: ${data}`),
  err =&amp;gt; console.log(`      forkJoin: ${err}`)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concat-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-concat&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat&#34;&gt;concat&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;前のstreamがcompleteしたら次のstreamの値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.concat(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`  concat ${data}`),
  err =&amp;gt; console.log(`  concat ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinelatest-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-combinelatest&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest&#34;&gt;combineLatest&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;stream自体を結合するのではなく値を結合する。
この例だと、streamでemitされた値がa、stream2で最後のemitされた値がbになる。
combineする値がない場合はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stream1.combineLatest(stream2, (a, b) =&amp;gt; a + b).subscribe(
  data =&amp;gt; console.log(`    combineLatest ${data}`),
  err =&amp;gt; console.log(`    combineLatest ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;同時に実行したときの結果&#34;&gt;同時に実行したときの結果&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;const stream1 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 1-${v+1}`).take(3);
const stream2 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 2-${v+1}`).take(3).delay(150);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/100.png&#34; alt=&#34;stream1とstream2&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;merge stream 1-1
  concat stream 1-1
merge stream 1-2
  concat stream 1-2
merge stream 2-1 &amp;lt;- mergeではstream1はcompleteしていないが、stream2がemitされる
merge stream 1-3
  concat stream 1-3
    combineLatest stream 1-3stream 2-1 &amp;lt;- stream2の値がemitされたのでcombineする
merge stream 2-2
    combineLatest stream 1-3stream 2-2
      forkJoin: stream 1-3,stream 2-3 &amp;lt;- stream1とstream2がcompleteしたのでforkJoinでemitされる
    combineLatest stream 1-3stream 2-3
merge stream 2-3
  concat stream 2-1 &amp;lt;- concatではstream1がcompleteしたので、stream2がemitされる
  concat stream 2-2
  concat stream 2-3
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>angular/material2でフォームを作る</title>
          <link>http://sambaiz.net/article/99/</link>
          <pubDate>Sat, 06 May 2017 22:16:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/99/</guid>
          <description>

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99.gif&#34; alt=&#34;フォーム&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/angular4-form&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;angular-material2-https-github-com-angular-material2-の準備&#34;&gt;&lt;a href=&#34;https://github.com/angular/material2&#34;&gt;angular/material2&lt;/a&gt;の準備&lt;/h2&gt;

&lt;p&gt;現時点で
&lt;a href=&#34;https://github.com/angular/material2/issues/675&#34;&gt;DatePicker&lt;/a&gt;や
&lt;a href=&#34;https://github.com/angular/material2/issues/581&#34;&gt;Table&lt;/a&gt;など
開発中のコンポーネントが多いため足りないものを他のライブラリで補うなどする必要がある。
DatePickerはもう少しで出そう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save @angular/material
$ npm install --save hammerjs # gesture用
$ npm install --save @angular/animations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moduleで&lt;code&gt;import &#39;hammerjs&#39;;&lt;/code&gt;して、以下のModuleをimportに加える。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BrowserAnimationsModule&lt;/code&gt;(&lt;code&gt;from &#39;@angular/platform-browser/animations&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MdButtonModule&lt;/code&gt;など使うもの(&lt;code&gt;from &#39;@angular/material&#39;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スタイルとアイコン(md-icon)を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link href=&amp;quot;../node_modules/@angular/material/prebuilt-themes/indigo-pink.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&amp;lt;link href=&amp;quot;https://fonts.googleapis.com/icon?family=Material+Icons&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;フォームを作る-https-angular-io-docs-ts-latest-guide-forms-html&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/forms.html&#34;&gt;フォームを作る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;とりあえずコンポーネントを作成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component TodoForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Formの値をバインドするためのクラスを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class TodoForm {
  constructor(
    public id: number,
    public title: string,
    public active: boolean,
    public priority?: number,
  ) {  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://material.angular.io/components&#34;&gt;material2の&lt;/a&gt;mdInput, mdSelect, mdButtonでフォームを作る。
&lt;code&gt;#todoForm&lt;/code&gt;のように頭についている#は
&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/template-syntax.html#!#ref-vars&#34;&gt;reference variable&lt;/a&gt;で、
titleはrequiredとしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;root&amp;quot;&amp;gt;
  &amp;lt;form (ngSubmit)=&amp;quot;onSubmit()&amp;quot; #todoForm=&amp;quot;ngForm&amp;quot;&amp;gt;

    &amp;lt;div *ngIf=&amp;quot;model.id !== 0&amp;quot; class=&amp;quot;form-item&amp;quot;&amp;gt;
      ID: {{model.id}}
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-input-container&amp;gt;
        &amp;lt;input mdInput name=&amp;quot;title&amp;quot; required placeholder=&amp;quot;やること&amp;quot; 
          [(ngModel)]=&amp;quot;model.title&amp;quot;&amp;gt;
      &amp;lt;/md-input-container&amp;gt;
    &amp;lt;/div&amp;gt;
    
    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-select placeholder=&amp;quot;優先度&amp;quot; name=&amp;quot;priority&amp;quot; 
        [(ngModel)]=&amp;quot;model.priority&amp;quot;&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;1&amp;quot;&amp;gt;高&amp;lt;/md-option&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;2&amp;quot;&amp;gt;中&amp;lt;/md-option&amp;gt;
        &amp;lt;md-option [value]=&amp;quot;3&amp;quot;&amp;gt;低&amp;lt;/md-option&amp;gt;        
      &amp;lt;/md-select&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;md-slide-toggle name=&amp;quot;active&amp;quot; [(ngModel)]=&amp;quot;model.active&amp;quot;&amp;gt;
        有効にする
      &amp;lt;/md-slide-toggle&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
      &amp;lt;button type=&amp;quot;submit&amp;quot; md-raised-button [disabled]=&amp;quot;!todoForm.form.valid&amp;quot;&amp;gt;
        Submit
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Active&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Priority&amp;lt;/th&amp;gt;
  &amp;lt;/thead&amp;gt;
  &amp;lt;tbody&amp;gt;
    &amp;lt;tr li *ngFor=&amp;quot;let todo of todos&amp;quot;&amp;gt;
      &amp;lt;td&amp;gt;{{todo.id}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.title}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.active}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;{{todo.priority}}&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;button md-button (click)=&amp;quot;onEdit(todo.id)&amp;quot;&amp;gt;編集&amp;lt;/button&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンポーネントはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component({
  selector: &#39;app-todo-form&#39;,
  templateUrl: &#39;./todo-form.component.html&#39;,
  styleUrls: [&#39;./todo-form.component.css&#39;]
})
export class TodoFormComponent implements OnInit {

  constructor() { }

  todos: TodoForm[] = [];
  model = new TodoForm(0, &amp;quot;&amp;quot;, false);

  ngOnInit() {
  }

  onSubmit() {
    if(this.model.id === 0) {
      this.model.id = this.todos.length + 1;
      this.todos.push(this.model);
    }else{
      this.todos[this.model.id - 1] = this.model;
    }
    this.model = new TodoForm(0, &amp;quot;&amp;quot;, false);
  }

  onEdit(id: number) {
    this.model = Object.assign({}, this.todos[id - 1]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;autocomplete-https-material-angular-io-components-component-autocomplete&#34;&gt;&lt;a href=&#34;https://material.angular.io/components/component/autocomplete&#34;&gt;AutoComplete&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;次に人を登録するためのtextフォームを作る。これは前もって登録されている人の中からAutoCompleteさせる。&lt;/p&gt;

&lt;p&gt;mdAutocompleteに候補を渡してmdInputのmdAutoCompleteにmdAutoCompleteの参照を渡す。
&lt;a href=&#34;https://angular.io/docs/ts/latest/api/forms/index/FormControl-class.html&#34;&gt;FormControl&lt;/a&gt;を扱うためには&lt;code&gt;@angular/forms&lt;/code&gt;の&lt;code&gt;ReactiveFormsModule&lt;/code&gt;をimportする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
    &amp;lt;md-input-container&amp;gt;
      &amp;lt;input mdInput name=&amp;quot;assignee&amp;quot; required placeholder=&amp;quot;やるひと&amp;quot; 
        [(ngModel)]=&amp;quot;model.assignee&amp;quot;
        [mdAutocomplete]=&amp;quot;autoAssignee&amp;quot;
        [formControl]=&amp;quot;assigneeFormControl&amp;quot;
      &amp;gt;
    &amp;lt;/md-input-container&amp;gt;

    &amp;lt;md-autocomplete #autoAssignee=&amp;quot;mdAutocomplete&amp;quot; [displayWith]=&amp;quot;displayAssignee&amp;quot;&amp;gt;
      &amp;lt;md-option *ngFor=&amp;quot;let p of filteredAssignee | async&amp;quot; [value]=&amp;quot;p&amp;quot;&amp;gt;
          {{ p.name }}
      &amp;lt;/md-option&amp;gt;
    &amp;lt;/md-autocomplete&amp;gt;
  &amp;lt;/div&amp;gt;
  
  &amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
    &amp;lt;md-select placeholder=&amp;quot;優先度&amp;quot; name=&amp;quot;priority&amp;quot; 
      [(ngModel)]=&amp;quot;model.priority&amp;quot;&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;1&amp;quot;&amp;gt;高&amp;lt;/md-option&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;2&amp;quot;&amp;gt;中&amp;lt;/md-option&amp;gt;
      &amp;lt;md-option [value]=&amp;quot;3&amp;quot;&amp;gt;低&amp;lt;/md-option&amp;gt;        
    &amp;lt;/md-select&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;people: Person[] = [
  {id: 1, name: &amp;quot;taro&amp;quot;},
  {id: 2, name: &amp;quot;jiro&amp;quot;},
  {id: 3, name: &amp;quot;ichiro&amp;quot;}
];
assigneeFormControl = new FormControl();
filteredAssignee: Observable&amp;lt;Person[]&amp;gt;;

ngOnInit() {
  this.filteredAssignee = this.assigneeFormControl.valueChanges
        .startWith(null)
        .map(val =&amp;gt; val ? this.assigneeFilter(val) : this.people.slice());

  this.assigneeFormControl.asyncValidator
}

assigneeFilter(val: string): Person[] {
  return this.people.filter(p =&amp;gt; new RegExp(`^${val}`, &#39;gi&#39;).test(p.name)); 
}

displayAssignee(person: Person): string {
  return person ? person.name : &#39;&#39;;
}

export class TodoForm {
  constructor(
    public id: number,
    public title: string,
    public active: boolean,
    public priority?: number,
    public assignee?: Person,
  ) {  }
}

interface Person { id: number, name: string };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;datepicker&#34;&gt;DatePicker&lt;/h2&gt;

&lt;p&gt;最後に目標日を設定するためにDatePickerを用意する。
上にも書いた通り、material2にはまだDatepickerがないので他のライブラリで代用する。
今回はAngular v4に対応していて見た目がシンプルな&lt;a href=&#34;https://github.com/koleary94/Angular-2-Datepicker&#34;&gt;koleary94/Angular-2-Datepicker&lt;/a&gt;を使った。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save angular2-material-datepicker
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;form-item&amp;quot;&amp;gt;
  &amp;lt;material-datepicker placeholder=&amp;quot;終了予定日&amp;quot; [(date)]=&amp;quot;model.deadline&amp;quot;&amp;gt;&amp;lt;/material-datepicker&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CSSのdisplayとposition</title>
          <link>http://sambaiz.net/article/98/</link>
          <pubDate>Sat, 06 May 2017 14:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/98/</guid>
          <description>

&lt;h2 id=&#34;display-https-developer-mozilla-org-ja-docs-web-css-display&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/display&#34;&gt;display&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;レンダリングに使うボックスを指定する。&lt;/p&gt;

&lt;h3 id=&#34;outer-display-type&#34;&gt;outer display type&lt;/h3&gt;

&lt;p&gt;pのようなブロックレベル要素やspanのようなインラインレベル要素に関わらず、指定したボックスにレンダリングする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99.png&#34; alt=&#34;outer display type&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:none&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;none&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;p style=&amp;quot;display:inline&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline&amp;lt;/p&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;中央寄せ&#34;&gt;中央寄せ&lt;/h3&gt;

&lt;p&gt;中央寄せはblockにwidthを設定して&lt;code&gt;margin auto&lt;/code&gt;するか、
親要素で&lt;code&gt;text-align: center&lt;/code&gt;してinline(-block)にする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-center.png&#34; alt=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  height: 80px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin width&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;text-align: center&amp;quot;&amp;gt;
  
  &amp;lt;div style=&amp;quot;display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block align-center&amp;lt;/div&amp;gt;
  
  &amp;lt;div style=&amp;quot;width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block align-center width&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flex-https-developer-mozilla-org-ja-docs-web-css-css-flexible-box-layout-using-css-flexible-boxes&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes&#34;&gt;flex&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;displayでflexを指定するとflex containerになる。
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-flow&#34;&gt;flex-flow&lt;/a&gt;は
表示する方向の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-direction&#34;&gt;flex-direction&lt;/a&gt;と
折り返しの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-wrap&#34;&gt;flex-wrap&lt;/a&gt;のショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;子要素の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex&#34;&gt;flex&lt;/a&gt;は
伸びるときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-grow&#34;&gt;flex-grow&lt;/a&gt;(default: 0)と
縮むときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-shrink&#34;&gt;flex-shrink&lt;/a&gt;(default: 1)、
初期サイズの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-basis&#34;&gt;flex-basis&lt;/a&gt;(default: auto)の
ショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-flex.png&#34; alt=&#34;flex&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  this is
  &amp;lt;div style=&amp;quot;display:flex; flex-flow: row wrap&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;flex: auto; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item1&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 300px; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item2&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-grow | flex-shrink | flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 0 1 30%; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item3&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  desu
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;position-https-developer-mozilla-org-ja-docs-web-css-position&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/position&#34;&gt;position&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;relative&#34;&gt;relative&lt;/h3&gt;

&lt;p&gt;この設定を考慮せずにすべての要素を配置した後に設定を適用する。
そのため、この例の3つ目のdivの&lt;code&gt;left: 30px&lt;/code&gt;は2つ目のdivの元々の位置から30px右になっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-relative.png&#34; alt=&#34;relative&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 30px; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;bbb&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;ccc&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute&#34;&gt;absolute&lt;/h3&gt;

&lt;p&gt;絶対位置で指定する。位置指定された祖先要素の相対的な位置になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-absolute.png&#34; alt=&#34;absolute&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 50px&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;background-color: #eeeeee&amp;quot;&amp;gt;relative top 50px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; left: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;left 100px&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fixed&#34;&gt;fixed&lt;/h3&gt;

&lt;p&gt;ビューポートに対して絶対的な位置を指定する。この例では2つ目のfixedなdivはスクロールしてもビューポートに対して位置が固定される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/99-fixed.png&#34; alt=&#34;fixed&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;height: 3000px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;position: fixed; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AngularのRouter</title>
          <link>http://sambaiz.net/article/97/</link>
          <pubDate>Sun, 30 Apr 2017 22:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/97/</guid>
          <description>

&lt;pre&gt;&lt;code&gt;@angular/core&amp;quot;: 4.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/40/&#34;&gt;Angular2とangular-cliでTODOを作る - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;angular-cli&lt;/code&gt;は&lt;code&gt;@angular/cli&lt;/code&gt;に&lt;a href=&#34;https://github.com/angular/angular-cli/commit/601f9b38f8ce53052d623a4b8a2dc5bb30f9eee1&#34;&gt;変更された&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;routingを行うのでnewで&lt;code&gt;--routing&lt;/code&gt;オプションを付けている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g @angular/cli
$ ng -v
@angular/cli: 1.0.1

$ ng new angular4-routing --routing
$ cd angular4-routing/
$ cat package.json | grep @angular/core
    &amp;quot;@angular/core&amp;quot;: &amp;quot;^4.0.0&amp;quot;,

$ ng serve
** NG Live Development Server is running on http://localhost:4200 **     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--routing&lt;/code&gt;を付けたので&lt;code&gt;app-routing.module.ts&lt;/code&gt;が作成され、&lt;code&gt;app.module.ts&lt;/code&gt;にAppRoutingModuleが追加される。
&lt;code&gt;index.html&lt;/code&gt;のheadにはpushStateのroutingが働くように
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&#34;&gt;base&lt;/a&gt;要素が
&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#base-href&#34;&gt;追加されている&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { NgModule } from &#39;@angular/core&#39;;
import { Routes, RouterModule } from &#39;@angular/router&#39;;

const routes: Routes = [
  {
    path: &#39;&#39;,
    children: []
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;app.component.html&lt;/code&gt;に&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#router-outlet&#34;&gt;router-outlet&lt;/a&gt;が置かれていてroutingによるComponentはこの下に描画される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;
  {{title}}
&amp;lt;/h1&amp;gt;
&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動的に追加されるコンポーネントのstyleは&lt;code&gt;@HostBinding&lt;/code&gt;で設定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class TodoMainComponent implements OnInit {

  @HostBinding(&#39;style.width&#39;)   width = &#39;100%&#39;;

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ルーティング定義-https-angular-io-docs-ts-latest-guide-router-html-route-config&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-config&#34;&gt;ルーティング定義&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;children&lt;/code&gt;で&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#child-routing-component&#34;&gt;child route&lt;/a&gt;を設定しているが、
これは親コンポーネントの&lt;code&gt;router-outlet&lt;/code&gt;の下に描画される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component todo/todo-main
$ ng g component todo/todo-list
$ ng g component todo/todo-item
$ ng g component not-found
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { NgModule } from &#39;@angular/core&#39;;
import { Routes, RouterModule } from &#39;@angular/router&#39;;

import { TodoMainComponent } from &#39;./todo/todo-main/todo-main.component&#39;
import { TodoListComponent } from &#39;./todo/todo-list/todo-list.component&#39;
import { TodoItemComponent } from &#39;./todo/todo-item/todo-item.component&#39;
import { NotFoundComponent } from &#39;./not-found/not-found.component&#39;

const routes: Routes = [
  {
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
  },
  {
    path: &#39;**&#39;,
    component: NotFoundComponent,
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-main works!
&amp;lt;/p&amp;gt;
&amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで &lt;a href=&#34;http://localhost:4200/todo&#34;&gt;http://localhost:4200/todo&lt;/a&gt; にアクセスすると、&lt;code&gt;TodoMainComponent&lt;/code&gt;と&lt;code&gt;TodoListComponent&lt;/code&gt;が表示される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app works!

todo-main works!

todo-list works!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;パラメータの取得-https-angular-io-docs-ts-latest-guide-router-html-route-parameters-activated-route&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-parameters-activated-route&#34;&gt;パラメータの取得&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ActivatedRoute&lt;/code&gt;をDIしてObservableなparamsをSubscribeする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit, HostBinding } from &#39;@angular/core&#39;;
import { Router, ActivatedRoute, Params } from &#39;@angular/router&#39;;

@Component({
  selector: &#39;app-todo-item&#39;,
  templateUrl: &#39;./todo-item.component.html&#39;,
  styleUrls: [&#39;./todo-item.component.css&#39;]
})
export class TodoItemComponent implements OnInit {

  id: number;

  constructor(
    private route: ActivatedRoute,
  ) { }

  ngOnInit() {  
    this.route.params.subscribe(
      (params: Params) =&amp;gt; this.id = +params[&#39;id&#39;]
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-item ({{id}}) works!
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;遷移&#34;&gt;遷移&lt;/h2&gt;

&lt;p&gt;タグなら&lt;code&gt;&amp;lt;a routerLink&amp;gt;&lt;/code&gt;を、コードなら&lt;code&gt;Router.navigate&lt;/code&gt;を使って遷移できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  todo-item ({{id}}) works!
  &amp;lt;button (click)=&amp;quot;onClickNext()&amp;quot;&amp;gt;Next&amp;lt;/button&amp;gt;
  &amp;lt;a routerLink=&amp;quot;/todo&amp;quot;&amp;gt;todos&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
export class TodoItemComponent implements OnInit {

  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) { }

  ...

  onClickNext() {
    if(typeof this.id !== &#39;undefined&#39;){
      this.router.navigate([`/todo/${this.id+1}`, {hoge: &amp;quot;fuga&amp;quot;}]);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;navigateでhogeという適当なパラメータを付けているが、呼ぶと&lt;code&gt;http://localhost:4200/todo/10;hoge=fuga&lt;/code&gt;のように
クエリパラメータが&lt;code&gt;?, &amp;amp;&lt;/code&gt;ではなく&lt;code&gt;;&lt;/code&gt;で区切られたURLに遷移する。
これをmatrix URL notationといって、&lt;a href=&#34;https://www.w3.org/DesignIssues/MatrixURIs.html&#34;&gt;結構由緒正しい&lt;/a&gt;ものらしい。&lt;/p&gt;

&lt;h2 id=&#34;guard-https-angular-io-docs-ts-latest-guide-router-html-guards&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#guards&#34;&gt;Guard&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;routeの遷移時に何かするためのもの。
具体的にはログインしているかどうかをチェックしたりとか、
遷移する前にデータを一時保存したりとかそういうのに使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g guard auth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanActivate-interface.html&#34;&gt;canActivate()&lt;/a&gt;
はrouteに遷移するときに呼ばれ、trueを返すとそのまま続行され、falseを返すと中断される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Injectable } from &#39;@angular/core&#39;;
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &#39;@angular/router&#39;;
import { Observable } from &#39;rxjs/Observable&#39;;

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable&amp;lt;boolean&amp;gt; | Promise&amp;lt;boolean&amp;gt; | boolean {
    console.log(`canActivate(): ${state.url}`);
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AppModuleのprovidersにAuthGuardを入れて、routesにも&lt;code&gt;canActivate&lt;/code&gt;としてAuthGuardを設定すると呼ばれるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { AuthGuard } from &#39;./auth.guard&#39;

const routes: Routes = [
  {
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    canActivate: [AuthGuard],
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
  },
  {
    path: &#39;**&#39;,
    component: NotFoundComponent,
  }
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定だと上で追加したNextボタンを押してchild routeに遷移したときには呼ばれない。
&lt;code&gt;canActivateChild()&lt;/code&gt;にするとchild routeに遷移したときにも呼ばれるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;canActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&amp;lt;boolean&amp;gt; | Promise&amp;lt;boolean&amp;gt; | boolean {
  return this.canActivate(route, state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
    path: &#39;todo&#39;,
    component: TodoMainComponent,
    canActivateChild: [AuthGuard],
    children: [
          {
            path: &#39;:id&#39;,
            component: TodoItemComponent
          },
          {
            path: &#39;&#39;,
            component: TodoListComponent
          }
    ]
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらの他には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html&#34;&gt;canDeactivate()&lt;/a&gt;: 今のrouteから離れるとき&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/Resolve-interface.html&#34;&gt;resolve()&lt;/a&gt;: コンポーネントを表示する前。pre-fetchのため。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/router/index/CanLoad-interface.html&#34;&gt;canLoad()&lt;/a&gt;: &lt;code&gt;loadChildren&lt;/code&gt;で指定したModuleを&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#lazy-loading-route-config&#34;&gt;lazy load&lt;/a&gt;
するとき。ドキュメントではAdminModuleに対して、認証されていなかったらロードしないようにしている。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のGuardがある。&lt;/p&gt;

&lt;h2 id=&#34;アニメーション-https-angular-io-docs-ts-latest-guide-router-html-route-animation&#34;&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#route-animation&#34;&gt;アニメーション&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;app.module.ts&lt;/code&gt;に&lt;code&gt;BrowserAnimationsModule&lt;/code&gt;を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save @angular/animations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { BrowserAnimationsModule } from &#39;@angular/platform-browser/animations&#39;;

@NgModule({
  ...
  imports: [
    ...
    BrowserAnimationsModule
  ],
  ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;animations.ts&lt;/code&gt;を作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { animate, AnimationEntryMetadata, state, style, transition, trigger } from &#39;@angular/core&#39;;

// Component transition animations
export const slideInDownAnimation: AnimationEntryMetadata =
  trigger(&#39;routeAnimation&#39;, [
    state(&#39;*&#39;,
      style({
        opacity: 1,
        transform: &#39;translateX(0)&#39;
      })
    ),
    transition(&#39;:enter&#39;, [
      style({
        opacity: 0,
        transform: &#39;translateX(-100%)&#39;
      }),
      animate(&#39;0.2s ease-in&#39;)
    ]),
    transition(&#39;:leave&#39;, [
      animate(&#39;0.5s ease-out&#39;, style({
        opacity: 0,
        transform: &#39;translateY(100%)&#39;
      }))
    ])
  ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを@Componentのanimationsに入れて&lt;code&gt;@HostBinding&lt;/code&gt;でanimationのトリガー(routeAnimation)を発火させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit, HostBinding } from &#39;@angular/core&#39;;
import { Router, ActivatedRoute, Params } from &#39;@angular/router&#39;;
import { slideInDownAnimation } from &#39;../../animations&#39;;

@Component({
  selector: &#39;app-todo-item&#39;,
  templateUrl: &#39;./todo-item.component.html&#39;,
  styleUrls: [&#39;./todo-item.component.css&#39;],
  animations: [ slideInDownAnimation ]
})
export class TodoItemComponent implements OnInit {

  @HostBinding(&#39;@routeAnimation&#39;) routeAnimation = true;
  @HostBinding(&#39;style.display&#39;)   display = &#39;block&#39;;
  @HostBinding(&#39;style.position&#39;)  position = &#39;absolute&#39;;

  id: number;

  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) { }

  ngOnInit() {  
    this.route.params.subscribe(
      (params: Params) =&amp;gt; this.id = +params[&#39;id&#39;]
    );
  }

  onClickNext() {
    this.router.navigate([&#39;/todo&#39;, {id: this.id + 1, hoge: &amp;quot;fuga&amp;quot;}])
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにアニメーションする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/97.gif&#34; alt=&#34;アニメーション&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのStream API</title>
          <link>http://sambaiz.net/article/96/</link>
          <pubDate>Sat, 22 Apr 2017 19:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/96/</guid>
          <description>

&lt;h2 id=&#34;stream-apiとは-https-nodejs-org-docs-v7-9-0-api-stream-html&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html&#34;&gt;Stream APIとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NodeでStreamデータを扱うためのもの。
例えばサイズが大きいファイルの入出力をStreamとして扱うことでバッファを最小限にできる。&lt;/p&gt;

&lt;p&gt;Streamは&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/events.html&#34;&gt;EventEmitter&lt;/a&gt;で、
Readable streamやWritable stream、ReadableとWritableを合わせたDuplex streamと
Readしたものを加工してWriteするTransform streamの種類があり、
それぞれ特定の関数が&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_api_for_stream_implementers&#34;&gt;実装&lt;/a&gt;されている必要がある。&lt;/p&gt;

&lt;h2 id=&#34;readable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-streams&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_streams&#34;&gt;Readable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamには&lt;code&gt;flowing&lt;/code&gt;と&lt;code&gt;paused&lt;/code&gt;の
&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_two_modes&#34;&gt;二つのモード&lt;/a&gt;がある。
最初は&lt;code&gt;paused&lt;/code&gt;モードで、readableになってからread()することで読むことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;readable&#39;, () =&amp;gt; {
  let chunk;
  while (null !== (chunk = readable.read(10))) {
    console.log(`${i++}: ${chunk}`);
  }
});
dable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat sample.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

$ node main.js
0: abcdefghij
1: klmnopqrst
2: uvwxyz
123
3: 4567890
あい
4: うえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dataのイベントハンドラーを追加するか、後で書くpipeを使うと&lt;code&gt;flowing&lt;/code&gt;モードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0: abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーハンドリングはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js
{ Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native) errno: -2, code: &#39;ENOENT&#39;, syscall: &#39;open&#39;, path: &#39;error.txt&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-readable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_readable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_read&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Readable = require(&#39;stream&#39;).Readable;

class Random extends Readable {
  constructor(opt) {
    super(opt); 
  }
  
  _read() {
    
    // error handling
    // if(err){ 
    //   this.emit(&#39;error&#39;, err)
    //   return
    // }
    
    this.push(Math.random()+&#39;&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;writable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-class-stream-writable&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_class_stream_writable&#34;&gt;Writable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;output.txtに出力するWritable stream。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let writable = fs.createWriteStream(&#39;output.txt&#39;)

writable.write(&#39;hoge\n&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力の流量が多く、Writable streamのバッファが&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_constructor_new_stream_writable_options&#34;&gt;highWaterMark&lt;/a&gt;を超えてしまうと、write()はfalseを返す。そのまま書き込み続けるとメモリを食いつぶしてしまうので、
全てのバッファが捌けて&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_event_drain&#34;&gt;drain&lt;/a&gt;イベントが発行されるまで書き込みを止めてback-pressureとする必要がある。
ただし、pipeを使う場合このあたりはやってくれるので、あまり気にすることはない。&lt;/p&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-writable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_writable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_write&lt;/code&gt;と、バッファされているchunkをまとめて扱うなら&lt;code&gt;_writev&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Writable = require(&#39;stream&#39;).Writable;

class DummyWritable extends Writable {
  constructor(opt) {
    super(opt);
  }

  _write(chunk, encoding, callback) {
    const chunkStr = chunk.toString()
    if (chunkStr == &#39;this is error&#39;) {
      callback(new Error(&#39;chunk is invalid&#39;));
    } else {
      console.log(chunkStr);
      callback();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipe-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-pipe-destination-options&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_pipe_destination_options&#34;&gt;pipe&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamをWritable streamとつなげる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
readable.pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意すべきなのは、pipeしたものをまとめてエラーハンドリングすることはできないこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
let piped = readable.pipe(writable);

piped.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;events.js:160
      throw er; // Unhandled &#39;error&#39; event
      ^

Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面倒だけど、毎度エラーハンドリングする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
const errorHandling = (err) =&amp;gt; { console.log(err) }
let piped = readable.on(&#39;error&#39;, errorHandling).pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeを組み合わせると、こんな風にcsvをfetchして加工し、文字コードを変えて出力するといったこともStreamでできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fetch = require(&#39;node-fetch&#39;);
const Iconv = require(&#39;iconv&#39;).Iconv;
const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
const csv = require(&#39;csv&#39;);
const fs = require(&#39;fs&#39;);

const errorHandling = (err) =&amp;gt; { console.log(err); };

const outputFile = fs.createWriteStream(&#39;output.csv&#39;);

fetch(&#39;http://example.com/test.csv&#39;).then((res) =&amp;gt; {

  res.body
  .pipe(csv.parse({columns : true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.transform(function(record){
    if(record[&#39;hoge&#39;] &amp;lt; 100000){
      return null;
    }
    return record;
  }))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.stringify({header: true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(iconv)
  .on(&#39;error&#39;, errorHandling)
  .pipe(outputFile)
  .on(&#39;error&#39;, errorHandling);

}).then(() =&amp;gt; console.log(&amp;quot;done&amp;quot;)).catch((err) =&amp;gt; console.log(err));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeではないけど、readlineのcreateInterfaceに入力と出力のStreamを渡すと、
行ごとに処理することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);

let readable = fs.createReadStream(&#39;sample.txt&#39;);
const rl = readline.createInterface({
  input: readable,
  output: process.stdout
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rxjsで扱う&#34;&gt;RxJSで扱う&lt;/h2&gt;

&lt;p&gt;StreamはEventEmitterなのでRxJSのfromEvent()でObservableとして扱うこともできる。ただし&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;v5&lt;/a&gt;にはpipeがない(v4には&lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS/blob/8fa95ac884181fb6cbff8ce7c1d669ffb190f5e4/src/core/linq/observable/pipe.js#L6&#34;&gt;ある&lt;/a&gt;)ので、pipeする場合は自分でSubscribeしてwriteする必要がありそう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const Rx = require(&#39;rxjs/Rx&#39;);
const writable = fs.createWriteStream(&#39;output.txt&#39;)

Rx.Observable.fromEvent(process.stdin, &#39;data&#39;)
.map((v) =&amp;gt; `- ${v}`)
.subscribe((v) =&amp;gt; write(v));

function write(v){
  // TODO: back-pressure
  writable.write(v);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js 
aiueo
kakikukeko
^C

$ cat output.txt 
- aiueo
- kakikukeko
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>tmuxのメモ</title>
          <link>http://sambaiz.net/article/95/</link>
          <pubDate>Fri, 21 Apr 2017 00:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/95/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://tmux.github.io/&#34;&gt;https://tmux.github.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;セッションを立ち上げてその中で複数のウィンドウやペインからコマンドを実行できるやつ。
サーバーでの作業中にネットワークが切断されてしまってもセッションをattachすることで再開することができる。
ローカル環境でもコマンドキーでのウィンドウ作成やペインの分割、
複数のサーバーにsshで入って調査するようなときにペインの同時入力は便利。
もちろんターミナルを閉じてしまっても再開できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install tmux
$ tmux
$ tmux ls
$ tmux a # sessionをattachする
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bind key(デフォルトで&lt;code&gt;Ctrl + b&lt;/code&gt;)を入れてからコマンドキーを入れる。よく使うもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;c: 新しいウインドウをCreateする&lt;/li&gt;
&lt;li&gt;d: 今のクライアントをDetachする&lt;/li&gt;
&lt;li&gt;n: Nextウィンドウに移動する&lt;/li&gt;
&lt;li&gt;p: Previousウィンドウに戻る&lt;/li&gt;
&lt;li&gt;w: Windowを一覧表示して選択する&lt;/li&gt;
&lt;li&gt;x: ペインを削除する&lt;/li&gt;
&lt;li&gt;,: ウィンドウの名前を変更する&lt;/li&gt;
&lt;li&gt;z: ウィンドウ一杯にペインをzoomする/解除&lt;/li&gt;
&lt;li&gt;[: ペイン内をスクロールできるようになる。qで解除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;~/.tmux.conf&lt;/code&gt;はこんな感じにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bind keyをC-tに変更してC-bを解除
set -g prefix C-t
unbind C-b

# Vimのキーバインドでペインを移動する
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# - でペインを横に分割する(縦に切る)
bind - split-window -h

# | でペインを縦に分割する(横に切る)
bind | split-window -v

# 同時入力
bind s set-window-option synchronize-panes on
bind S set-window-option synchronize-panes off
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Firebaseをwebで使う(Hosting, Authentication, Realtime Database, Storage)</title>
          <link>http://sambaiz.net/article/94/</link>
          <pubDate>Sun, 16 Apr 2017 20:03:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/94/</guid>
          <description>

&lt;h2 id=&#34;firebase-https-firebase-google-com-hl-ja-とは&#34;&gt;&lt;a href=&#34;https://firebase.google.com/?hl=ja&#34;&gt;Firebase&lt;/a&gt;とは&lt;/h2&gt;

&lt;p&gt;GoogleのmBaaS。Android/iOSアプリの開発に使う認証、データストア、クラッシュレポート、分析、通知、広告などなど全部入りサービス。
今年のGoogleI/Oでも&lt;a href=&#34;https://events.google.com/io/schedule/?section=may-19&#34;&gt;毎時間のように&lt;/a&gt;
Firebaseのセッションがあって大分推している印象。&lt;/p&gt;

&lt;p&gt;基本的にはアプリで使うのだけれど、webで使える機能も結構ある。今回は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hosting&lt;/li&gt;
&lt;li&gt;Authentication&lt;/li&gt;
&lt;li&gt;Realtime Database&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を使ってみる。&lt;/p&gt;

&lt;h2 id=&#34;料金-https-firebase-google-com-pricing&#34;&gt;&lt;a href=&#34;https://firebase.google.com/pricing/&#34;&gt;料金&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;プランは無料のSPARKと25ドル/月のFLAME、従量課金のBLAZEがある。
試す分にはSPARKで十分だけど、Realtime Databaseの同時接続数が100なので注意。&lt;/p&gt;

&lt;h2 id=&#34;セットアップ-https-firebase-google-com-docs-web-setup&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/web/setup&#34;&gt;セットアップ&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/cli/&#34;&gt;firebase-cli&lt;/a&gt;をインストール、ログインして初期化する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g firebase-tools
$ firebase login
$ mkdir firebase-chat &amp;amp;&amp;amp; cd firebase-chat
$ firebase init
...
? What Firebase CLI features do you want to setup for this folder? 
❯◉ Database: Deploy Firebase Realtime Database Rules
 ◉ Functions: Configure and deploy Cloud Functions
 ◉ Hosting: Configure and deploy Firebase Hosting sites

? What Firebase project do you want to associate as default? *****

? What file should be used for Database Rules? database.rules.json

? Do you want to install dependencies with npm now? Yes

? What do you want to use as your public directory? public

? Configure as a single-page app (rewrite all urls to /index.html)? Yes

✔  Firebase initialization complete!

$ ls
database.rules.json	firebase.json		functions		public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;firebase.jsonはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat firebase.json
{
  &amp;quot;database&amp;quot;: {
    &amp;quot;rules&amp;quot;: &amp;quot;database.rules.json&amp;quot;
  },
  &amp;quot;hosting&amp;quot;: {
    &amp;quot;public&amp;quot;: &amp;quot;public&amp;quot;,
    &amp;quot;rewrites&amp;quot;: [
      {
        &amp;quot;source&amp;quot;: &amp;quot;**&amp;quot;,
        &amp;quot;destination&amp;quot;: &amp;quot;/index.html&amp;quot;
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルでサーバーを立ち上げて確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase serve
Server listening at: http://localhost:5000

$ curl http://localhost:5000 # Firebase SDK loaded with auth, database, messaging, storage
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hosting-https-firebase-google-com-docs-hosting-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/hosting/?hl=ja&#34;&gt;Hosting&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;静的サイトのホスティング。もちろん独自ドメインも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only hosting
...
✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/*****/overview
Hosting URL: https://*****.firebaseapp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;authentication-https-firebase-google-com-docs-auth&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/auth/&#34;&gt;Authentication&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ユーザー認証。Googleだけではなく、TwitterやFacebook、Githubといったプロバイダや、メールとパスワードでの認証が用意されていて、
コンソールから有効にする必要がある。&lt;/p&gt;

&lt;p&gt;実装はFirebase SDKで自分でやるか、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const provider = new firebase.auth.GoogleAuthProvider();
firebase.auth().signInWithPopup(provider).then((result) =&amp;gt; {
    console.log(`sign in successfully. ${result.user.displayName}`)
}).catch((error) =&amp;gt; {
    console.log(`fail to sign in. ${error.message}`)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/firebase/FirebaseUI-Web&#34;&gt;FirebaseUI Auth&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script defer src=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.css&amp;quot; /&amp;gt;

&amp;lt;div id=&amp;quot;firebaseui-auth-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// FirebaseUI config.
var uiConfig = {
  signInOptions: [
    // Leave the lines as is for the providers you want to offer your users.
    firebase.auth.GoogleAuthProvider.PROVIDER_ID
  ],
  callbacks: {
    signInSuccess: function(currentUser, credential, redirectUrl) {
      // リダイレクトさせない
      return false;
    }
  },
  // Terms of service url.
  tosUrl: &#39;&amp;lt;your-tos-url&amp;gt;&#39;
};

// Initialize the FirebaseUI Widget using Firebase.
var ui = new firebaseui.auth.AuthUI(firebase.auth());
// The start method will wait until the DOM is loaded.
ui.start(&#39;#firebaseui-auth-container&#39;, uiConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにボタンが並ぶ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/93-firebase-authentication.png&#34; alt=&#34;Firebase authentication&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;onAuthStateChanged()&lt;/code&gt;でsign in/outをハンドリングでき、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firebase.auth().onAuthStateChanged((user) =&amp;gt; {
    if (user) {
      console.log(`${user.displayName} sign in`);
    } else {
      console.log(&#39;sign out&#39;);
    }
  }, (error) =&amp;gt; {
    console.log(error);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;currentUserでsign inしてるユーザーを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(firebase.auth().currentUser){
  console.log(firebase.auth().currentUser.displayName);
}else{
  // need to sign in
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;realtime-database-https-firebase-google-com-docs-database&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/&#34;&gt;Realtime Database&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NoSQLなデータベース。直接読み書きするのではなく、
ローカルにデータを保存してリアルタイムに同期するため一時的にオフライン状態になっても読み書きできる。&lt;/p&gt;

&lt;h3 id=&#34;読み書き-https-firebase-google-com-docs-database-web-read-and-write&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/web/read-and-write&#34;&gt;読み書き&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;データベースへの書き込みと更新。refで&lt;code&gt;users/1&lt;/code&gt;のように参照を取って操作する。
&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#push&#34;&gt;push()&lt;/a&gt;で
&lt;code&gt;hoge/-Khp36CCygw5AI6G8L1B&lt;/code&gt;のようなユニークなキーを発行することができ、これは時系列にソートされるようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const database = firebase.database();

for(let i = 0; i &amp;lt; 10; i++){
    
    const newHogeRef = database.ref(&#39;hoge&#39;).push();
    console.log(`newHogeRef: ${newHogeRef.toString()}`);
    
    newHogeRef.set({
        idx: i,
        aaa: &amp;quot;bbb123&amp;quot;,
    });

    newHogeRef.update({
        aaa: &amp;quot;bbb456&amp;quot;,
        eee: &amp;quot;fff&amp;quot;
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CCygw5AI6G8L1B
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CLyJ9BQVefW-l5
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CMs9-jJoKUUgr0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#on&#34;&gt;on()&lt;/a&gt;で
value eventを拾うと、
呼んだときとデータに変更があったときに&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.DataSnapshot?hl=ja&#34;&gt;snapshot&lt;/a&gt;が取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 7}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 8}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 9}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス権限-バリデーション-https-firebase-google-com-docs-database-security-securing-data&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data&#34;&gt;アクセス権限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;firebase.jsonで指定しているdatabase ruleファイル(database.rules.json)でルールを設定する。
デフォルトで認証していれば読み書きできる設定になっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read/writeだけではなくバリデーションの設定もこんな感じでできる。
これは&lt;code&gt;users/${ユーザーのuid}&lt;/code&gt;への読み書きを本人のみができるようにするもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only database
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の設定を適用したデータベースに読み書きしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const uid = firebase.auth().currentUser.uid;

database.ref(`users/${uid}`).set({
    age: 20,
    name: &amp;quot;taro&amp;quot;
});

// ok: Object {age: 20, name: &amp;quot;taro&amp;quot;}
database.ref(`users/${uid}`).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    console.log(snapshot.val()); // Object {age: 20, name: &amp;quot;taro&amp;quot;}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のような不正なデータや不正なキーに書き込もうとすると
&lt;code&gt;PERMISSION_DENIED: Permission denied&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ageがおかしい
database.ref(`users/${uid}`).set({
    age: &amp;quot;aaaa&amp;quot;,
    name: &amp;quot;jiro&amp;quot;
});

// 本人じゃない
database.ref(`users/hogehoge`).set({
    age: 20,
    name: &amp;quot;jiro&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、さっきまでアクセスできていたhogeにもアクセスできなくなっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// PERMISSION_DENIED: Permission denied
database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを解決するためにrulesのルートに&lt;code&gt;auth != null&lt;/code&gt;の設定を入れてしまうと、
&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data#read_and_write_rules_cascade&#34;&gt;浅い階層のルールが深い階層のルールより優先される&lt;/a&gt;
ためusersのread/writeの設定が無効になってしまうので注意。ただしvalidateはそれぞれの階層でチェックされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;storage-https-firebase-google-com-docs-storage&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/&#34;&gt;Storage&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;画像などを保存しておくために使う。
Realtime Databaseと同様、
ネットワーク品質が良くない環境でも使えるように、処理が中断されても途中から処理を再開するようになっている。
裏側ではGoogle Cloud Storageが使われている。&lt;/p&gt;

&lt;h3 id=&#34;アップロード-https-firebase-google-com-docs-storage-web-upload-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/upload-files&#34;&gt;アップロード&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file-upload&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const storage = firebase.storage();

const inputFile = document.getElementById(&#39;file-upload&#39;);

inputFile.addEventListener(&#39;change&#39;, (e) =&amp;gt; {
  const files = e.target.files;
  const user = firebase.auth().currentUser;
  if(user){
    const ref = storage.ref(`images/${user.uid}`);
    const uploadTask = ref.put(files[0]);
  }
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中断、再開、キャンセル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.pause();
uploadTask.resume();
uploadTask.cancel();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アップロードの状態はstage_changed eventで確認し、完了するとダウンロードURLを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.on(&#39;state_changed&#39;, (snapshot) =&amp;gt; {

  const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
  console.log(&#39;Upload is &#39; + progress + &#39;% done&#39;);

  switch (snapshot.state) {
    case firebase.storage.TaskState.PAUSED: // or &#39;paused&#39;
      console.log(&#39;Upload is paused&#39;);
      break;
    case firebase.storage.TaskState.RUNNING: // or &#39;running&#39;
      console.log(&#39;Upload is running&#39;);
      break;
  }
}, (error) =&amp;gt; {
  // Handle unsuccessful uploads
  console.log(error);
}, () =&amp;gt; {
  // Handle successful uploads on complete
  // For instance, get the download URL: https://firebasestorage.googleapis.com/...
  console.log(uploadTask.snapshot.downloadURL);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス制限-バリデーション-https-firebase-google-com-docs-storage-security-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/security/?hl=ja&#34;&gt;アクセス制限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Realtime Databaseと同様にアクセス制限やバリデーションをかけることができる。
設定はコンソールから。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/93-firebase-storage-rule.png&#34; alt=&#34;Storageのルール&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service firebase.storage {
  match /b/*****.appspot.com/o {
    match /images/{imageId} {
      // Only allow uploads of any image file that&#39;s less than 5MB
      allow write: if request.resource.size &amp;lt; 5 * 1024 * 1024
                   &amp;amp;&amp;amp; request.resource.contentType.matches(&#39;image/.*&#39;)
                   &amp;amp;&amp;amp; request.auth != null;
      allow read: if request.auth != null;             
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ダウンロード-https-firebase-google-com-docs-storage-web-download-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/download-files&#34;&gt;ダウンロード&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;getDownloadURL()&lt;/code&gt;でURLを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img id=&amp;quot;myimg&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const ref = storage.ref(`images/${user.uid}`).getDownloadURL().then((url) =&amp;gt; {
  
  const img = document.getElementById(&#39;myimg&#39;);
  img.src = url;

}).catch((error) =&amp;gt; {

  switch (error.code) {
    case &#39;storage/object-not-found&#39;:
      console.log(&amp;quot;not found&amp;quot;);
      break;

    default:
      console.log(error);
  }
});;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>MySQLのALTER TABLEのメモ</title>
          <link>http://sambaiz.net/article/93/</link>
          <pubDate>Sat, 15 Apr 2017 19:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/93/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/ja/alter-table.html&#34;&gt;MySQL :: MySQL 5.6 リファレンスマニュアル :: 13.1.7 ALTER TABLE 構文&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE t0 (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    c1 VARCHAR(30),
    c2 VARCHAR(30)
);
CREATE TABLE t2 (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE t0 RENAME t1;
ALTER TABLE t1
  ADD COLUMN t2_id BIGINT UNSIGNED AFTER id,
  ADD COLUMN c3 INTEGER NOT NULL AFTER t2_id,
  MODIFY COLUMN c1 VARCHAR(30) NOT NULL,
  DROP COLUMN c2,
  ADD INDEX (c3),
  ADD FOREIGN KEY (t2_id) REFERENCES t2(id) ON UPDATE CASCADE ON DELETE CASCADE
;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW CREATE TABLE t1 \G;
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `t2_id` bigint(20) unsigned DEFAULT NULL,
  `c3` int(11) NOT NULL,
  `c1` varchar(30) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `c3` (`c3`),
  KEY `t2_id` (`t2_id`),
  CONSTRAINT `t1_ibfk_1` FOREIGN KEY (`t2_id`) REFERENCES `t2` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE t1
  DROP INDEX c3,
  DROP FOREIGN KEY t1_ibfk_1,
  DROP INDEX t2_id
;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW CREATE TABLE t1 \G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `t2_id` bigint(20) unsigned DEFAULT NULL,
  `c3` int(11) NOT NULL,
  `c1` varchar(30) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityのパーティクル設定(Shuriken)</title>
          <link>http://sambaiz.net/article/92/</link>
          <pubDate>Thu, 13 Apr 2017 17:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/92/</guid>
          <description>

&lt;p&gt;Unityには&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/class-ParticleSystem.html&#34;&gt;Shuriken&lt;/a&gt;というパーティクルシステムがある。&lt;/p&gt;

&lt;p&gt;Sphereを置いてParticle Systemを追加すると、Particleが出始める。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-1.png&#34; alt=&#34;Particleの初期状態&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;モジュール&#34;&gt;モジュール&lt;/h2&gt;

&lt;p&gt;設定項目が多いためモジュールに分かれている。ひとまずデフォルトで有効になっている&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(メインモジュール)&lt;/li&gt;
&lt;li&gt;Emission&lt;/li&gt;
&lt;li&gt;Shape&lt;/li&gt;
&lt;li&gt;Renderer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;について見ていく。&lt;/p&gt;

&lt;h3 id=&#34;メインモジュール-https-docs-unity3d-com-550-documentation-manual-partsysmainmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysMainModule.html&#34;&gt;メインモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Duration: 5&lt;/li&gt;
&lt;li&gt;Looping: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;デフォルトだとLoopingにチェックが入っているのでずっと出ているが、チェックを外すとDurationで止まる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Delay: 0&lt;/li&gt;
&lt;li&gt;Play On Awake: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PlayOnAwakeがtrueでStartDelayが0なので実行してからすぐにParticleが出始める。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Lifetime: 5&lt;/li&gt;
&lt;li&gt;Max Particles: 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartLifetimeはParticleが消えるまでの時間。ただしMaxParticlesに達したら消される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Speed: 5&lt;/li&gt;
&lt;li&gt;Simulation Speed: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartSpeedはParticleの初速で、上げると勢い良く飛んでいく。
SimulationSpeedを上げるとParticleが出るのも含めて全体のスピードが上がる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Size: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期サイズ。小さくすると塵みたいになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Rotation: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期角度。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gravity Modifier: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重力値。0だと無重力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Simulation Space: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleをlocal座標かworld座標で動かすか。
Localだとオブジェクトが移動したときに一緒に移動する。Worldだと置いてかれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scaling Mode: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ParticleのScale。LocalだとそのオブジェクトのScaleだけを見る。Hierarchyだと親も考慮したScale。Shapeだと開始位置だけ。&lt;/p&gt;

&lt;h3 id=&#34;emissionモジュール-https-docs-unity3d-com-550-documentation-manual-partsysemissionmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysEmissionModule.html&#34;&gt;Emissionモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Rate over time: 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単位時間あたりにParticleを出す数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rate over Distance: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;オブジェクトが移動するときにParticleを出す数。Simulation SpaceがWorldのときのみ有効。&lt;/p&gt;

&lt;h3 id=&#34;shapeモジュール-https-docs-unity3d-com-550-documentation-manual-partsysshapemodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysShapeModule.html&#34;&gt;Shapeモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shape: Corn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleを出す形。Cornだと特定方向に向けた円錐状に出る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-corn.png&#34; alt=&#34;ShapeがCorn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Spehreで全方向に出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-sphere.png&#34; alt=&#34;ShapeがSphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hemisphereで片側だけ出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-hemisphere.png&#34; alt=&#34;ShapeがHemisphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;EdgeでY方向に直線上に出したりすることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-edge.png&#34; alt=&#34;ShapeがEdge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そのほかのパラメータはShapeに応じて設定する。&lt;/p&gt;

&lt;h3 id=&#34;rendererモジュール-https-docs-unity3d-com-550-documentation-manual-partsysrenderermodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysRendererModule.html&#34;&gt;Rendererモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Render Mode: Billboard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleがどのようにレンダリングされるか。Billboardは常にカメラに向くようにレンダリングされる。&lt;/p&gt;

&lt;p&gt;Stretched Billboardにするとカメラの方向に向きながら、&lt;a href=&#34;https://en.wikipedia.org/wiki/Squash_and_stretch&#34;&gt;stretch and squash&lt;/a&gt;させる。つまり速度を強調するように変形させる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-stretched-billboard.png&#34; alt=&#34;Render ModeがStretched Billboard&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material: None&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleのmaterial。これにDefault-Particleを指定するとこうなる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-default-particle.png&#34; alt=&#34;MaterialがDefault Particle&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;afterburner&#34;&gt;AfterBurner&lt;/h2&gt;

&lt;p&gt;Standard AssetsにあるAfterBurnerの設定を見てみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner.png&#34; alt=&#34;AfterBurner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;中央の濃い部分と、そのまわりの薄い部分の2つの設定を組み合わせている。
Explosionとかは9個組み合わせているので比較的シンプル。&lt;/p&gt;

&lt;p&gt;濃い部分ではEmissionのRate over Timeを80にすることで続いているように見えるようにして、
Size over LifetimeモジュールのSizeを徐々に小さくすることによって尾の方にかけて細くなるようにしている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-size.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;さらにColor over LifetimeモジュールのColorで両端のAlphaを0、Location 6.0%のAlphaを30に設定することで、
素早くフェードインし、徐々にフェードアウトするようにしている。&lt;/p&gt;

&lt;p&gt;また、Start SizeをRandom Between Two Constantsの(1.2, 1.4)に設定することで多少揺らいでいるように見せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-gradient.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;薄い部分ではEmissionのRate over Timeを60、ColorのLocation 6.0%のAlphaを8に設定して薄く見せている。
あとはSize over Lifetimeを設定し、Start SizeはRandom Between Two Constantsの(4,6)と大きく設定してある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>godocのメモ</title>
          <link>http://sambaiz.net/article/91/</link>
          <pubDate>Wed, 05 Apr 2017 22:11:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/91/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/godoc&#34;&gt;https://godoc.org/golang.org/x/tools/cmd/godoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;コメントからドキュメントを生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc cmd/fmt Printf
func Printf(format string, a ...interface{}) (n int, err error)
    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.

$ godoc -src cmd/fmt Printf
// Printf formats according to a format specifier and writes to standard output.
// It returns the number of bytes written and any write error encountered.
func Printf(format string, a ...interface{}) (n int, err error) {
    return Fprintf(os.Stdout, format, a...)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;記述対象の要素の名前から始まる、完全な文として&lt;a href=&#34;https://blog.golang.org/godoc-documenting-go-code&#34;&gt;コメントを書く&lt;/a&gt;。
インデントすれば整形した文になり、&lt;code&gt;Bug(ユーザー名):&lt;/code&gt;から始めればバグセクションにまとめられる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo bar package
package foo

import &amp;quot;fmt&amp;quot;

// Hoge returns &amp;quot;HOGE (input num)&amp;quot; string.
//   Hoge
//   Fuga
//   Piyo
// BUG(sambaiz): when passed 2, it panic.
func Hoge(num int) string {
	if num == 2 {
		panic(&amp;quot;AAAAAAAAHHHH&amp;quot;)
	}
	return fuga(&amp;quot;HOGE&amp;quot;, num)
}

// returns &amp;quot;(keyword) (num)&amp;quot; string
func fuga(keyword string, num int) string {
	return fmt.Sprintf(&amp;quot;%s %d&amp;quot;, keyword, num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#hdr-Examples&#34;&gt;例&lt;/a&gt;を&lt;code&gt;ExampleXXX&lt;/code&gt;のような関数に書いておくと、これもドキュメントに追加される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package foo

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;
)

func TestHoge(t *testing.T){
	...
}

func ExampleHoge() {
	fmt.Println(Hoge(1))
	// Output: HOGE 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Webサーバーを立ち上げてブラウザで確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ godoc -http=:6060 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じでfooパッケージのドキュメントが表示される。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:6060/pkg/github.com/sambaiz/godoctest/foo/&#34;&gt;http://localhost:6060/pkg/github.com/sambaiz/godoctest/foo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/91_godoc.png&#34; alt=&#34;godoc&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Nightmareでブラウザでの操作を自動化する</title>
          <link>http://sambaiz.net/article/90/</link>
          <pubDate>Wed, 29 Mar 2017 23:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/90/</guid>
          <description>&lt;p&gt;最近、&lt;a href=&#34;http://postwash.net/&#34;&gt;POSTWASH&lt;/a&gt;という洗濯代行サービスを使っている。
専用のカバンに詰めて集荷にきた人に渡すと、きれいに畳まれた洗濯ものが届く便利なサービスだ。
注文時にはWebのフォームから集荷、配達時間や支払い方法などを選ぶ必要があるんだけど、毎週のことなのでこれを自動化してみる。&lt;/p&gt;

&lt;p&gt;ブラウザの操作を自動化するのに&lt;a href=&#34;https://github.com/segmentio/nightmare&#34;&gt;Nightmare&lt;/a&gt;を使う。
&lt;a href=&#34;https://electron.atom.io/&#34;&gt;Electron&lt;/a&gt;を使っていて、&lt;a href=&#34;http://phantomjs.org/&#34;&gt;PahntomJS&lt;/a&gt;より2倍くらい速く、簡潔に書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install nightmare
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Nightmare()&lt;/code&gt;の引数に&lt;code&gt;show: true&lt;/code&gt;を渡すとウィンドウが開いて実行し始める。
これで確認画面までいくのであとは注文ボタンを押すだけ。
ウィンドウが閉じないように最後に&lt;code&gt;nightmare.end()&lt;/code&gt;を呼んでいない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const co = require(&#39;co&#39;);
const moment = require(&#39;moment&#39;)
const jst = +9
const Nightmare = require(&#39;nightmare&#39;);		
const nightmare = Nightmare({ 
  show: true,
  waitTimeout: 3000,
  gotoTimeout: 3000
});
const loginID = process.env.LOGIN_ID;
const loginPassword = process.env.LOGIN_PASSWORD;

moment.locale(&#39;ja&#39;);
const now = moment().utcOffset(jst)
const dayAfterTomorrow = now.add(2, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;);
const nextWeek = now.add(7, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;)
console.log(`${dayAfterTomorrow}~${nextWeek}`);

// IDとパスワードを入れてログイン
const login = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/accounts/&#39;)
  .type(&#39;#loginid&#39;, loginID)
  .insert(&#39;#loginpw&#39;, loginPassword) // .insert() is faster than .type() but does not trigger the keyboard events.
  .click(&#39;#submit&#39;)
  .wait(&#39;#yokoso&#39;)
  .evaluate(() =&amp;gt; document.querySelector(&#39;#yokoso h5&#39;).textContent);

// 注文フォームを埋めていく
const order = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/mypage/order.html&#39;)
  .wait(&#39;#item\\[4\\]&#39;)
  .check(&#39;#item\\[4\\]&#39;)
  .insert(&#39;#itemnum\\[4\\]&#39;, &#39;1&#39;)
  .select(&#39;#pickup_date_request&#39;, dayAfterTomorrow)
  .select(&#39;#pickup_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .wait(500) // #delivery_date_request が切り替わってしまうので少し待つ
  .select(&#39;#delivery_date_request&#39;, nextWeek)
  .select(&#39;#delivery_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .select(&#39;#payment&#39;, &#39;代金引換&#39;)
  .check(&#39;#agreement&#39;)
  .click(&#39;#submit&#39;)

co(function *(){
    yield login().then(
        (result) =&amp;gt; console.log(result), // ようこそ
        (err) =&amp;gt; console.log(err)
    );
    yield order();
    // yield nightmare.end();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでの文字コードの変換</title>
          <link>http://sambaiz.net/article/89/</link>
          <pubDate>Tue, 28 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/89/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/bnoordhuis/node-iconv&#34;&gt;node-iconv&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install iconv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SHIFT_JISからUTF-8への変換はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = new Buffer([
    0x8b, 0x8d, 
    0x8e, 0x4d, 
    0x26,
    0x82, 0xb2,
    0x94, 0xd1
]);

const iconv = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
console.log(`before: ${before.toString(&#39;hex&#39;)} ${before.toString()}`)
const after = iconv.convert(before);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;before: 8b8d8e4d2682b294d1 ���M&amp;amp;����
after:  e7899be79abf26e38194e9a3af 牛皿&amp;amp;ご飯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字コードによっては変換後に表せないことがある。
例えば、UTF-8からSHIFT_JISへの変換でサロゲートペア🍚を渡すと変換できず、エラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw errnoException(&#39;EILSEQ&#39;, &#39;Illegal character sequence.&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;//IGNORE&lt;/code&gt;を&lt;a href=&#34;https://www.npmjs.com/package/iconv#dealing-with-untranslatable-characters&#34;&gt;付ける&lt;/a&gt;ことで
そのような文字があった場合でもエラーにしないようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = &amp;quot;牛皿&amp;amp;🍚&amp;quot;;

const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
console.log(`before: ${new Buffer(before).toString(&#39;hex&#39;)} ${before.toString()}`)
const conv = iconv.convert(before);
const iconv2 = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
const after = iconv2.convert(conv);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変換できないものは無視される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before: e7899be79abf26f09f8d9a 牛皿&amp;amp;🍚
after:  e7899be79abf26 牛皿&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambdaでは&#34;&gt;Lambdaでは&lt;/h2&gt;

&lt;p&gt;Lambdaではインストールされているiconvコマンドを使うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new Promise((resolve, reject) =&amp;gt; {
    let filePath = &amp;quot;/tmp/shiftjis&amp;quot;;
    fs.writeFileSync(filePath, shiftjis);
    var exec = require(&#39;child_process&#39;).exec;
    var cmd = `iconv -c -f sjis -t utf-8 ${filePath}`;
    var child = exec(cmd, (err, stdout, stderr) =&amp;gt; {
      if (err) reject(err);
      else resolve(stdout);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bokukoko.info/entry/2015/08/30/AWS_Lambda%E5%86%85%E3%81%A7%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95&#34;&gt;AWS Lambda内で文字コードを変換する方法 - ボクココ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HoloLensのSharing</title>
          <link>http://sambaiz.net/article/88/</link>
          <pubDate>Sat, 25 Mar 2017 22:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/88/</guid>
          <description>

&lt;ul&gt;
&lt;li&gt;HoloToolkit-Unity v1.5.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;サーバー&#34;&gt;サーバー&lt;/h2&gt;

&lt;p&gt;SharingService.exeを
&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/tree/v1.5.5.0/External/HoloToolkit/Sharing/Server&#34;&gt;ここ&lt;/a&gt;
からとってきて実行する。開発に使っているHoloToolkitと同じリリースバージョンのものを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; SharingService.exe -local
...
SharingService: Listening for session list connections on port 20602 of all network devices of the local machine.
SharingService: Local IP addresses are:
SharingService:         xxx.xxx.xxx.xxx
SharingService: Created Session &amp;quot;Default&amp;quot; with ID 0 on port 20601
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今日のTokyo Hololens Meetup Vol.2の開発者セッションで、
ちょうどSharingの話があったのだけれど、残念ながら先着順で出遅れて聞けなかった。&lt;/p&gt;

&lt;p&gt;Tweetを見る限りだとカスタマイズできず、スケーリングできないSharingService.exeは使わずに
&lt;a href=&#34;https://github.com/neuecc/MagicOnion&#34;&gt;MagicOnion&lt;/a&gt;というのを自前で作ったらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://togetter.com/li/1094037&#34;&gt;Tokyo Hololens MeetuUp Vol.2 Session5 #HoloLensJP #TMCN - Togetterまとめ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;クライアント-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing&#34;&gt;クライアント&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Assets/HoloToolkit/Sharing/Tests&lt;/code&gt;のSceneで試してみる。&lt;/p&gt;

&lt;p&gt;以下のcapabilitiesを設定し、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SpatialPerception&lt;/li&gt;
&lt;li&gt;InternetClient&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharingのServer Addressを設定してビルド。ほかにはこんな設定がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingStage.cs#L15&#34;&gt;Client Role&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Primary: 直接セッションサーバーに接続し、セッションを管理する&lt;/li&gt;
&lt;li&gt;Secondary: Primaryクライアントに接続して、セッション管理は任せる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Server Address&lt;/li&gt;
&lt;li&gt;Port&lt;/li&gt;
&lt;li&gt;Auto Discover Server&lt;/li&gt;
&lt;li&gt;Session Name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;起動して以下のようなエラーが出たらSharingService.exeがHoloToolkitのバージョンと合っていない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List Server Handshake Failed: Invalid schema version.
Expected: 17, got 15
Please sync to latest XTools
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接続と離脱のメッセージはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SharingService: User UnknownUser at address xxx.xxx.xxx.xxx joined session Default
SharingService: User UnknownUser left session Default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2つ以上クライアントを立ち上げると、他のクライアントの、球からの相対的な頭の位置にCubeが映った。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/88-sharing.jpg&#34; alt=&#34;他のクライアントの頭の位置にCubeがある&#34; /&gt;&lt;/p&gt;

&lt;p&gt;が、球の場所が空間に対して同期されない・・・。&lt;/p&gt;

&lt;p&gt;原因を探るために、
TestsのSceneと同様に、SharingのPrefabにCustomMessage.csを、
適当なGameObjectにImportExportAnchorManager.csとRemoteHeadManager.csと
目印になるオブジェクトを追加し、
ImportExportAnchorManager.csにこんな感じのを追加してcurrentStateを表示してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public GameObject statusText;
private void Update()
{
    statusText.GetComponent&amp;lt;TextMesh&amp;gt;().text = currentState.ToString();
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、起動してからまだReady状態になっていなかったことが分かった。
少し待ってみるといろんな状態を経て、Ready状態になると、
目印のオブジェクトが物理的に同じところに移動し、頭の位置も正しいところに移動した。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/88-sharing2.png&#34; alt=&#34;Sharingしている状態&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;なにをやっているか見ていく。&lt;/p&gt;

&lt;p&gt;まずは拾えるevent。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/83/&#34;&gt;C#のdelegateとevent - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sharingsessiontracker-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-scripts-sharingsessiontracker-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingSessionTracker.cs&#34;&gt;SharingSessionTracker&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler&lt;SessionJoinedEventArgs&gt; SessionJoined;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ユーザーがセッションに入ったとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SessionJoinedEventArgs : EventArgs
{
    public User joiningUser;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler&lt;SessionLeftEventArgs&gt; SessionLeft;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;セッションから出たとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SessionLeftEventArgs : EventArgs
{
    public long exitingUserId;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sharingstage-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-scripts-sharingstage-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Scripts/SharingStage.cs&#34;&gt;SharingStage&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;public event EventHandler SharingManagerConnected;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SharingManagerが接続されたとき。ArgsはEmpty。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;connectedEvent(this, EventArgs.Empty);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;これらのeventをsubscribeしているTestsの中のコード。&lt;/p&gt;

&lt;h2 id=&#34;custommessages-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-custommessages-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/CustomMessages.cs&#34;&gt;CustomMessages&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;データを送受信するところ。&lt;/p&gt;

&lt;h3 id=&#34;初期化-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-custommessages-cs-l57&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/CustomMessages.cs#L57&#34;&gt;初期化&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SharingManagerが接続されたら初期化がはじまる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Start()
{
    SharingStage.Instance.SharingManagerConnected += SharingManagerConnected;
}

private void SharingManagerConnected(object sender, EventArgs e)
{
    InitializeMessageHandlers();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、ServerとのConnectionを取得し、Messageを受信したときのeventをsubscribeしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SharingStage sharingStage = SharingStage.Instance;
serverConnection = sharingStage.Manager.GetServerConnection();
connectionAdapter = new NetworkConnectionAdapter();
connectionAdapter.MessageReceivedCallback += OnMessageReceived;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それから自分自身のユーザーIDも保存してある。これはMessageを送るときに使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;localUserID = SharingStage.Instance.Manager.GetLocalUser().GetID();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に&lt;code&gt;MessageHandlers&lt;/code&gt;にnullを詰めて終わり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (byte index = (byte)TestMessageID.HeadTransform; index &amp;lt; (byte)TestMessageID.Max; index++)
{
    if (MessageHandlers.ContainsKey((TestMessageID)index) == false)
    {
        MessageHandlers.Add((TestMessageID)index, null);
    }

    serverConnection.AddListener(index, connectionAdapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後からこういう風にhandlerを設定している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CustomMessages.Instance.MessageHandlers[CustomMessages.TestMessageID.HeadTransform] = this.UpdateHeadTransform;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;受信&#34;&gt;受信&lt;/h3&gt;

&lt;p&gt;messageTypeに対応したhandlerに渡す。初期状態では全てnullなので何もしない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void OnMessageReceived(NetworkConnection connection, NetworkInMessage msg)
{
    byte messageType = msg.ReadByte();
    MessageCallback messageHandler = MessageHandlers[(TestMessageID)messageType];
    if (messageHandler != null)
    {
        messageHandler(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;送信&#34;&gt;送信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CustomMessages.Instance.SendStageTransform(transform.localPosition, transform.localRotation);
CustomMessages.Instance.SendHeadTransform(headPosition, headRotation);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにBroadcastしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void SendHeadTransform(Vector3 position, Quaternion rotation)
{
    // If we are connected to a session, broadcast our head info
    if (serverConnection != null &amp;amp;&amp;amp; serverConnection.IsConnected())
    {
        // Create an outgoing network message to contain all the info we want to send
        NetworkOutMessage msg = CreateMessage((byte)TestMessageID.HeadTransform);

        AppendTransform(msg, position, rotation);

        // Send the message as a broadcast, which will cause the server to forward it to all other users in the session.
        serverConnection.Broadcast(
            msg,
            MessagePriority.Immediate,
            MessageReliability.UnreliableSequenced,
            MessageChannel.Avatar);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;importexportanchormanager-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-importexportanchormanager-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/ImportExportAnchorManager.cs&#34;&gt;ImportExportAnchorManager&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オブジェクトのpositionを物理的に固定する&lt;a href=&#34;https://docs.unity3d.com/ScriptReference/VR.WSA.WorldAnchor.html&#34;&gt;WorldAnchor&lt;/a&gt;を共有する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;currentState&lt;/code&gt;は最初&lt;code&gt;AnchorStore_Initializing&lt;/code&gt;で、
&lt;code&gt;anchorStore&lt;/code&gt;が取得できたら&lt;code&gt;AnchorStore_Initialized&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ImportExportState currentState = ImportExportState.Start;

// インスタンスがロードされたときに呼ばれる。コンストラクターの代わり
protected override void Awake()
{
    base.Awake();
    Debug.Log(&amp;quot;Import Export Manager starting&amp;quot;);
    // We need to get our local anchor store started up.
    currentState = ImportExportState.AnchorStore_Initializing;
    WorldAnchorStore.GetAsync(AnchorStoreReady);
}

private void AnchorStoreReady(WorldAnchorStore store)
{
    anchorStore = store;
    currentState = ImportExportState.AnchorStore_Initialized;
}

private void Start()
{
    SharingStage.Instance.SharingManagerConnected += SharingManagerConnected;
    SharingSessionTracker.Instance.SessionJoined += Instance_SessionJoined;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SharingManagerが接続されたら、RoomManagerのインスタンスを取得して、
Anchorのダウンロードとアップロードしたときのeventをsubscribeしている。&lt;/p&gt;

&lt;p&gt;Uploaded時は&lt;code&gt;currentState&lt;/code&gt;を&lt;code&gt;Ready&lt;/code&gt;にし、
Downloaded時は&lt;code&gt;rawAnchorData&lt;/code&gt;に保存し、&lt;code&gt;currentState&lt;/code&gt;を&lt;code&gt;DataReady&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void SharingManagerConnected(object sender, EventArgs e)
{
    // Setup the room manager callbacks.
    roomManager = SharingStage.Instance.Manager.GetRoomManager();
    roomManagerCallbacks = new RoomManagerAdapter();

    roomManagerCallbacks.AnchorsDownloadedEvent += RoomManagerCallbacks_AnchorsDownloaded;
    roomManagerCallbacks.AnchorUploadedEvent += RoomManagerCallbacks_AnchorUploaded;
    roomManager.AddListener(roomManagerCallbacks);
}

private void RoomManagerCallbacks_AnchorUploaded(bool successful, XString failureReason)
{
    if (successful)
    {
        currentState = ImportExportState.Ready;
    }
    else
    {
        Debug.Log(&amp;quot;Upload failed &amp;quot; + failureReason);
        currentState = ImportExportState.Failed;
    }
}

private byte[] rawAnchorData = null;

private void RoomManagerCallbacks_AnchorsDownloaded(bool successful, AnchorDownloadRequest request, XString failureReason)
{
    // If we downloaded anchor data successfully we should import the data.
    if (successful)
    {
        int datasize = request.GetDataSize();
        Debug.Log(datasize + &amp;quot; bytes &amp;quot;);
        rawAnchorData = new byte[datasize];

        request.GetData(rawAnchorData, datasize);
        currentState = ImportExportState.DataReady;
    }
    else
    {
        // If we failed, we can ask for the data again.
        Debug.Log(&amp;quot;Anchor DL failed &amp;quot; + failureReason);
        MakeAnchorDataRequest();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SessionJoin時には、&lt;code&gt;sharingServiceReady&lt;/code&gt;をtrueにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;InitRoomApi()&lt;/code&gt;では&lt;code&gt;currentRoom&lt;/code&gt;にJoin(あるいは新しく作る)し、Roomを代入している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;currentState&lt;/code&gt;は新しくRoomを作った場合&lt;code&gt;InitialAnchorRequired&lt;/code&gt;で、すでにあるRoomに入った場合&lt;code&gt;RoomApiInitialized&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private bool sharingServiceReady = false;
private Room currentRoom;

private void Instance_SessionJoined(object sender, SharingSessionTracker.SessionJoinedEventArgs e)
{
    SharingSessionTracker.Instance.SessionJoined -= Instance_SessionJoined;

    // ほかの処理が落ち着くまで5秒待って実行する
    Invoke(&amp;quot;MarkSharingServiceReady&amp;quot;, 5);
}

private void MarkSharingServiceReady()
{
    sharingServiceReady = true;

#if UNITY_EDITOR || UNITY_STANDALONE
    InitRoomApi();
#endif
}

private void InitRoomApi()
{
    if (roomManager.GetRoomCount() == 0)
    {
        if (LocalUserHasLowestUserId())
        {
            Debug.Log(&amp;quot;Creating room &amp;quot;);            
            currentRoom = roomManager.CreateRoom(new XString(&amp;quot;DefaultRoom&amp;quot;), roomID, false);
            currentState = ImportExportState.InitialAnchorRequired;
        }
    }
    else
    {
        Debug.Log(&amp;quot;Joining room &amp;quot;);
        currentRoom = roomManager.GetRoom(0);
        roomManager.JoinRoom(currentRoom);
        currentState = ImportExportState.RoomApiInitialized;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update。ここで&lt;code&gt;currentState&lt;/code&gt;を見ている。ここまでの&lt;code&gt;currentState&lt;/code&gt;をまとめると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AnchorStore_Initializing: 初期状態&lt;/li&gt;
&lt;li&gt;AnchorStore_Initialized: AnchorStore取得完了&lt;/li&gt;
&lt;li&gt;InitialAnchorRequired: 新しくRoomを作った(のでWorldAnchorを生成する)&lt;/li&gt;
&lt;li&gt;RoomApiInitialized: すでにあるRoomに入った&lt;/li&gt;
&lt;li&gt;Ready: Upload完了&lt;/li&gt;
&lt;li&gt;DataReady: Download完了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Update()
{
    switch (currentState)
    {
        case ImportExportState.AnchorStore_Initialized:
            if (sharingServiceReady)
            {
                InitRoomApi();
            }
            break;
        case ImportExportState.RoomApiInitialized:
            StartAnchorProcess();
            break;
        case ImportExportState.DataReady:
            // DataReady is set when the anchor download completes.
            currentState = ImportExportState.Importing;
            WorldAnchorTransferBatch.ImportAsync(rawAnchorData, ImportComplete);
            break;
        case ImportExportState.InitialAnchorRequired:
            currentState = ImportExportState.CreatingInitialAnchor;
            CreateAnchorLocally();
            break;
        case ImportExportState.ReadyToExportInitialAnchor:
            // We&#39;ve created an anchor locally and it is ready to export.
            currentState = ImportExportState.UploadingInitialAnchor;
            Export();
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Roomを新しく作ったならWorldAnchorを作成する必要がある。
&lt;a href=&#34;https://docs.unity3d.com/ScriptReference/VR.WSA.WorldAnchor-isLocated.html&#34;&gt;isLocated&lt;/a&gt;がtrueになったら
&lt;code&gt;OnTrackingChanged_InitialAnchor&lt;/code&gt;にし、AnchorをUploadする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void CreateAnchorLocally()
{
    WorldAnchor anchor = GetComponent&amp;lt;WorldAnchor&amp;gt;();
    if (anchor == null)
    {
        anchor = gameObject.AddComponent&amp;lt;WorldAnchor&amp;gt;();
    }

    if (anchor.isLocated)
    {
        currentState = ImportExportState.ReadyToExportInitialAnchor;
    }
    else
    {
        anchor.OnTrackingChanged += Anchor_OnTrackingChanged_InitialAnchor;
    }
}

private void Anchor_OnTrackingChanged_InitialAnchor(WorldAnchor self, bool located)
{
    if (located)
    {
        Debug.Log(&amp;quot;Found anchor, ready to export&amp;quot;);
        currentState = ImportExportState.ReadyToExportInitialAnchor;
    }
    else
    {
        Debug.Log(&amp;quot;Failed to locate local anchor (super bad!)&amp;quot;);
        currentState = ImportExportState.Failed;
    }

    self.OnTrackingChanged -= Anchor_OnTrackingChanged_InitialAnchor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;anchorStore&lt;/code&gt;に保存して、SerializeしてUploadする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Export()
{
    WorldAnchor anchor = GetComponent&amp;lt;WorldAnchor&amp;gt;();

    string guidString = Guid.NewGuid().ToString();
    exportingAnchorName = guidString;

    // Save the anchor to our local anchor store.
    if (anchorStore.Save(exportingAnchorName, anchor))
    {
        sharedAnchorInterface = new WorldAnchorTransferBatch();
        sharedAnchorInterface.AddWorldAnchor(guidString, anchor);
        WorldAnchorTransferBatch.ExportAsync(sharedAnchorInterface, WriteBuffer, ExportComplete);
    }
    else
    {
        Debug.Log(&amp;quot;This anchor didn&#39;t work, trying again&amp;quot;);
        currentState = ImportExportState.InitialAnchorRequired;
    }
}

public void ExportComplete(SerializationCompletionReason status)
{
    if (status == SerializationCompletionReason.Succeeded &amp;amp;&amp;amp; exportingAnchorBytes.Count &amp;gt; minTrustworthySerializedAnchorDataSize)
    {
        Debug.Log(&amp;quot;Uploading anchor: &amp;quot; + exportingAnchorName);
        roomManager.UploadAnchor(
            currentRoom,
            new XString(exportingAnchorName),
            exportingAnchorBytes.ToArray(),
            exportingAnchorBytes.Count);
    }
    else
    {
        Debug.Log(&amp;quot;This anchor didn&#39;t work, trying again&amp;quot;);
        currentState = ImportExportState.InitialAnchorRequired;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もしすでにあるRoomにJoinしている(&lt;code&gt;RoomApiInitialized&lt;/code&gt;)なら、Anchorをダウンロードし始め、&lt;code&gt;DataRequested&lt;/code&gt;になる。
ダウンロードしたら&lt;code&gt;DataReady&lt;/code&gt;になって、AnchorデータをImportする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void StartAnchorProcess()
{
    // First, are there any anchors in this room?
    int anchorCount = currentRoom.GetAnchorCount();

    // If there are anchors, we should attach to the first one.
    if (anchorCount &amp;gt; 0)
    {
        // Extract the name of the anchor.
        XString storedAnchorString = currentRoom.GetAnchorName(0);
        string storedAnchorName = storedAnchorString.GetString();

        // Attempt to attach to the anchor in our local anchor store.
        if (AttachToCachedAnchor(storedAnchorName) == false)
        {
            MakeAnchorDataRequest();
        }
    }
}

private void MakeAnchorDataRequest()
{
    if (roomManager.DownloadAnchor(currentRoom, currentRoom.GetAnchorName(0)))
    {
        currentState = ImportExportState.DataRequested;
    }
    else
    {
        Debug.Log(&amp;quot;Couldn&#39;t make the download request.&amp;quot;);
        currentState = ImportExportState.Failed;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Import完了したら&lt;code&gt;anchorStore&lt;/code&gt;に保存し、&lt;code&gt;Ready&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void ImportComplete(SerializationCompletionReason status, WorldAnchorTransferBatch wat)
{
    if (status == SerializationCompletionReason.Succeeded &amp;amp;&amp;amp; wat.GetAllIds().Length &amp;gt; 0)
    {
        Debug.Log(&amp;quot;Import complete&amp;quot;);

        string first = wat.GetAllIds()[0];
        Debug.Log(&amp;quot;Anchor name: &amp;quot; + first);

        WorldAnchor anchor = wat.LockObject(first, gameObject);
        anchorStore.Save(first, anchor);
        currentState = ImportExportState.Ready;
    }
    else
    {
        Debug.Log(&amp;quot;Import fail&amp;quot;);
        currentState = ImportExportState.DataReady;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remoteheadmanager-https-github-com-microsoft-holotoolkit-unity-blob-v1-5-5-0-assets-holotoolkit-sharing-tests-remoteheadmanager-cs&#34;&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/v1.5.5.0/Assets/HoloToolkit/Sharing/Tests/RemoteHeadManager.cs&#34;&gt;RemoteHeadManager&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;他のユーザーの頭の位置にオブジェクトを表示させる。&lt;/p&gt;

&lt;p&gt;受信時のhandlerを設定し、eventをsubscribeする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Start()
{
    CustomMessages.Instance.MessageHandlers[CustomMessages.TestMessageID.HeadTransform] = this.UpdateHeadTransform;

    SharingSessionTracker.Instance.SessionJoined += Instance_SessionJoined;
    SharingSessionTracker.Instance.SessionLeft += Instance_SessionLeft;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;joinしたのが自分自身じゃないかチェック。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Instance_SessionJoined(object sender, SharingSessionTracker.SessionJoinedEventArgs e)
{
    if (e.joiningUser.GetID() != SharingStage.Instance.Manager.GetLocalUser().GetID())
    {
        GetRemoteHeadInfo(e.joiningUser.GetID());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remoteHeads&lt;/code&gt;になければ、HeadObjectを作成し、追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public RemoteHeadInfo GetRemoteHeadInfo(long userID)
{
    RemoteHeadInfo headInfo;

    // Get the head info if its already in the list, otherwise add it
    if (!this.remoteHeads.TryGetValue(userID, out headInfo))
    {
        headInfo = new RemoteHeadInfo();
        headInfo.UserID = userID;
        headInfo.HeadObject = CreateRemoteHead();

        this.remoteHeads.Add(userID, headInfo);
    }

    return headInfo;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sessionから離れたときはオブジェクトを削除し、remoteHeadsから取り除く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void Instance_SessionLeft(object sender, SharingSessionTracker.SessionLeftEventArgs e)
{
    if (e.exitingUserId != SharingStage.Instance.Manager.GetLocalUser().GetID())
    {
        RemoveRemoteHead(this.remoteHeads[e.exitingUserId].HeadObject);
        this.remoteHeads.Remove(e.exitingUserId);
    }
}

void RemoveRemoteHead(GameObject remoteHeadObject)
{
    DestroyImmediate(remoteHeadObject);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;受信時のhandlerではMessageからpositionとquarternionを取得し、オブジェクトの位置を動かしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void UpdateHeadTransform(NetworkInMessage msg)
{
    // Parse the message
    long userID = msg.ReadInt64();

    Vector3 headPos = CustomMessages.Instance.ReadVector3(msg);

    Quaternion headRot = CustomMessages.Instance.ReadQuaternion(msg);

    RemoteHeadInfo headInfo = GetRemoteHeadInfo(userID);
    headInfo.HeadObject.transform.localPosition = headPos;
    headInfo.HeadObject.transform.localRotation = headRot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分の頭の位置はUpdate()で送信している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Update()
{
    // Grab the current head transform and broadcast it to all the other users in the session
    Transform headTransform = Camera.main.transform;

    // Transform the head position and rotation from world space into local space
    Vector3 headPosition = this.transform.InverseTransformPoint(headTransform.position);
    Quaternion headRotation = Quaternion.Inverse(this.transform.rotation) * headTransform.rotation;

    CustomMessages.Instance.SendHeadTransform(headPosition, headRotation);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ライセンス&#34;&gt;ライセンス&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;MIT License

Copyright (c) 2016 Microsoft Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &amp;quot;Software&amp;quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &amp;quot;AS IS&amp;quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unixのパイプをmkfifo()で作ってdup2()で標準出力にコピーして書き込む</title>
          <link>http://sambaiz.net/article/87/</link>
          <pubDate>Fri, 24 Mar 2017 22:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/87/</guid>
          <description>

&lt;h2 id=&#34;パイプとは&#34;&gt;パイプとは&lt;/h2&gt;

&lt;p&gt;Unixでプロセス間通信するためのもの。シェルで使う&lt;code&gt;|&lt;/code&gt;は無名パイプ。
&lt;code&gt;mkfifo()&lt;/code&gt;システムコールで名前付きパイプを作成でき、これを読み書きすることで任意のプロセス間でやりとりできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkfifo hoge
$ ls -lh
$ prw-r--r-- ... 0B ... hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常のファイルと同様に読み書きすることができ、読み書きどちらかを行おうとすると待つことになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo hoge &amp;amp; # 読まれるまで待つ
$ cat hoge
aaaaa
[1]+  Done                    echo &amp;quot;aaaaa&amp;quot; &amp;gt; hoge

$ cat hoge &amp;amp; # 書かれるまで待つ
$ echo &amp;quot;bbbbb&amp;quot; &amp;gt; hoge
bbbbb
[1]+  Done                    cat hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルディスクリプタをコピーするシステムコール&lt;code&gt;dup2()&lt;/code&gt;でopenしたパイプを標準出力(1)にコピーしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int main(){
  int fd = open(&amp;quot;./hoge&amp;quot;, O_WRONLY);
  if(fd &amp;lt; 0){
    printf(&amp;quot;fail to open\n&amp;quot;);
    return 1;
  }

  printf(&amp;quot;OPEN %d \n&amp;quot;, fd);

  if(dup2(fd, 1) &amp;lt; 0){
    printf(&amp;quot;fail to dup2\n&amp;quot;);
    return 2;
  }

  printf(&amp;quot;WRITE\n&amp;quot;); // これがどこに書き込まれるか

  close(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後のprintfの内容は標準出力ではなく、パイプに書き込まれていることがわかる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a.out &amp;amp;
$ echo &amp;quot;read `cat hoge` from pipe&amp;quot;
OPEN 3 
read WRITE from pipe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%91%E3%82%A4%E3%83%97_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)#.E3.83.97.E3.83.AD.E3.82.B0.E3.83.A9.E3.83.A0.E3.81.AB.E3.82.88.E3.82.8B.E3.83.91.E3.82.A4.E3.83.97.E3.81.AE.E4.BD.9C.E6.88.90&#34;&gt;パイプ (コンピュータ) - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/richmikan@github/items/bb660a58690ac01ec295&#34;&gt;mkfifoコマンドって使ってますか？ - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/stc1988/items/9354204d3c2ff210512b&#34;&gt;リダイレクトの挙動 - Qiita&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CuratorでElasticsearchの古いindexを削除する</title>
          <link>http://sambaiz.net/article/86/</link>
          <pubDate>Wed, 22 Mar 2017 00:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/86/</guid>
          <description>

&lt;h2 id=&#34;curatorとは-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-index-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/index.html&#34;&gt;Curatorとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;indexやsnapshotを管理するのに使えるツール。&lt;/p&gt;

&lt;h2 id=&#34;インストール-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-installation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/installation.html&#34;&gt;インストール&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;インストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/yum.repos.d/curator.repo
[curator-4]
name=CentOS/RHEL 7 repository for Elasticsearch Curator 4.x packages
baseurl=http://packages.elastic.co/curator/4/centos/7
gpgcheck=1
gpgkey=http://packages.elastic.co/GPG-KEY-elasticsearch
enabled=1

$ yum install -y elasticsearch-curator
$ curator --version
curator, version 4.2.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-configfile-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/configfile.html&#34;&gt;config&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;configファイルを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client:
  hosts:
    - 127.0.0.1
  port: 9200

logging:
  loglevel: INFO
  logfile:
  logformat: default
  blacklist: [&#39;elasticsearch&#39;, &#39;urllib3&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;action-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-actions-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/actions.html&#34;&gt;action&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;今回はindexを削除するので&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/ex_delete_indices.html&#34;&gt;delete_indices&lt;/a&gt;。
対象は&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/filters.html&#34;&gt;filter&lt;/a&gt;で指定する。
logstash formatだとhogehoge-2017.01.01のようなindex名になるので&lt;code&gt;%Y.%m.%d&lt;/code&gt;。&lt;code&gt;okder than 3 days&lt;/code&gt;のものを削除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actions:
  1:
    action: delete_indices
    description: &amp;gt;-
      3日前より古いhogehoge-* indexを消す
    filters:
    - filtertype: pattern
      kind: prefix
      value: hogehoge-
    - filtertype: age
      source: name
      direction: older
      timestring: &#39;%Y.%m.%d&#39;
      unit: days
      unit_count: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行-https-www-elastic-co-guide-en-elasticsearch-client-curator-current-command-line-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/command-line.html&#34;&gt;実行&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;configとactionファイルを指定して実行する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curator --config curator_config.yml curator_action.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毎日00:05に実行するようにしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l
5 0 * * * curator --config curator_config.yml curator_action.yml
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでRxをはじめる</title>
          <link>http://sambaiz.net/article/85/</link>
          <pubDate>Sat, 18 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/85/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;https://github.com/ReactiveX/rxjs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rx-reactivex-とは-http-reactivex-io-intro-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Rx(ReactiveX)とは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;非同期処理をうまく扱えるようにするライブラリ。いろんな言語で実装されている。
非同期処理の結果はObservableなStreamに流される。
ObservableはIteratableのように扱うことができる。&lt;/p&gt;

&lt;p&gt;Rxは&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;Observer pattern&lt;/a&gt;
を拡張したもの。
Observer patternというのは、Subjectが、Observeしている全てのObserverに対して通知を送るデザインパターン。
C#などのeventのそれ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/83/&#34;&gt;C#のdelegateとevent - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;inputのkeyupイベントのObservableを作成し、それを&lt;code&gt;subscribe()&lt;/code&gt;して出力している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input&amp;quot; /&amp;gt;

&amp;lt;script&amp;gt;

const inputForm = document.querySelector(&#39;#input&#39;);

const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err)
);

&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力するとこんなのが出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;b&amp;quot;, code: &amp;quot;KeyB&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;c&amp;quot;, code: &amp;quot;KeyC&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;observable-http-reactivex-io-rxjs-class-es6-observable-js-observable-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html&#34;&gt;Observable&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;create-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-create&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-create&#34;&gt;create&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;でObservableに値をemitし、&lt;code&gt;complete()&lt;/code&gt;で終了させる。
&lt;code&gt;error()&lt;/code&gt;でエラーをemitするとそれ以後の値はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.create(function (observer) {
    observer.next(&amp;quot;AAAAA&amp;quot;);
    observer.next(&amp;quot;BBBBB&amp;quot;);
    observer.next(&amp;quot;CCCCC&amp;quot;);
    observer.complete();
}).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;AAAA
BBBB
CCCC
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;from-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-from&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from&#34;&gt;from&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;配列などのIteratableをObservableに変換する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.from([1,2,3]).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
2
3
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fromevent-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-fromevent&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent&#34;&gt;fromEvent&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上で使ったやつ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromEvent(document.querySelector(&#39;#input&#39;), &#39;keyup&#39;).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;frompromise-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-frompromise&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromPromise&#34;&gt;fromPromise&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;PromiseもObservableに変換できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromPromise(Promise.resolve(&amp;quot;ok&amp;quot;)).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ok
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interval-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-interval&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-interval&#34;&gt;interval&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一定時間ごとにemitし続ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.interval(1000).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/100/&#34;&gt;RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest) - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;operator-http-reactivex-io-rxjs-manual-overview-html-operators&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/manual/overview.html#operators&#34;&gt;Operator&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observableのメソッド。新しいObservableを作って返す。&lt;/p&gt;

&lt;p&gt;上で試したkeyupのObservableにいろいろやってみる。&lt;/p&gt;

&lt;h3 id=&#34;pluck-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-pluck&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-pluck&#34;&gt;pluck&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;nestされたプロパティを指定する。この例だと&lt;code&gt;.target.value&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;h
ho
hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-filter&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-filter&#34;&gt;filter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;フィルタリングする。この例だと長さが2より大きいものだけがemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 );
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-map&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map&#34;&gt;map&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;map。この例だと&lt;code&gt;value: ${text}&lt;/code&gt;のフォーマットでemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;value: hog
value: hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-reduce&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce&#34;&gt;reduce&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;reduce。emitされるのはcompleteされたときなので、&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-takeUntil&#34;&gt;takeUntil()&lt;/a&gt;で
渡したObservableが何かemitしたときにcompleteさせるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .takeUntil(Rx.Observable.interval(5000))
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`)
  .reduce((acc, curr) =&amp;gt; `${acc} ${curr}`, &amp;quot;&amp;quot;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err),
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; value: aaa value: aaaa value: aaaaa value: aaaaaa value: aaaaaaa value: aaaaaaaa value: aaaaaaaaa value: aaaaaaaaaa value: aaaaaaaaaaa
 completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subject-http-reactivex-io-documentation-subject-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/documentation/subject.html&#34;&gt;Subject&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observerでもあり、Observableでもあるブリッジのようなもの。&lt;/p&gt;

&lt;p&gt;これまでのObservableはSubscribeされるまでemitしない&amp;rdquo;Cold&amp;rdquo;なものだったが、
SubjectはそんなObservableをSubscribeし、それをトリガーにemitするので、
&amp;ldquo;Cold&amp;rdquo;なObservableを常にemitし得る&amp;rdquo;Hot&amp;rdquo;なものに変えることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ColdなObservable
const cold = Rx.Observable.from([1,2,3]);

// Coldだと、いつから、何回読んでも同じ値が得られる

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data), 
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;publish-subject&#34;&gt;(Publish)Subject&lt;/h3&gt;

&lt;p&gt;Subscribeした時点からemitされたアイテムをemitする。それまでにemitされたアイテムはしない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.Subject(); 

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;) // 1: AAA

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;BBB&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
2: BBB
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asyncsubject&#34;&gt;AsyncSubject&lt;/h3&gt;

&lt;p&gt;complete時に最後にemitされた値だけをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.AsyncSubject();

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;); 
subject.next(&amp;quot;BBB&amp;quot;);

subject.complete();

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: BBB
1: completed
2: BBB
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;behaviorsubject&#34;&gt;BehaviorSubject&lt;/h3&gt;

&lt;p&gt;Subscribeしたとき、最近のアイテムをemitする。あとはSubjectと同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.BehaviorSubject(&amp;quot;ZZZ&amp;quot;)

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;CCC&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: ZZZ
1: AAA
1: BBB
2: BBB
1: CCC
2: CCC
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;replaysubject&#34;&gt;ReplaySubject&lt;/h3&gt;

&lt;p&gt;いつSubscribeしてもbufferにある全てのアイテムをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.ReplaySubject(2) // buffer size = 2

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);
subject.next(&amp;quot;CCC&amp;quot;);
subject.next(&amp;quot;DDD&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buffer size = 2 なので2がSubscribeしたときにはAAAとBBBはもうない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
1: CCC
1: DDD
2: CCC
2: DDD
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/wilfrem/tech-rxjs&#34;&gt;歌舞伎座tech発表資料 RxJSの中を追う&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>FluentdとKPL(Kinesis Producer Library)でログをまとめてスループットを稼ぐ</title>
          <link>http://sambaiz.net/article/84/</link>
          <pubDate>Wed, 15 Mar 2017 23:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/84/</guid>
          <description>

&lt;h2 id=&#34;kpl-kinesis-producer-library-とは&#34;&gt;KPL(Kinesis Producer Library)とは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/streams/latest/dev/developing-producers-with-kpl.html&#34;&gt;Developing Amazon Kinesis Streams Producers Using the Amazon Kinesis Producer Library - Amazon Kinesis Streams&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kinesisに送るとき、自動リトライしてくれたり、レコードをまとめてスループットを向上してくれたりするアプリケーション。Protobufを使っている。
普通に送るとどんなに小さくてもシャード*1000レコード/秒しか最大でPUTできないのを、KPLを使ってまとめることで増やすことができる。&lt;/p&gt;

&lt;h2 id=&#34;fluentdで送る&#34;&gt;fluentdで送る&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;で&lt;code&gt;kinesis_producer&lt;/code&gt;を指定するとKPLを使って送信する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;kinesis_producer&amp;gt;&lt;/code&gt;の中にKPLの設定を書くことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;kinesis_producer&amp;gt;
    record_max_buffered_time 10
&amp;lt;/kinesis_producer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L239&#34;&gt;record_max_bufferd_time&lt;/a&gt;
はバッファされたレコードが送られるまでの最大時間(ms)。デフォルトは100ms。この時間が経つか、他のリミットに当たったらレコードは送られる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L30&#34;&gt;AggregationMaxCount&lt;/a&gt;: 一つのレコードにまとめる最大レコード数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L44&#34;&gt;AggregationMaxSize&lt;/a&gt;: まとめたレコードの最大バイト数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L54&#34;&gt;CollectionMaxCount&lt;/a&gt;: PutRecordsで送る最大アイテム数&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L67&#34;&gt;CollectionMaxSize&lt;/a&gt;: PutRecordsで送るデータ量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudWatchに送る&lt;a href=&#34;https://github.com/awslabs/amazon-kinesis-producer/blob/v0.10.2/java/amazon-kinesis-producer-sample/default_config.properties#L158&#34;&gt;metrics_level&lt;/a&gt;はデフォルトでdetailedになっていて、
コンソールのメトリクスからstream名で検索すると
&lt;code&gt;KinesisProducerLibrary&lt;/code&gt;に&lt;code&gt;UserRecordsPerKinesisRecord&lt;/code&gt;や、&lt;code&gt;UserRecordsDataPut&lt;/code&gt;、&lt;code&gt;BufferingTime&lt;/code&gt;、&lt;code&gt;RequestTime&lt;/code&gt;などいろいろ表示される。&lt;/p&gt;

&lt;p&gt;とりあえず試しにこんな設定で送ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;match hoge.log&amp;gt;
  @type kinesis_producer
  region ap-northeast-1
  stream_name teststream
  include_time_key true

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambdaで読む&#34;&gt;Lambdaで読む&lt;/h2&gt;

&lt;p&gt;まとめられたレコードを&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation&#34;&gt;kinesis-aggregation&lt;/a&gt;で分解して読む。
今回は&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation/tree/master/node&#34;&gt;Node.js&lt;/a&gt;でやる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save aws-kinesis-agg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意する必要があるのは&lt;a href=&#34;https://github.com/awslabs/kinesis-aggregation/issues/16&#34;&gt;ドキュメントの情報が古く&lt;/a&gt;て、
関数の引数が足りないこと。第二引数のcomputeChecksumsが抜けているので気付かないと一つずつずれていくことになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const agg = require(&#39;aws-kinesis-agg&#39;);

exports.handler = (event, context, callback) =&amp;gt; {
    Promise.all(
        event.Records.map(
            (record) =&amp;gt; deaggregate(record)
        )
    ).then(
        (records) =&amp;gt; {
            // LambdaのNode.jsはまだ4.3なのでSpread operatorが使えない・・・
            // const message = `${[].concat(...records).length} came in`; 
            let sumCount = 0;
            records.forEach((r) =&amp;gt; sumCount += r.length);
            const message = `${records.length} aggregated records and ${sumCount} records come in`; 
            console.log(message);
            callback(null, message);
        },
        (err) =&amp;gt; callback(err)
    );
};

function deaggregate(record){
    return new Promise((resolve, reject) =&amp;gt; {
        agg.deaggregateSync(record.kinesis, true, (err, userRecords) =&amp;gt; {
            if (err) {
                reject(err);
            } else {
                resolve(userRecords);
            }
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;175レコードが10レコードにまとめられた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 aggregated records and 175 records come in
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/high-throughput-messaging-system-with-kinesis-kpl-fluentd-lambda/&#34;&gt;Kinesis Producer Library(KPL)とfluentdとLambdaを連携してKinesisのスループットを上げる ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>C#のdelegateとevent</title>
          <link>http://sambaiz.net/article/83/</link>
          <pubDate>Sun, 12 Mar 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/83/</guid>
          <description>

&lt;h2 id=&#34;delegate-https-msdn-microsoft-com-ja-jp-library-900fyy8e-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/900fyy8e.aspx&#34;&gt;delegate&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;カプセル化するためのdelegate(移譲)メソッドに使う型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Converter{

	private static double defaultConvert(double num){
		return num;
	}

	public delegate double Convert(double num);
	public Convert convert = defaultConvert;

	public double run(double num){
		return convert (num);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名メソッドやラムダ式を渡すこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var conv = new Converter ();

print (conv.run (2)); // 2

// 匿名メソッドの例
conv.convert = delegate(double input)
{
    return input + 1;
};
print (conv.run (2)); // 2 + 1 = 3

// ラムダ式の例
conv.convert = s =&amp;gt; s * s;
print (conv.run(2)); // 2 * 2 = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;event-https-msdn-microsoft-com-ja-jp-library-8627sbea-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/8627sbea.aspx&#34;&gt;event&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;宣言元でしか呼べないマルチキャストデリゲート。&lt;code&gt;+=&lt;/code&gt;でsubscribeして&lt;code&gt;-=&lt;/code&gt;で解除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void RunEventHandler(double num);
public event RunEventHandler RunEvent;

public double run(double num){
    if (RunEvent != null) {
        RunEvent (num);
    }
    return convert (num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subscribeしたものは全て呼ばれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void runHook(double num){
    print(&amp;quot;b: &amp;quot; +  num);
}

var conv = new Converter ();
conv.RunEvent += s =&amp;gt; print (&amp;quot;a: &amp;quot; +  s); // Subscribe a
conv.run (2); // a: 2

conv.RunEvent += runHook; // Subscribe b
conv.run (3); // a: 3, b: 3

conv.RunEvent -= runHook; // Unsubscribe b
conv.run (4); // a: 4

// error
// conv.RunEvent (); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.NET Frameworkのクラスライブラリの全てのイベントでは
&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/db0etb8x.aspx&#34;&gt;EventHandler&lt;TEventArgs&gt;&lt;/a&gt;を使っていて、
ユーザー定義のコードでもこのパターンを使うのが&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/w369ty8x.aspx&#34;&gt;推奨されている&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void EventHandler&amp;lt;TEventArgs&amp;gt;(
	object sender,
	TEventArgs e
)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのMaterial</title>
          <link>http://sambaiz.net/article/82/</link>
          <pubDate>Sat, 11 Mar 2017 20:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/82/</guid>
          <description>

&lt;h2 id=&#34;materialとshaderとtexture-https-docs-unity3d-com-550-documentation-manual-shaders-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/Shaders.html&#34;&gt;MaterialとShaderとTexture&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Materialは表面がどのようにレダリングされるかを定義するもの。
Shaderを指定し、Textureなどのパラメーターを設定する。&lt;/p&gt;

&lt;p&gt;Shaderは光と、Materialの設定から、ピクセルの色を計算するスクリプト。
大体&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/shader-StandardShader.html&#34;&gt;Standard Shader&lt;/a&gt;
で事足りるらしい。&lt;/p&gt;

&lt;p&gt;Textureはビットマップイメージ。色(Albedo)だけではなく、反射率や粗さなど、いろんな要素に使える。&lt;/p&gt;

&lt;h2 id=&#34;standard-shader&#34;&gt;Standard Shader&lt;/h2&gt;

&lt;h3 id=&#34;rendering-mode-https-docs-unity3d-com-manual-standardshadermaterialparameterrenderingmode-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/Manual/StandardShaderMaterialParameterRenderingMode.html&#34;&gt;Rendering Mode&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Albedoは(255, 255, 255, 255)で、テクスチャにはDefault Particleを指定している。
透明度はテクスチャのアルファチャンネルとAlbedoのアルファ値に基づく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-defaultparticle.png&#34; alt=&#34;Default Particle&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Opaque: デフォルト。すべて不透明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-opaque.png&#34; alt=&#34;Opaque&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CutOut: 閾値を境に、完全に透明か、不透明になる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alpha Cutoffを0.1にした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-cutout.png&#34; alt=&#34;CutOut&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transparent: 透明度が適用される。現実世界の透明なマテリアルのように、反射のハイライトは完全に表示される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-transparent.png&#34; alt=&#34;Transparent&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fade: ハイライトにも透明度を適用する。フェードイン/アウトしたいときに使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-fade.png&#34; alt=&#34;Fade&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;metallic&#34;&gt;Metallic&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/StandardShaderMaterialCharts.html&#34;&gt;マテリアルチャート&lt;/a&gt;をもとにAlbedoとMetallicとSmoothnessを設定する。&lt;/p&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Albedo: (255, 255, 255, 255)&lt;/li&gt;
&lt;li&gt;Metallic: 1&lt;/li&gt;
&lt;li&gt;Smoothness: 0.68&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を設定している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-metal.png&#34; alt=&#34;Metallic&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのUI</title>
          <link>http://sambaiz.net/article/81/</link>
          <pubDate>Wed, 08 Mar 2017 16:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/81/</guid>
          <description>

&lt;h2 id=&#34;canvas-https-docs-unity3d-com-ja-540-scriptreference-canvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/ScriptReference/Canvas.html&#34;&gt;Canvas&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;UI要素を配置するための領域。&lt;/p&gt;

&lt;h3 id=&#34;rendermode-https-docs-unity3d-com-jp-540-manual-uicanvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UICanvas.html&#34;&gt;renderMode&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Overlay: スクリーンに対してオーバーレイするように表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Camera: Cameraから指定した距離(planeDistance)離れた前方に表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;World Space 他のオブジェクトと同じように表示&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;canvas-scaler-https-docs-unity3d-com-jp-540-manual-script-canvasscaler-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/script-CanvasScaler.html&#34;&gt;Canvas Scaler&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UI Scale Mode (World Space以外)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constant Pixel Size: 画面サイズに関わらず同じピクセル数にする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scale With Screen Size: 画面サイズでスケールさせる&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Constant Physical Size 解像度や画面サイズによらず物理的に同じサイズにする&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dynami Pixels Per Unit (World Spaceのみ): Textなどの動的に生成されたビットマップの解像度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1と3でそれぞれこんな感じになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu1.png&#34; alt=&#34;Dynamic Pixels Per Unitが1のとき&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu3.png&#34; alt=&#34;Dynamic Pixels Per Unitが3のとき&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;autolayout-https-docs-unity3d-com-ja-540-manual-comp-uiautolayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/comp-UIAutoLayout.html&#34;&gt;AutoLayout&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-VerticalLayoutGroup.html&#34;&gt;Vertical Layout Group&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-GridLayoutGroup.html&#34;&gt;Grid Layout Group&lt;/a&gt;
など。これらのComponentを追加すると子要素のTransform(の一部)が自動で設定される。&lt;/p&gt;

&lt;h3 id=&#34;content-size-fitter-https-docs-unity3d-com-ja-540-manual-script-contentsizefitter-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-ContentSizeFitter.html&#34;&gt;Content Size Fitter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Layout Component要素に合うように自動で調整される。&lt;/p&gt;

&lt;h2 id=&#34;レイアウトを作る-https-docs-unity3d-com-jp-540-manual-uibasiclayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UIBasicLayout.html&#34;&gt;レイアウトを作る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;RectTool(ツールバーボタンの一番右の四角いやつ)を選択して、Pivot, Localにするとよい。
Canvasにいろいろ置いていって、Anchorを選んでRect Transformを設定していく。
あとはPrefabにしてInstantiateするなりして表示する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine.UI;

public GameObject dialogWindow;
var obj = Instantiate(obj, new Vector3(0, 0, 200), Quaternion.identity);

var hogeText = obj.transform.Find(&amp;quot;panel/hoge&amp;quot;).gameObject.GetComponent&amp;lt;Text&amp;gt;();
hogeText.text = &amp;quot;fuga&amp;quot;;

var fugaButton = obj.transform.Find(&amp;quot;panel/fuga&amp;quot;).gameObject.GetComponent&amp;lt;Button&amp;gt;();
fugaButton.onClick.AddListener (() =&amp;gt; {
    Debug.Log (&amp;quot;onClick&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのTransform</title>
          <link>http://sambaiz.net/article/80/</link>
          <pubDate>Tue, 07 Mar 2017 02:11:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/80/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&#34;&gt;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトの位置、スケール、回転を保持する。親子関係を持つ。&lt;/p&gt;

&lt;h2 id=&#34;position&#34;&gt;Position&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-position.html&#34;&gt;position&lt;/a&gt;がワールド空間の、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localPosition.html&#34;&gt;localPosition&lt;/a&gt;
が親から見た相対的なローカル空間の位置。localPositionの1unitはscaleに依存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.position = new Vector3(0, 0, 0);
transform.localPosition = new Vector3(0, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に移動するには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Translate.html&#34;&gt;Translate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;になっていて、&lt;code&gt;Space.World&lt;/code&gt;を指定するとワールド座標を基準にする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Time-deltaTime.html&#34;&gt;Time.deltaTime&lt;/a&gt;は最後のフレームを完了するのにかかった秒数。
なのでフレームレートにかかわらず同じ速度で移動させることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Translate(0, Time.deltaTime, 0, Space.World);
transform.Translate(Vector3.up * Time.deltaTime, Space.World); // 軸に沿って移動
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform); // 最後の引数のローカル座標を基準にする
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scale&#34;&gt;Scale&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localScale.html&#34;&gt;localScale&lt;/a&gt;
はローカル空間のスケール。ワールド空間のScaleはない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.localScale = new Vector3(0.1f, 1f, 1f);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rotation&#34;&gt;Rotation&lt;/h2&gt;

&lt;p&gt;ワールド空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-rotation.html&#34;&gt;rotation&lt;/a&gt;と
ローカル空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localRotation.html&#34;&gt;localRoation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Unityは&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.html&#34;&gt;Quarternion&lt;/a&gt;(四元数)で回転を持っている。
実際はQuarternionそのものを自分で計算することはなく、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.LookRotation.html&#34;&gt;Quaternion.LookRotation()&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.Euler.html&#34;&gt;Quaternion.Euler()&lt;/a&gt;などを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vector3 relativePos;
transform.rotation = Quaternion.LookRotation(relativePos); // そのPointを向くように回転
transform.localRotation = Quaternion.Euler(0, 30, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transformを向くように回転する場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.LookAt.html&#34;&gt;LookAt()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Transform target;
transform.LookAt(target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に回転させるには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Rotate.html&#34;&gt;Rotate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;で、&lt;code&gt;Space.World&lt;/code&gt;を指定すると回転の軸がワールドの軸になる。指定するのは角度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Rotate(0, Time.deltaTime, 0, Space.World);
transform.Rotate(Vector3.up, Time.deltaTime, Space.World);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ワールド座標のあるPointを中心として回転させる場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.RotateAround.html&#34;&gt;RotateAround()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.RotateAround(Vector3.zero, Vector3.up, 20 * Time.deltaTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parent-https-docs-unity3d-com-jp-current-scriptreference-transform-parent-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform-parent.html&#34;&gt;parent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;親を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fuga = GameObject.CreatePrimitive (PrimitiveType.Cube);
fuga.transform.parent = hoge.transform;
fuga.transform.parent = null; // detach
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-https-docs-unity3d-com-jp-540-scriptreference-transform-find-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Find.html&#34;&gt;Find&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;子の名前で検索する。
FindChildもあるけどドキュメントに書いてないので使わない方がよさそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var child = transform.Find(&amp;quot;hoge/fuga&amp;quot;)
if(child != null){
    child.gameObject
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでDateを任意のフォーマットの文字列にする</title>
          <link>http://sambaiz.net/article/79/</link>
          <pubDate>Mon, 06 Mar 2017 20:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/79/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://momentjs.com/&#34;&gt;Moment.js&lt;/a&gt;を使う。
相対時間(&lt;code&gt;5 years ago&lt;/code&gt;)を出したり、日付の計算(&lt;code&gt;add(3, &#39;days&#39;)&lt;/code&gt;)もできる便利なライブラリ。
ブラウザでも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install moment
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const moment = require(&#39;moment&#39;)
const jst = +9
let now = moment().utcOffset(jst).format(&amp;quot;YYYY-MM-DD HH:mm:ss.SSSZ&amp;quot;);
console.log(now);
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityと.NETとMono</title>
          <link>http://sambaiz.net/article/78/</link>
          <pubDate>Sun, 05 Mar 2017 18:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/78/</guid>
          <description>

&lt;p&gt;.NETとかよくわからなかったのでまとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;net-framework&#34;&gt;.NET Framework&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoftが開発したアプリケーション開発、実行環境。&lt;/p&gt;

&lt;p&gt;各言語のコンパイラによって言語、環境によらない共通の中間言語(CIL, Common Intermediate Language)バイナリ(exeやdll)に変換し、
実行時に共通言語基盤(CLI, Common Language Infrastructure)の仮想実行システム(VES)が環境依存の機械語を動的に生成(JIT, Just in time)する。
CLIの仕様はECMAで標準化されていて、Microsoftが実装したCLIが共通言語ランタイム(CLR)。Windowsでしか動かない。&lt;/p&gt;

&lt;h2 id=&#34;net-core&#34;&gt;.NET Core&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/magazine/mt694084.aspx&#34;&gt;.NET Core - .NET Core による .NET のクロスプラットフォームへの移行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/dotnet&#34;&gt;Microsoft/dotnet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームに対応した.NET。CoreCLRはWindowsだけではなくMacやLinuxでも動く。
.NET Frameworkと共通のAPIもあるが、GUIまわりでどちらかにしかないAPIが存在する。&lt;/p&gt;

&lt;h2 id=&#34;mono-http-www-mono-project-com&#34;&gt;&lt;a href=&#34;http://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームな.NET Framework互換ソフトウェア。C#のコンパイラとCLIが実装されている。
Unityはこれを使っているが、バージョンが古くて使えないライブラリがある。&lt;/p&gt;

&lt;h2 id=&#34;net-coreでhello-world&#34;&gt;.NET CoreでHello World&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/net/core#macos&#34;&gt;インストール手順&lt;/a&gt;に沿って
&lt;code&gt;dotnet&lt;/code&gt;コマンドを使えるようにする。&lt;/p&gt;

&lt;p&gt;Hello Worldまで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dotnet console -o hwapp
$ cd hwapp
$ ls
Program.cs	hwapp.csproj

$ dotnet restore
$ ls
Program.cs	hwapp.csproj	obj

$ ls obj
hwapp.csproj.nuget.g.props	project.assets.json
hwapp.csproj.nuget.g.targets

# dotnet build
$ dotnet run
Hello World!

$ dotnet bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に.NET CoreにしかないAPIも使っていないのでmono(.NET Framework)ででも実行できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Program.cs 
using System;

namespace hwapp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&amp;quot;Hello World!&amp;quot;);
        }
    }
}

$ mono bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/AimingStudy/unitynet&#34;&gt;Unityと.NET&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Elasticsearchで期間ごとの集計値を出す</title>
          <link>http://sambaiz.net/article/77/</link>
          <pubDate>Sun, 05 Mar 2017 01:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/77/</guid>
          <description>

&lt;p&gt;Bucket(SQLでいうGROUP BY)にまとめて(Bucket Aggreagtion)、集計(Metric Aggregation)する。&lt;/p&gt;

&lt;p&gt;使うデータは&lt;a href=&#34;http://sambaiz.net/article/76/&#34;&gt;作ったツール&lt;/a&gt;で生成したこんなの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;score&amp;quot;:82}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bucket-aggregations-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket.html&#34;&gt;Bucket Aggregations&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;date-range-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-daterange-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-daterange-aggregation.html&#34;&gt;Date Range Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;date_range&lt;/code&gt;で期間のBucketを作る。この例だと今から10分前の00秒~今の分の00秒まで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {
        &amp;quot;range_10minutes&amp;quot;: {
            &amp;quot;date_range&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;format&amp;quot;: &amp;quot;HH-mm-ssZ&amp;quot;,
                &amp;quot;ranges&amp;quot;: [                               
                    { &amp;quot;to&amp;quot;: &amp;quot;now/m&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;now-10m/m&amp;quot; }
                ]
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;range_10minutes&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;15-17+0000-15-27+0000&amp;quot;,
        &amp;quot;from&amp;quot;: 1488640620000,
        &amp;quot;from_as_string&amp;quot;: &amp;quot;15-17+0000&amp;quot;,
        &amp;quot;to&amp;quot;: 1488641220000,
        &amp;quot;to_as_string&amp;quot;: &amp;quot;15-27+0000&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 600
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;date-histogram-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-datehistogram-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-datehistogram-aggregation.html&#34;&gt;Date Histogram Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;date_histogram&lt;/code&gt;で日付の間隔でBucketを作る。この例だと1分ごとにBucketが作られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {   
        &amp;quot;histogram_1minute&amp;quot;: {                  
            &amp;quot;date_histogram&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;interval&amp;quot;: &amp;quot;1m&amp;quot;
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;histogram_1minute&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      ...
      {
        &amp;quot;key_as_string&amp;quot;: &amp;quot;1488640560&amp;quot;,
        &amp;quot;key&amp;quot;: 1488640560000,
        &amp;quot;doc_count&amp;quot;: 60
      },
      {
        &amp;quot;key_as_string&amp;quot;: &amp;quot;1488640620&amp;quot;,
        &amp;quot;key&amp;quot;: 1488640620000,
        &amp;quot;doc_count&amp;quot;: 31
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;terms-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-bucket-terms-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-bucket-terms-aggregation.html&#34;&gt;Terms Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;terms&lt;/code&gt;で値ごとにBucketを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{
    &amp;quot;aggs&amp;quot;: {   
        &amp;quot;os_names&amp;quot;:{                  
            &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;os_name&amp;quot; }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;os_names&amp;quot;: {
    &amp;quot;doc_count_error_upper_bound&amp;quot;: 0,
    &amp;quot;sum_other_doc_count&amp;quot;: 0,
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;windows&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 458
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;android&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 456
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;mac&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 455
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;linux&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 447
      },
      {
        &amp;quot;key&amp;quot;: &amp;quot;ios&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 404
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metrics-aggregations-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-metrics-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-metrics.html&#34;&gt;Metrics Aggregations&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;avg-aggregation-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-search-aggregations-metrics-avg-aggregation-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/search-aggregations-metrics-avg-aggregation.html&#34;&gt;Avg Aggregation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;avg&lt;/code&gt;で平均を出す。&lt;code&gt;max&lt;/code&gt;、&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;sum&lt;/code&gt;も同様。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d &#39;
{
    &amp;quot;aggs&amp;quot;: {      
        &amp;quot;avg_score&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot; : &amp;quot;score&amp;quot; } }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;avg_score&amp;quot;: {
    &amp;quot;value&amp;quot;: 50.34639639639639
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;集計する&#34;&gt;集計する&lt;/h2&gt;

&lt;p&gt;aggsを組み合わせて集計する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/hoge/_search -d&#39;
{             
    &amp;quot;aggs&amp;quot;: {
        &amp;quot;range&amp;quot;: {
            &amp;quot;date_range&amp;quot;: {
                &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                &amp;quot;format&amp;quot;: &amp;quot;HH-mm-ssZ&amp;quot;,
                &amp;quot;ranges&amp;quot;: [                               
                    { &amp;quot;to&amp;quot;: &amp;quot;now/m&amp;quot;, &amp;quot;from&amp;quot;: &amp;quot;now-10m/m&amp;quot; }
                ]
            },
            &amp;quot;aggs&amp;quot;: {
                &amp;quot;histogram&amp;quot;: {                  
                    &amp;quot;date_histogram&amp;quot;: {
                        &amp;quot;field&amp;quot;: &amp;quot;@timestamp&amp;quot;,
                        &amp;quot;interval&amp;quot;: &amp;quot;1m&amp;quot;
                    },
                    &amp;quot;aggs&amp;quot;: {
                        &amp;quot;os_names&amp;quot;:{
                            &amp;quot;terms&amp;quot;: { &amp;quot;field&amp;quot; : &amp;quot;os_name&amp;quot; },
                            &amp;quot;aggs&amp;quot;: {
                                &amp;quot;avg_score&amp;quot;: { &amp;quot;avg&amp;quot;: { &amp;quot;field&amp;quot;: &amp;quot;score&amp;quot; }}
                            }
                        }
                    }
                }
            }
        }
    }
}&#39; | jq .aggregations
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;range&amp;quot;: {
    &amp;quot;buckets&amp;quot;: [
      {
        &amp;quot;key&amp;quot;: &amp;quot;15-55-00+0000-16-05-00+0000&amp;quot;,
        &amp;quot;from&amp;quot;: 1488642900000,
        &amp;quot;from_as_string&amp;quot;: &amp;quot;15-55-00+0000&amp;quot;,
        &amp;quot;to&amp;quot;: 1488643500000,
        &amp;quot;to_as_string&amp;quot;: &amp;quot;16-05-00+0000&amp;quot;,
        &amp;quot;doc_count&amp;quot;: 25,
        &amp;quot;histogram&amp;quot;: {
          &amp;quot;buckets&amp;quot;: [
            {
              &amp;quot;key_as_string&amp;quot;: &amp;quot;1488643440&amp;quot;,
              &amp;quot;key&amp;quot;: 1488643440000,
              &amp;quot;doc_count&amp;quot;: 25,
              &amp;quot;os_names&amp;quot;: {
                &amp;quot;doc_count_error_upper_bound&amp;quot;: 0,
                &amp;quot;sum_other_doc_count&amp;quot;: 0,
                &amp;quot;buckets&amp;quot;: [
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;linux&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 9,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 41.44444444444444
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;ios&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 5,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 63.6
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;mac&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 5,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 53.6
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;android&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 4,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 41.25
                    }
                  },
                  {
                    &amp;quot;key&amp;quot;: &amp;quot;windows&amp;quot;,
                    &amp;quot;doc_count&amp;quot;: 2,
                    &amp;quot;avg_score&amp;quot;: {
                      &amp;quot;value&amp;quot;: 67
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>一定間隔でjsonデータを作って送り続けるCLIツールを作った</title>
          <link>http://sambaiz.net/article/76/</link>
          <pubDate>Sat, 04 Mar 2017 23:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/76/</guid>
          <description>&lt;p&gt;Elasticsearchにリアルタイムなテストデータを投入するために、一定間隔でjsonを作って送り続けるCLIツールを作った。Go製。
&lt;a href=&#34;https://github.com/urfave/cli&#34;&gt;urfave/cli&lt;/a&gt;を使った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/sendjson&#34;&gt;sambaiz/sendjson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こんなindexにデータを入れてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT &#39;http://localhost:9200/hoge&#39; -d&#39;
{
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;test_type&amp;quot;: { 
      &amp;quot;_all&amp;quot;:       { &amp;quot;enabled&amp;quot;: false  }, 
      &amp;quot;properties&amp;quot;: { 
        &amp;quot;os_name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; },
        &amp;quot;score&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;byte&amp;quot; },
        &amp;quot;@timestamp&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;epoch_second&amp;quot; }
      }
    }
  }
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じでキーに対してtypeと入る値を定義するとそれっぽいデータができて送られていく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install github.com/sambaiz/sendjson
$ sendjson --interval 0.5s --duration 10s --url http://localhost:9200/hoge/test_type &#39;
{
    &amp;quot;os_name&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;or&amp;quot;: [&amp;quot;windows&amp;quot;, &amp;quot;mac&amp;quot;, &amp;quot;linux&amp;quot;, &amp;quot;ios&amp;quot;, &amp;quot;android&amp;quot;]},
    &amp;quot;score&amp;quot;:  {&amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, &amp;quot;min&amp;quot;: 0, &amp;quot;max&amp;quot;: 100},
    &amp;quot;@timestamp&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;time&amp;quot;, &amp;quot;time_format&amp;quot;: &amp;quot;unix_epoch&amp;quot;}
}&#39;

{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;score&amp;quot;:82}
{&amp;quot;@timestamp&amp;quot;:1488635130,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:9}
{&amp;quot;@timestamp&amp;quot;:1488635131,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:73}
{&amp;quot;@timestamp&amp;quot;:1488635131,&amp;quot;os_name&amp;quot;:&amp;quot;ios&amp;quot;,&amp;quot;score&amp;quot;:50}
{&amp;quot;@timestamp&amp;quot;:1488635132,&amp;quot;os_name&amp;quot;:&amp;quot;windows&amp;quot;,&amp;quot;score&amp;quot;:69}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと入っていることを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:9200/hoge/_search | jq
{
  &amp;quot;took&amp;quot;: 2,
  &amp;quot;timed_out&amp;quot;: false,
  &amp;quot;_shards&amp;quot;: {
    &amp;quot;total&amp;quot;: 5,
    &amp;quot;successful&amp;quot;: 5,
    &amp;quot;failed&amp;quot;: 0
  },
  &amp;quot;hits&amp;quot;: {
    &amp;quot;total&amp;quot;: 29,
    &amp;quot;max_score&amp;quot;: 1,
    &amp;quot;hits&amp;quot;: [
      {
        &amp;quot;_index&amp;quot;: &amp;quot;hoge&amp;quot;,
        &amp;quot;_type&amp;quot;: &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot;: &amp;quot;AVqZpCjjFTc9Q_rmmMn7&amp;quot;,
        &amp;quot;_score&amp;quot;: 1,
        &amp;quot;_source&amp;quot;: {
          &amp;quot;@timestamp&amp;quot;: 1488636356,
          &amp;quot;os_name&amp;quot;: &amp;quot;android&amp;quot;,
          &amp;quot;score&amp;quot;: 38
        }
      },
      {
        &amp;quot;_index&amp;quot;: &amp;quot;hoge&amp;quot;,
        &amp;quot;_type&amp;quot;: &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot;: &amp;quot;AVqZpE-kFTc9Q_rmmMoN&amp;quot;,
        &amp;quot;_score&amp;quot;: 1,
        &amp;quot;_source&amp;quot;: {
          &amp;quot;@timestamp&amp;quot;: 1488636366,
          &amp;quot;os_name&amp;quot;: &amp;quot;android&amp;quot;,
          &amp;quot;score&amp;quot;: 87
        }
      },
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>H2OでHTTPS-&gt;HTTPのリバースプロキシを立てる</title>
          <link>http://sambaiz.net/article/75/</link>
          <pubDate>Thu, 02 Mar 2017 20:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/75/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://qiita.com/cubicdaiya/items/235777dc401ec419b14e&#34;&gt;良くチューニングされたNginxと同じくらい速い&lt;/a&gt;と
評判のHTTP/2サーバー&lt;a href=&#34;https://h2o.examp1e.net/&#34;&gt;H2O&lt;/a&gt;でリバースプロキシを立ててみる。
HTTP/2だけではなく1.xにも対応しているので古い環境などでも大丈夫。&lt;/p&gt;

&lt;p&gt;設定は
&lt;a href=&#34;https://github.com/h2o/h2o/wiki/Reverse-Proxy&#34;&gt;Reverse Proxy&lt;/a&gt;と
&lt;a href=&#34;https://github.com/h2o/h2o/wiki/redirect-HTTP-to-HTTPS&#34;&gt;HTTP to HTTPS&lt;/a&gt;の
サンプルをもとにして書いた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hosts:
  &amp;quot;*&amp;quot;:
    listen:
      port: 443
      ssl:
        certificate-file: /etc/h2o/oreore.crt
        key-file:         /etc/h2o/server.key
    paths:
      &amp;quot;/&amp;quot;:
        proxy.reverse.url: http://127.0.0.1:3000/

access-log: /dev/stdout
error-log: /dev/stderr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とりあえずオレオレ証明書で試してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa 2048 &amp;gt; server.key # private key
$ openssl req -new -key server.key &amp;gt; server.csr # certificate signing request 
$ openssl x509 -days 365000 -req -signkey server.key &amp;lt; server.csr &amp;gt; oreore.crt # oreore certificate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerで動かす。&lt;a href=&#34;https://github.com/lkwg82/h2o.docker&#34;&gt;lkwg82/h2o.docker&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi h2o.conf
$ docker run -v $(pwd):/etc/h2o --net=host --name h2o --restart=always -itd lkwg82/h2o-http2-server
$ curl --insecure https://127.0.0.1 # -&amp;gt; :3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromeでアクセスして、Developer ToolsのNetworkで右クリックでProtocolにチェックを入れてh2と表示されていたら
HTTP/2で通信している。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goroutineの数をworkerで抑制する</title>
          <link>http://sambaiz.net/article/74/</link>
          <pubDate>Mon, 27 Feb 2017 23:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/74/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/61/&#34;&gt;Goのnet/httpとKeep-Alive - sambaiz.net&lt;/a&gt;でやったように、
あるエンドポイントに連続してGoroutineでリクエストを投げると、リクエスト数を増やしたときにタイムアウトが頻発するようになった。&lt;/p&gt;

&lt;p&gt;まず、2000リクエストを投げてみた結果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 2000, ok: 2000, ng: 0, time(ms) 138
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一応全部捌けてはいるけど、おおよそ同時にリクエストを送っているのにタイムアウト(100ms)時間を超えてしまっている。これをさらに3000に増やしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 13, ng: 2987, time(ms) 372
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほぼ全滅してしまった・・・。時間もおかしいのでGoroutineでの処理に遅延が発生しているようだ。
そこで、都度Goroutineを生成してリクエストを投げるのではなく、
一定数のWorkerに処理させることで、同時に作られるGoroutineの数を抑制する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Req struct {
	Okch chan int
	Ngch chan int
}

func startWorker(ctx context.Context, num int) (requestch chan *Req) {

	requestch = make(chan *Req)

	for i := 0; i &amp;lt; num; i++ {
		go func() {
			for {
				select {
				case req := &amp;lt;-requestch:
					request(req.Okch, req.Ngch)
				case &amp;lt;-ctx.Done():
					return
				}
			}
		}()
	}

	return
}

func main(){
    ...
    ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	requestch := startWorker(ctx, 1000)

    requestch &amp;lt;- req
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、すべてのリクエストをタイムアウトせずに送れるようになった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 3000, ng: 0, time(ms) 157
[RESULT] request: 5000, ok: 5000, ng: 0, time(ms) 239
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上のコードではWorkerを作るにあたって単純にWorkerの数分goroutineを生成して共通のチャネルに入ってきたものを読んで処理させているが、
以下の記事のようにDispatcherを用意してWorkerPool(chan chan Job)からWorkerのjobChannel(chan Job)を取り出して送る方法も紹介されていたので
これとも比較してみた。今回は入力するチャネルだけ分けて終了方法はStartで渡したcontextに一任しているので上の方法とさほど変わらず、むしろ冗長に見えるが、
実際はWorkerそれぞれがquitするチャネルなどを持っていて、独立して終了させることができるため、Workerの数を動的にコントロールしやすいのが特長だと思う。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/&#34;&gt;Handling 1 Million Requests per Minute with Go  · marcio.io&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Dispatcher struct{
	Requestch chan *Req
	workerPool chan chan *Req
	workerNum int
}

func NewDispatcher(workerNum int) *Dispatcher{
	return &amp;amp;Dispatcher{
		Requestch: make(chan *Req),
		workerPool: make(chan chan *Req, workerNum),
		workerNum: workerNum,
	}
}


func (d *Dispatcher) Start(ctx context.Context) error{
	poolLength := len(d.workerPool)
	if poolLength != 0{
		return errors.New(&amp;quot;already started&amp;quot;)
	}
	for i := 0; i &amp;lt; d.workerNum; i++{
		startWorker(ctx, 1, d.workerPool)
	}

	go d.dispatch(ctx)

	return nil
}

func (d *Dispatcher) dispatch(ctx context.Context){
	for{
		select{
		case req := &amp;lt;- d.Requestch:
            // workerPoolからchanを取り出しreqを入れる
			worker := &amp;lt;- d.workerPool
			worker &amp;lt;- req
		case &amp;lt;-ctx.Done():
			return 
		}
	}
}

func startWorker(ctx context.Context, num int, workerPool chan chan *Req) {

	requestch := make(chan *Req)

	for i := 0; i &amp;lt; num; i++ {
		go func() {
			for {
                // workerPoolにchanを入れる(終わったらまだ戻る)
				workerPool &amp;lt;- requestch
				select {
				case req := &amp;lt;-requestch:
					request(req.Okch, req.Ngch)
				case &amp;lt;-ctx.Done():
					return
				}
			}
		}()
	}

	return
}

func main(){
    ...
    dispatcher := NewDispatcher(1000)
	if err := dispatcher.Start(ctx); err != nil{
		panic(err)
	}

    dispatcher.requestch &amp;lt;- req
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほとんど変わらず。WorkerPoolからチャネルを取り出す分、わずかに遅いかな。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RESULT] request: 3000, ok: 3000, ng: 0, time(ms) 169
[RESULT] request: 5000, ok: 5000, ng: 0, time(ms) 246
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdでKinesis Streamsに送ってLambdaで読んでS3に保存する</title>
          <link>http://sambaiz.net/article/73/</link>
          <pubDate>Sun, 26 Feb 2017 18:56:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/73/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis&#34;&gt;aws-fluent-plugin-kinesis&lt;/a&gt;でKinesis Streamsに送り、Lambdaで読んでS3に保存する。
要するにFirehoseのようなことをやりたいのだけれどTokyoリージョンにまだ来ないので自分でやる。&lt;/p&gt;

&lt;h2 id=&#34;fluentdで送る&#34;&gt;fluentdで送る&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ td-agent-gem install fluent-plugin-kinesis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;try_flush_interval&lt;/code&gt;と&lt;code&gt;queued_chunk_flush_interval&lt;/code&gt;はドキュメントには載っていないが、
以下のページによるとそれぞれqueueに次のchunkがないときとあるときのflushする間隔。
いずれもデフォルトは1だが、これを減らすことでもっと頻繁に吐き出されるようになるらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sonots/fluentd-scr/blob/master/02_out_forward_buffered.md&#34;&gt;Fluentd の out_forward と BufferedOutput&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;あとシャードに振り分けるための&lt;a href=&#34;https://github.com/awslabs/aws-fluent-plugin-kinesis#partition_key&#34;&gt;partition_key&lt;/a&gt;
を指定できる。デフォルトはランダム。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type tail
  path /var/log/td-agent/hoge.log
  pos_file /etc/td-agent/log.pos
  tag hoge.log
  format json

  time_key timestamp
  # 2017-01-01T01:01:01+0900
  time_format %Y-%m-%dT%H:%M:%S%z
&amp;lt;/source&amp;gt;

&amp;lt;match hoge.log&amp;gt;
  @type kinesis_streams
  region ap-northeast-1
  stream_name teststream
  include_time_key true

  flush_interval 1
  buffer_chunk_limit 1m
  try_flush_interval 0.1
  queued_chunk_flush_interval 0.01
  num_threads 15
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いくつか送ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in `seq 1 1000`
do
  echo &#39;{&amp;quot;hoge&amp;quot;: &amp;quot;fuga&amp;quot;, &amp;quot;timestamp&amp;quot;: &amp;quot;2017-01-01T01:01:01+0900&amp;quot;}&#39; &amp;gt;&amp;gt; /var/log/td-agent/hoge.log
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kinesisのシャードが足りないと詰まってしまうので注意。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/84/&#34;&gt;FluentdとKPL(Kinesis Producer Library)でログをまとめてスループットを稼ぐ - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lambdaで読む&#34;&gt;Lambdaで読む&lt;/h2&gt;

&lt;p&gt;Lambdaのトリガーの設定でKinesisを選ぶと、バッチサイズや開始位置を設定できる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/73-lambda-kinesis.png&#34; alt=&#34;トリガーの設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const zlib = require(&#39;zlib&#39;);
const aws = require(&#39;aws-sdk&#39;);
const s3 = new aws.S3({ apiVersion: &#39;2006-03-01&#39; });
const BUCKET_NAME = process.env.BUCKET_NAME; // 環境変数で設定する

exports.handler = (event, context, callback) =&amp;gt; {

    const data = event.Records.map((record) =&amp;gt; new Buffer(record.kinesis.data, &#39;base64&#39;).toString()).join(&amp;quot;\n&amp;quot;);
    const key = new Date().toISOString();
    
    putS3(key, data, true).then(
        (data) =&amp;gt; callback(null, `Successfully processed ${event.Records.length} records.`),
        (err) =&amp;gt; callback(err, null)
    );
};

function putS3(key, data, gzip){    
    return new Promise((resolve, reject) =&amp;gt; {
        
        const params = {
            Bucket: BUCKET_NAME,
            Key: key
        };

        if(gzip){
            params.Body = zlib.gzipSync(data);
            params.ContentEncoding = &amp;quot;gzip&amp;quot;;
        }else{
            params.Body = data;
        }
        
        s3.putObject(params, (err, data) =&amp;gt; {
            if (err) reject(err);
            else resolve(data);
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トリガーを有効にするとイベントが発火してS3に保存されるようになった。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AWSのAssumeRole</title>
          <link>http://sambaiz.net/article/72/</link>
          <pubDate>Sat, 25 Feb 2017 20:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/72/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_credentials_temp.html&#34;&gt;AWS Security Token Service&lt;/a&gt;による、
RoleArn(&lt;code&gt;arn:aws:iam::&amp;lt;account id&amp;gt;:role/&amp;lt;role name&amp;gt;&lt;/code&gt;)から一時的なCredentialを取得する仕組み。
前もって発行したAPIキーとは違い、有効期限が存在するため続けて呼ぶ場合は失効する前に再発行する必要がある。&lt;/p&gt;

&lt;p&gt;ではRoleArnを知っていたら誰でも取得できるかというと、もちろんそうではなく、
ロールの信頼関係、&lt;code&gt;&amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;&lt;/code&gt;のPrincipalのところで信頼する対象を設定する。
例えば、&lt;code&gt;Service&lt;/code&gt;で&lt;code&gt;ec2.amazonaws.com&lt;/code&gt;を指定してEC2がAssumeRoleするのを許可したり、
&lt;code&gt;AWS&lt;/code&gt;で(他の)アカウントやユーザーを指定してそのAPIキーでこのRoleのCredentialを取得できるようにしたりといった感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
  &amp;quot;Statement&amp;quot;: [
    {
      &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
      &amp;quot;Principal&amp;quot;: {
        &amp;quot;Service&amp;quot;: &amp;quot;ec2.amazonaws.com&amp;quot;
      },
      &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EC2にロールを設定すると、実はそのロールについてAssumeRoleして自動でCredentialを取得している。
EC2にロールを設定するにはロールとは別に
&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html&#34;&gt;インスタンスプロファイルを作成&lt;/a&gt;
する必要があるが、コンソールでEC2のサービスロールを作ると同名のインスタンスプロファイルが自動で作成される。
さらに、AssumeRoleのServiceとして&lt;code&gt;ec2.amazonaws.com&lt;/code&gt;が追加されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://169.254.169.254/latest/meta-data/iam/info
{
  &amp;quot;Code&amp;quot; : &amp;quot;Success&amp;quot;,
  &amp;quot;LastUpdated&amp;quot; : &amp;quot;2017-02-25T10:56:33Z&amp;quot;,
  &amp;quot;InstanceProfileArn&amp;quot; : &amp;quot;arn:aws:iam::*****:instance-profile/assume_role_test&amp;quot;,
  &amp;quot;InstanceProfileId&amp;quot; : &amp;quot;*****&amp;quot;
}

$ curl http://169.254.169.254/latest/meta-data/iam/security-credentials/assume_role_test
{
  &amp;quot;Code&amp;quot; : &amp;quot;Success&amp;quot;,
  &amp;quot;LastUpdated&amp;quot; : &amp;quot;2017-02-25T10:56:23Z&amp;quot;,
  &amp;quot;Type&amp;quot; : &amp;quot;AWS-HMAC&amp;quot;,
  &amp;quot;AccessKeyId&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;SecretAccessKey&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;Token&amp;quot; : &amp;quot;*****&amp;quot;,
  &amp;quot;Expiration&amp;quot; : &amp;quot;2017-02-25T17:26:07Z&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/iam-role-and-assumerole/&#34;&gt;IAMロール徹底理解 〜 AssumeRoleの正体 ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/id_credentials_temp_use-resources.html&#34;&gt;一時的なセキュリティ認証情報を使用して AWS リソースへのアクセスをリクエストする - AWS Identity and Access Management&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ElasticsearchのCircuit Breaker</title>
          <link>http://sambaiz.net/article/71/</link>
          <pubDate>Fri, 24 Feb 2017 21:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/71/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/52/&#34;&gt;ElasticsearchをDockerで動かしてGrafanaで可視化する - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ESに送られるデータの量が増えてくるとGrafanaのDashboardにグラフが表示されなくなってしまった。
表示されたエラーはこういうの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;root_cause&amp;quot;: [
    {
        &amp;quot;type&amp;quot;: &amp;quot;circuit_breaking_exception&amp;quot;,
        &amp;quot;reason&amp;quot;: &amp;quot;[request] Data too large, data for [] would be larger than limit of [8998512230/8.3gb]&amp;quot;,
        &amp;quot;bytes_wanted&amp;quot;: 10464007168,
        &amp;quot;bytes_limit&amp;quot;: 8998512230
    }
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは1リクエストの集計などで使うメモリ量がしきい値をこえて
&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/circuit-breaker.html&#34;&gt;Circuit Breaker&lt;/a&gt;が発動したということ。
メモリを食いつぶしてOutOfMemoryになる前に焼き切れるようになっている。&lt;/p&gt;

&lt;p&gt;情報は&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/cluster-nodes-stats.html&#34;&gt;stats&lt;/a&gt;のapiでも取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/_nodes/stats | jq .nodes[].breakers.request
{
  &amp;quot;limit_size_in_bytes&amp;quot;: 8998512230,
  &amp;quot;limit_size&amp;quot;: &amp;quot;8.3gb&amp;quot;,
  &amp;quot;estimated_size_in_bytes&amp;quot;: 10348347504,
  &amp;quot;estimated_size&amp;quot;: &amp;quot;9.6gb&amp;quot;,
  &amp;quot;overhead&amp;quot;: 1,
  &amp;quot;tripped&amp;quot;: 470
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回ひっかかったのは&lt;code&gt;indices.breaker.request.limit&lt;/code&gt;。デフォルトではJVMのヒープメモリの60%になっているが、
これを80%にまで緩和する。併せてparent-levelのbreakerも上げる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT localhost:9200/_cluster/settings -d &#39;{
    &amp;quot;persistent&amp;quot; : {
        &amp;quot;indices.breaker.request.limit&amp;quot;: &amp;quot;80%&amp;quot;,
        &amp;quot;indices.breaker.total.limit&amp;quot;: &amp;quot;80%&amp;quot;
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT localhost:9200/_cluster/settings -d &#39;{
    &amp;quot;persistent&amp;quot; : {
        &amp;quot;indices.breaker.request.limit&amp;quot;: &amp;quot;80%&amp;quot;,
        &amp;quot;indices.breaker.total.limit&amp;quot;: &amp;quot;80%&amp;quot;
    }
}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必要なメモリ量を上回ったのでひとまずは返せるようになった。
これは一時しのぎで、定常的に大量にメモリが必要なリクエストを処理する必要があるなら、そもそもメモリが足りないので増やさなければならない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200/_nodes/stats | jq .nodes[].breakers.request
{
  &amp;quot;limit_size_in_bytes&amp;quot;: 11998016307,
  &amp;quot;limit_size&amp;quot;: &amp;quot;11.1gb&amp;quot;,
  &amp;quot;estimated_size_in_bytes&amp;quot;: 10473078896,
  &amp;quot;estimated_size&amp;quot;: &amp;quot;9.7gb&amp;quot;,
  &amp;quot;overhead&amp;quot;: 1,
  &amp;quot;tripped&amp;quot;: 470
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>crontabのメモ</title>
          <link>http://sambaiz.net/article/70/</link>
          <pubDate>Fri, 24 Feb 2017 21:40:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/70/</guid>
          <description>

&lt;p&gt;各ユーザーごとのcron設定。&lt;code&gt;crontab -e&lt;/code&gt;でも編集できるけど、間違えて&lt;code&gt;-r&lt;/code&gt;にすると全部消えてしまうのでこういう風に一旦取り出してから編集すると安全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crontab -l &amp;gt; ~/crontab
$ echo &amp;quot;*/1 * * * * /hoge/fuga.sh&amp;quot; &amp;gt;&amp;gt; ~/crontab
$ crontab &amp;lt; ~/crontab
$ crontab -l
*/1 * * * * /hoge/fuga.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://vividcode.hatenablog.com/entry/man-cron-and-crontab&#34;&gt;cron 設定ファイル (crontab ファイル) の置き場所と書式について - ひだまりソケットは壊れない&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Cookieのメモ</title>
          <link>http://sambaiz.net/article/69/</link>
          <pubDate>Wed, 22 Feb 2017 20:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/69/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レスポンスに&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーが含まれていればブラウザはcookieに保存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエスト時には&lt;code&gt;Cookie&lt;/code&gt;ヘッダーにcookieを入れて送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CookieにExpire(ある期間まで有効)またはMax-Age(特定の期間の間有効)を設定するとPermanent cookieとなる。
いずれも設定しなかった場合Session cookieとなり、ブラウザを閉じると削除されることになっているが、
ブラウザのセッション復元機能が有効になっていれば永続化される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secureを付けるとHTTPSでのみ送られる。
また、HttpOnlyはjsから&lt;code&gt;document.cookie&lt;/code&gt;などでアクセスすることができなくなる。
サイトにXSSの脆弱性があるとき、cookieが盗まれてしまうのを防ぐことができるので問題なければ設定するべき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Domainを指定するとそのドメインとサブドメインへのリクエストのときに送られる。しないとそのドメインだけ。Pathも指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Domain=example.com; Path=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエストが飛び、&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーを受け取ればCookieに書かれるので、アクセスしたサイトのドメイン以外のCookieが書かれることがある。
このようなCookieを3rd party cookieといって、広告のトラッキングによく使われるが、
Safariなどのデフォルト設定では書き込めなくなっている。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ELBのスケーリングとsurge queue</title>
          <link>http://sambaiz.net/article/68/</link>
          <pubDate>Tue, 21 Feb 2017 19:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/68/</guid>
          <description>

&lt;p&gt;バックエンドだけではなくELB自体もスケーリングし、内部node数はdigで調べることができる。
このnode数は自分ではコントロールできず、基本的に意識することはない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dig ****.ap-northeast-1.elb.amazonaws.com

;; ANSWER SECTION:
*****.elb.amazonaws.com. 60 IN A xxx.xxx.xxx.xxx
*****.elb.amazonaws.com. 60 IN A yyy.yyy.yyy.yyy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodeが増えるのにはある程度時間がかかるので、
アクセスが急増(5分間で50%以上のトラフィック増加が&lt;a href=&#34;http://aws.typepad.com/sajp/2015/05/aws-black-belt-elb.html&#34;&gt;目安&lt;/a&gt;)
したら捌ききれず、503を返すことがある。
前もって多量のアクセスが来ることが分かっていて、
&lt;a href=&#34;https://aws.amazon.com/jp/premiumsupport/signup/&#34;&gt;AWSサポート&lt;/a&gt;がBusiness以上なら
pre-warming申請することでnodeが増えた状態で待ち構えられる。&lt;/p&gt;

&lt;p&gt;バックエンドのアプリケーションがリクエストを処理できない場合、ELBのsurge queueに溜まっていく。
この数はCloudWatchのSurgeQueueLength(キュー長の急増)メトリクスで確認できる。
また、SurgeQueueLengthの最大値1024を超えるとリクエストは拒否され、その数はSpoiloverCount(過剰数)メトリクスに出る。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/elb-and-cloudwatch-metrics-in-depth/&#34;&gt;ELBの挙動とCloudWatchメトリクスの読み方を徹底的に理解する ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/premiumsupport/knowledge-center/elb-latency-troubleshooting/&#34;&gt;Elastic Load Balancing でのレイテンシーのトラブルシューティング&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Kinesis Streams/Firehose/Analyticsを試す</title>
          <link>http://sambaiz.net/article/67/</link>
          <pubDate>Mon, 20 Feb 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/67/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/&#34;&gt;https://aws.amazon.com/jp/kinesis/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;リアルタイムのストリーミングデータを扱うサービス群。
いまのところTokyoリージョンではKinesis Streamsしか使えない。&lt;/p&gt;

&lt;h3 id=&#34;kinesis-firehose-https-aws-amazon-com-jp-kinesis-firehose&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/&#34;&gt;Kinesis Firehose&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;AWSのデータストアに送るストリーム。自分でデータを読む処理を書かなくてよく、スケーリングも勝手にやってくれるので簡単に使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/faqs/&#34;&gt;https://aws.amazon.com/jp/kinesis/firehose/faqs/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Q: 送信先とは何ですか?
送信先はデータが配信されるデータストアです。Amazon Kinesis Firehose では、
現在送信先として Amazon S3、Amazon Redshift、Amazon Elasticsearch Service がサポートされています。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/firehose/pricing/&#34;&gt;料金&lt;/a&gt;は取り込まれたデータ量による。&lt;/p&gt;

&lt;p&gt;今回はS3に送ってみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-firehose.png&#34; alt=&#34;firehose作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;圧縮方法を設定したり、Lambdaを噛ませたりすることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-firehose2.png&#34; alt=&#34;firehose作成2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;StatusがActiveになったら&lt;a href=&#34;http://docs.aws.amazon.com/firehose/latest/dev/writing-with-agents.html&#34;&gt;Kinesis Agent&lt;/a&gt;で送ってみる。
CloudWatchとFirehoseにPutする権限が必要。Firehoseはkinesis:ではなくfirehose:なので注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum install –y aws-kinesis-agent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/aws-kinesis/agent.json&lt;/code&gt;を編集する。リージョンごとのエンドポイントは
&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#fh_region&#34;&gt;ここ&lt;/a&gt;
にある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;awsAccessKeyId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;awsSecretAccessKey&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;firehose.endpoint&amp;quot;: &amp;quot;https://firehose.us-east-1.amazonaws.com&amp;quot;, 
    &amp;quot;flows&amp;quot;: [
        {
            &amp;quot;filePattern&amp;quot;: &amp;quot;/tmp/hoge.log&amp;quot;, 
            &amp;quot;deliveryStream&amp;quot;: &amp;quot;hogefugastream&amp;quot;
        }
    ] 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service aws-kinesis-agent start
$ sudo chkconfig aws-kinesis-agent on
$ echo &amp;quot;aaa&amp;quot; &amp;gt;&amp;gt; /tmp/hoge.log
$ tail /var/log/aws-kinesis-agent/aws-kinesis-agent.log
com.amazon.kinesis.streaming.agent.Agent [INFO] Agent: Progress: 2 records parsed (168 bytes), 
and 2 records sent successfully to destinations. Uptime: 300044ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;S3に保存されているのを確認。&lt;/p&gt;

&lt;h3 id=&#34;kinesis-streams-https-aws-amazon-com-jp-kinesis-streams&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/streams/&#34;&gt;Kinesis Streams&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;用途を制限しないストリーム。データは保持期間の間、何度でも読むことができるので、
とりあえず必要なだけシャードを増やしてデータを入れておけばどうにかなる。
データを扱う側はそれぞれ独立に必要なタイミングで必要なだけpullするため、スケールするにあたってその先は別に考えることができ、
高負荷なシステムのlog aggregatorとして使われる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/streams/pricing/&#34;&gt;料金&lt;/a&gt;は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;時間単位のシャード速度： 1シャードは最大1000件/秒の1MB/秒の入力と2MB/秒の出力能力がある。&lt;/li&gt;
&lt;li&gt;PUTペイロードユニット: 追加する25KBのチャンクの数。5KBでも1チャンク。&lt;/li&gt;
&lt;li&gt;データ保持期間: デフォルトで24時間。7日まで延長可能。シャード時間ごとに課金。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;による。&lt;/p&gt;

&lt;p&gt;ストリーム作成時はシャード数を入れる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-streams.png&#34; alt=&#34;streams作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Firehoseと同じくKinesis Agentで送ってみる。
エンドポイントは&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#ak_region&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;awsAccessKeyId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;awsSecretAccessKey&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;kinesis.endpoint&amp;quot;: &amp;quot;https://kinesis.us-east-1.amazonaws.com&amp;quot;, 
    &amp;quot;flows&amp;quot;: [
        {
            &amp;quot;filePattern&amp;quot;: &amp;quot;/tmp/hoge.log&amp;quot;, 
            &amp;quot;kinesisStream&amp;quot;: &amp;quot;fugafugastream&amp;quot;
        }
    ] 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aws-cliでデータを&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/streams/latest/dev/fundamental-stream.html#get-records&#34;&gt;取得する&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;まず、シャードイテレーターを取得する。有効時間は300秒。
&lt;a href=&#34;http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#API_GetShardIterator_RequestSyntax&#34;&gt;TRIM_HORIZON&lt;/a&gt;
で最も古い方からデータを取得していく。SequenceNumberを指定して途中から読むこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aws kinesis get-shard-iterator --shard-id shardId-000000000000 --shard-iterator-type TRIM_HORIZON --stream-name fugafugastream
{
    &amp;quot;ShardIterator&amp;quot;: &amp;quot;AAAAAAAAAAFjKI0neNqY2N5HzGljYFCzoFqpQsdncdC6xE+ylnqvZpmusNfyViY3hBSS8WQXa67gvtkF0f2eKzxQ/Fd7SXZG8Inkb8l1UDF5t+jHgErA28gVSWyT4uYxTzzbnhm9AhcbztyQrjqehYcjEfpWIz5XmhY9K3Kjp0Crygy+OYNSS5PoQFcB1PZ7xMFE8zLTxJXLv1ANRu0Q+1m/JFxKQ3WS&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このシャードイテレータを使ってget-recordsする。データはBase64で入っているのでデコードして確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aws kinesis get-records --shard-iterator AAAAAAAAAAFjKI0neNqY2N5HzGljYFCzoFqpQsdncdC6xE+ylnqvZpmusNfyViY3hBSS8WQXa67gvtkF0f2eKzxQ/Fd7SXZG8Inkb8l1UDF5t+jHgErA28gVSWyT4uYxTzzbnhm9AhcbztyQrjqehYcjEfpWIz5XmhY9K3Kjp0Crygy+OYNSS5PoQFcB1PZ7xMFE8zLTxJXLv1ANRu0Q+1m/JFxKQ3WS
{
    &amp;quot;Records&amp;quot;: [
        {
            &amp;quot;Data&amp;quot;: &amp;quot;YWFhCg==&amp;quot;, 
            &amp;quot;PartitionKey&amp;quot;: &amp;quot;999679.8130737302&amp;quot;, 
            &amp;quot;ApproximateArrivalTimestamp&amp;quot;: 1487082145.518, 
            &amp;quot;SequenceNumber&amp;quot;: &amp;quot;49570460043263608661463102123405561406360875697772167170&amp;quot;
        }, 
        ...
    ], 
    &amp;quot;NextShardIterator&amp;quot;: &amp;quot;AAAAAAAAAAE08GRdLF1d76L1wCyLIiuAgpSEkKZSkUEO0VdUt3EOfdm1oOSXA1Xc4+tJPkSmB8g5NaQqDPRS/67u5IXermTUiAj6g2lgvDCGCqWFcYMAxIwIKZjKluCPQjL9kRaUqfVAaElRoKjp4Gv7JmuBDjKpxsbF2yk4uJJDAcevqH/VVkala8UbdhTweGyFgf9VhP/ljzXlrqkZ8wbD0eFwtZ3x&amp;quot;, 
    &amp;quot;MillisBehindLatest&amp;quot;: 0
}

$ echo &amp;quot;YWFhCg==&amp;quot; | base64 -d
aaa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kinesis-analytics-https-aws-amazon-com-jp-kinesis-analytics&#34;&gt;&lt;a href=&#34;https://aws.amazon.com/jp/kinesis/analytics/&#34;&gt;Kinesis Analytics&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SourceとなるKinesis Streamsか、Firehoseを指定し、SQLを実行できる。そして必要なら次のストリームに入れることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-create-analytics.png&#34; alt=&#34;analytics作成&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はSourceとしてjsonで株価のデータが入っているDemo streamを使う。
いくつかSQLテンプレートが用意されていて、その中のContinuous Filterを選択。
Streamに入ってきたものをTECHで絞って出力する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- ** Continuous Filter ** 
-- Performs a continuous filter based on a WHERE condition.
--          .----------.   .----------.   .----------.              
--          |  SOURCE  |   |  INSERT  |   |  DESTIN. |              
-- Source--&amp;gt;|  STREAM  |--&amp;gt;| &amp;amp; SELECT |--&amp;gt;|  STREAM  |--&amp;gt;Destination
--          |          |   |  (PUMP)  |   |          |              
--          &#39;----------&#39;   &#39;----------&#39;   &#39;----------&#39;               
-- STREAM (in-application): a continuously updated entity that you can SELECT from and INSERT into like a TABLE
-- PUMP: an entity used to continuously &#39;SELECT ... FROM&#39; a source STREAM, and INSERT SQL results into an output STREAM
-- Create output stream, which can be used to send to a destination
CREATE OR REPLACE STREAM &amp;quot;DESTINATION_SQL_STREAM&amp;quot; (ticker_symbol VARCHAR(4), sector VARCHAR(12), change REAL, price REAL);
-- Create pump to insert into output 
CREATE OR REPLACE PUMP &amp;quot;STREAM_PUMP&amp;quot; AS INSERT INTO &amp;quot;DESTINATION_SQL_STREAM&amp;quot;
-- Select all columns from source stream
SELECT STREAM ticker_symbol, sector, change, price
FROM &amp;quot;SOURCE_SQL_STREAM_001&amp;quot;
-- LIKE compares a string to a string pattern (_ matches all char, % matches substring)
-- SIMILAR TO compares string to a regex, may use ESCAPE
WHERE sector SIMILAR TO &#39;%TECH%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/64-run-analytics.png&#34; alt=&#34;analytics実行&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdのmonitor_agentのデータをGoでGoogle Stackdriverに送って監視する</title>
          <link>http://sambaiz.net/article/66/</link>
          <pubDate>Sun, 19 Feb 2017 23:55:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/66/</guid>
          <description>

&lt;h2 id=&#34;fluentdのmonitor-agent-http-docs-fluentd-org-v0-12-articles-monitoring&#34;&gt;&lt;a href=&#34;http://docs.fluentd.org/v0.12/articles/monitoring&#34;&gt;fluentdのmonitor_agent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;メトリクスをjsonで返すAPIを提供する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type monitor_agent
  bind 0.0.0.0
  port 24220
&amp;lt;/source&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:24220/api/plugins.json | jq
{
  &amp;quot;plugins&amp;quot;: [
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590d8c250&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;input&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;forward&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;forward&amp;quot;,
        &amp;quot;port&amp;quot;: &amp;quot;24222&amp;quot;,
        &amp;quot;bind&amp;quot;: &amp;quot;0.0.0.0&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: false,
      &amp;quot;retry_count&amp;quot;: null
    },
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590d894c4&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;input&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;monitor_agent&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;monitor_agent&amp;quot;,
        &amp;quot;bind&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
        &amp;quot;port&amp;quot;: &amp;quot;24220&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: false,
      &amp;quot;retry_count&amp;quot;: null
    },
    {
      &amp;quot;plugin_id&amp;quot;: &amp;quot;object:3f8590dc1f2c&amp;quot;,
      &amp;quot;plugin_category&amp;quot;: &amp;quot;output&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;file&amp;quot;,
      &amp;quot;config&amp;quot;: {
        &amp;quot;@type&amp;quot;: &amp;quot;file&amp;quot;,
        &amp;quot;path&amp;quot;: &amp;quot;/var/log/td-agent/hoge.log&amp;quot;,
        &amp;quot;buffer_path&amp;quot;: &amp;quot;/var/log/td-agent/hoge.log.*&amp;quot;
      },
      &amp;quot;output_plugin&amp;quot;: true,
      &amp;quot;buffer_queue_length&amp;quot;: 0,
      &amp;quot;buffer_total_queued_size&amp;quot;: 0,
      &amp;quot;retry_count&amp;quot;: 0
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをもとにStackdriverで異常を検知できるようにする。&lt;/p&gt;

&lt;h2 id=&#34;google-stackdriver-https-cloud-google-com-stackdriver&#34;&gt;&lt;a href=&#34;https://cloud.google.com/stackdriver/&#34;&gt;Google Stackdriver&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GoogleがStackdriverを買収して改造したもの。GCPだけではなくAWSのリソースも監視できる。
まだBeta。&lt;/p&gt;

&lt;h2 id=&#34;ec2インスタンスを監視する-https-cloud-google-com-monitoring-quickstart-aws-configure-sd-acct&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/quickstart-aws#configure-sd-acct&#34;&gt;EC2インスタンスを監視する&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GCPのメニューのSTACKDRIVER -&amp;gt; モニタリングで、プロジェクトを指定してStackdriverアカウントを作成する。&lt;/p&gt;

&lt;p&gt;今回はEC2で動いているfluentdを監視するので指示に従ってクロスアカウントアクセスのロールを作成、
Role ARNを入力してAWSアカウントと接続すると、
StackdriverのResouces-&amp;gt;InstancesでCPUの使用率などは確認できるが、
EC2にAgentを入れると詳細な情報を取得できる。&lt;/p&gt;

&lt;p&gt;GCPのメニューのサービスアカウントから接続したAWSアカウントを選択し、
Project-&amp;gt;編集者とLogging-&amp;gt;ログ書き込みロールのサービスアカウントを作成する。
新しい秘密鍵の提供にチェックを入れて、JSONのキーをダウンロードする。
これをEC2の&lt;code&gt;/etc/google/auth/application_default_credentials.json&lt;/code&gt;に置いて
&lt;code&gt;chown root:root&lt;/code&gt;、&lt;code&gt;chmod 400&lt;/code&gt;する。&lt;/p&gt;

&lt;p&gt;Monitoring AgentとLogging Agentをインストールし、
&lt;code&gt;stackdriver-collectd&lt;/code&gt;と&lt;code&gt;google-fluentd&lt;/code&gt;のプロセスがあれば正常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O https://repo.stackdriver.com/stack-install.sh
sudo bash stack-install.sh --write-gcm

curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh
sudo bash install-logging-agent.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メモリの使用量やTCPコネクション数などがとれていることを確認する。
Googleのドキュメントには見つからなかったけど、
旧Stackdriverと同様、&lt;code&gt;stackdriver_monitor: false&lt;/code&gt;のタグを付けると
&lt;a href=&#34;https://support.stackdriver.com/customer/portal/articles/1491785-collecting-data-from-specific-resources-only&#34;&gt;監視対象から外れる&lt;/a&gt;
っぽい。&lt;/p&gt;

&lt;h2 id=&#34;カスタムメトリクスを送る-https-cloud-google-com-monitoring-custom-metrics&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/&#34;&gt;カスタムメトリクスを送る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;MetricDescriptorを作成し、これにTimeSeriesデータを書き込んでいく。&lt;/p&gt;

&lt;h3 id=&#34;metricdescriptorの作成-https-cloud-google-com-monitoring-custom-metrics-creating-metrics-monitoring-create-metric-protocol&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#monitoring-create-metric-protocol&#34;&gt;MetricDescriptorの作成&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors&#34;&gt;MetricDescriptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;typeは&lt;code&gt;custom.googleapis.com/&lt;/code&gt;
から&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom_metric_names&#34;&gt;始める&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind&#34;&gt;metricKind&lt;/a&gt;
にはGAUGEのほかに変化量をとるDELTA、累積するCUMULATIVEを指定できる。&lt;/p&gt;

&lt;p&gt;labelはフィルタリングのためのもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;fluentd buffer_queue_length&amp;quot;,
  &amp;quot;displayName&amp;quot;: &amp;quot;fluentd-buffer_queue_length&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
  &amp;quot;metricKind&amp;quot;: &amp;quot;GAUGE&amp;quot;,
  &amp;quot;valueType&amp;quot;: &amp;quot;INT64&amp;quot;,
  &amp;quot;labels&amp;quot;: [
    {
      &amp;quot;key&amp;quot;: &amp;quot;plugin_type&amp;quot;,
      &amp;quot;valueType&amp;quot;: &amp;quot;STRING&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The type of the plugin&amp;quot;
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをGoで登録する。&lt;/p&gt;

&lt;p&gt;gcpのほうのprojectでProject-&amp;gt;編集者のサービスアカウントを作成してパスを
環境変数&lt;code&gt;GOOGLE_APPLICATION_CREDENTIALS&lt;/code&gt;に入れて
&lt;a href=&#34;https://developers.google.com/identity/protocols/application-default-credentials&#34;&gt;Default Credential&lt;/a&gt;
にする。&lt;/p&gt;

&lt;p&gt;必要なパッケージをgo get。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get google.golang.org/api/monitoring/v3
$ go get golang.org/x/oauth2/google
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		panic(err)
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		panic(err)
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/*****&amp;quot;

		requestBody = &amp;amp;monitoring.MetricDescriptor{
			Description: &amp;quot;fluentd buffer_queue_length&amp;quot;,
			DisplayName: &amp;quot;fluentd-buffer_queue_length&amp;quot;,
			Type:        &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
			MetricKind:  &amp;quot;GAUGE&amp;quot;,
			ValueType:   &amp;quot;INT64&amp;quot;,
			Labels: []*monitoring.LabelDescriptor{
				&amp;amp;monitoring.LabelDescriptor{
					Key:         &amp;quot;plugin_type&amp;quot;,
					ValueType:   &amp;quot;STRING&amp;quot;,
					Description: &amp;quot;The type of the plugin&amp;quot;,
				},
			},
		}
	)

	response, err := client.Projects.MetricDescriptors.Create(name, requestBody).Context(ctx).Do()
	if err != nil {
		panic(err)
	}

	fmt.Println(&amp;quot;done&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登録されたことをlistで確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response, err := client.Projects.MetricDescriptors.List(name).Context(ctx).Do()
if err != nil {
  panic(err)
}

for _, v := range response.MetricDescriptors {
  fmt.Println(v.DisplayName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;API Request Count
Agent Memory Usage
Stream Space Used
...
fluentd-buffer_queue_length
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;timeseriesの書き込み-https-cloud-google-com-monitoring-custom-metrics-creating-metrics-monitoring-write-timeseries-protocol&#34;&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/custom-metrics/creating-metrics#monitoring-write-timeseries-protocol&#34;&gt;TimeSeriesの書き込み&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/monitoring/api/ref_v3/rest/v3/TimeSeries&#34;&gt;TimeSeries&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;metricのtypeはMetricDescriptorのtypeと対応する。
pointsのendTimeはRFC3339のUTC文字列で渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
 &amp;quot;timeSeries&amp;quot;: [
  {
   &amp;quot;metric&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
    &amp;quot;labels&amp;quot;: {
     &amp;quot;plugin_type&amp;quot;: &amp;quot;file&amp;quot;
    }
   },
   &amp;quot;resource&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;aws_ec2_instance&amp;quot;,
    &amp;quot;labels&amp;quot;: {
     &amp;quot;project_id&amp;quot;: &amp;quot;*****&amp;quot;,
     &amp;quot;instance_id&amp;quot;: &amp;quot;*****&amp;quot;,
     &amp;quot;region&amp;quot;: &amp;quot;aws:ap-northeast-1&amp;quot;,
     &amp;quot;aws_account&amp;quot;: &amp;quot;*****&amp;quot;
    }
   },
   &amp;quot;points&amp;quot;: [
    {
     &amp;quot;interval&amp;quot;: {
      &amp;quot;endTime&amp;quot;: &amp;quot;2016-06-01T10:00:00-04:00&amp;quot;
     },
     &amp;quot;value&amp;quot;: {
      &amp;quot;int64Value&amp;quot;: 0
     }
    }
   ]
  }
 ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;resourceのtypeは
&lt;a href=&#34;https://cloud.google.com/logging/docs/reference/v2/rest/v2/monitoredResourceDescriptors/list#MonitoredResourceDescriptor&#34;&gt;MonitoredResourceDescriptor&lt;/a&gt;
と対応していて、
&lt;a href=&#34;https://cloud.google.com/logging/docs/reference/v2/rest/v2/monitoredResourceDescriptors/list&#34;&gt;list&lt;/a&gt;で確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
 &amp;quot;resourceDescriptors&amp;quot;: [
   {
   &amp;quot;type&amp;quot;: &amp;quot;aws_ec2_instance&amp;quot;,
   &amp;quot;displayName&amp;quot;: &amp;quot;Amazon EC2 Instance&amp;quot;,
   &amp;quot;description&amp;quot;: &amp;quot;A VM instance in Amazon EC2.&amp;quot;,
   &amp;quot;labels&amp;quot;: [
    {
     &amp;quot;key&amp;quot;: &amp;quot;project_id&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The identifier of the GCP project under which data is stored for the AWS account specified in the aws_account label (e.g., my-project).&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;instance_id&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The VM instance identifier assigned by AWS.&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;region&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The AWS region in which the VM is running. Supported AWS region values are listed by service at http://docs.aws.amazon.com/general/latest/gr/rande.html. The value supplied for this label must be prefixed with &#39;aws:&#39; (for example, &#39;aws:us-east-1&#39; is a valid value while &#39;us-east-1&#39; is not).&amp;quot;
    },
    {
     &amp;quot;key&amp;quot;: &amp;quot;aws_account&amp;quot;,
     &amp;quot;description&amp;quot;: &amp;quot;The AWS account number under which the VM is running.&amp;quot;
    }
   ]
  },
  ...
 ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;書くコード。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func writeFluentdBufferQueueLength() error {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		return err
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		return err
	}

	now := time.Now().UTC().Format(time.RFC3339)

	resource := &amp;amp;monitoring.MonitoredResource{
		Type: &amp;quot;aws_ec2_instance&amp;quot;,
		Labels: map[string]string{
			&amp;quot;project_id&amp;quot;:  &amp;quot;*****&amp;quot;,
			&amp;quot;instance_id&amp;quot;: &amp;quot;*****&amp;quot;,
			&amp;quot;region&amp;quot;:      &amp;quot;aws:ap-northeast-1&amp;quot;,
			&amp;quot;aws_account&amp;quot;: &amp;quot;*****&amp;quot;,
		},
	}

	metrics, err := fetchFluentdMetrics()
	if err != nil {
		return err
	}

	timeSeries := []*monitoring.TimeSeries{}

	for _, v := range metrics.Plugins {
		if v.OutputPlugin {

			fmt.Printf(&amp;quot;send %s\n&amp;quot;, v.Type)

			timeSeries = append(
				timeSeries,
				&amp;amp;monitoring.TimeSeries{
					Metric: &amp;amp;monitoring.Metric{
						Type: &amp;quot;custom.googleapis.com/fluentd/buffer_queue_length&amp;quot;,
						Labels: map[string]string{
							&amp;quot;plugin_type&amp;quot;: v.Type,
						},
					},
					Resource: resource,
					Points: []*monitoring.Point{
						&amp;amp;monitoring.Point{
							Interval: &amp;amp;monitoring.TimeInterval{
								EndTime: now,
							},
							Value: &amp;amp;monitoring.TypedValue{
								Int64Value: int64p(v.BufferQueueLength),
							},
						},
					},
				},
			)
		}
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/try-stackdriver-159110&amp;quot;

		requestBody = &amp;amp;monitoring.CreateTimeSeriesRequest{
			TimeSeries: timeSeries,
		}
	)

	_, err = client.Projects.TimeSeries.Create(name, requestBody).Context(ctx).Do()
	if err != nil {
		return err
	}

	fmt.Println(&amp;quot;done&amp;quot;)

	return nil
}

const fluentdMonitorEndpoint = &amp;quot;http://localhost:24220/api/plugins.json&amp;quot;

type fluentdMetrics struct {
	Plugins []fluentdMetricsPlugin `json:&amp;quot;plugins&amp;quot;`
}
type fluentdMetricsPlugin struct {
	Type              string `json:&amp;quot;type&amp;quot;`
	OutputPlugin      bool   `json:&amp;quot;output_plugin&amp;quot;`
	BufferQueueLength int64  `json:&amp;quot;buffer_queue_length&amp;quot;`
}

// monitor_agentからfluentdのメトリクスを取得する
func fetchFluentdMetrics() (*fluentdMetrics, error) {

	resp, err := http.Get(fluentdMonitorEndpoint)
	if err != nil {
		return nil, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var ret fluentdMetrics

	if err := json.Unmarshal(body, &amp;amp;ret); err != nil {
		return nil, err
	}

	return &amp;amp;ret, nil
}

// int64 -&amp;gt; *int64
func int64p(n int64) *int64 {
	return &amp;amp;n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;a href=&#34;https://github.com/jasonlvhit/gocron&#34;&gt;gocron&lt;/a&gt;などで定期的に実行させる。&lt;/p&gt;

&lt;p&gt;読むコード。確認用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func readFluentdBufferQueueLength() error {
	ctx := context.Background()
	httpClient, err := google.DefaultClient(ctx, monitoring.CloudPlatformScope)
	if err != nil {
		return err
	}
	client, err := monitoring.New(httpClient)
	if err != nil {
		return err
	}

	var (
		// The project on which to execute the request. The format is `&amp;quot;projects/{project_id_or_number}&amp;quot;`.
		name = &amp;quot;projects/*****&amp;quot;
	)

	start := time.Now().Add(time.Hour * -3).UTC().Format(time.RFC3339)
	now := time.Now().UTC().Format(time.RFC3339)

	filter := &amp;quot;metric.type = \&amp;quot;custom.googleapis.com/fluentd/buffer_queue_length\&amp;quot;&amp;quot;
	resp, err := client.Projects.TimeSeries.List(name).
		IntervalStartTime(start).
		IntervalEndTime(now).
		Filter(filter).Context(ctx).Do()
	if err != nil {
		return err
	}

	for _, v := range resp.TimeSeries {
		fmt.Println(v.Metric.Type)
		for _, p := range v.Points {
			fmt.Println(*(p.Value.Int64Value))
		}
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと届いていれば
Resource-&amp;gt;Metrics Explorerでもcustom/fluentd/buffer_queue_lengthを確認できる。&lt;/p&gt;

&lt;p&gt;これでAlertを設定できるようになった。TargetのResource TypeはCustom Metrics。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/66.png&#34; alt=&#34;Alertの設定&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのselectの中断処理(close, context)</title>
          <link>http://sambaiz.net/article/65/</link>
          <pubDate>Thu, 16 Feb 2017 20:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/65/</guid>
          <description>

&lt;h2 id=&#34;close-chan&#34;&gt;close(chan)&lt;/h2&gt;

&lt;p&gt;closeしたチャネルを読むとゼロ値になるので、selectで待っているやつにまとめて送れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	done := make(chan bool)

	wg := new(sync.WaitGroup)

	waitTillDone(wg, done)
	waitTillDone(wg, done)

    // こんなことしなくていい
	// done &amp;lt;- true
	// done &amp;lt;- true

	close(done)

	wg.Wait()
}

func waitTillDone(wg *sync.WaitGroup, done &amp;lt;-chan bool) {
	wg.Add(1)
	go func() {
		select {
		case v := &amp;lt;-done:
			fmt.Println(v) // false (ゼロ値)
			wg.Done()
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;context-https-godoc-org-golang-org-x-net-context&#34;&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;context&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;key-valueの値を渡せるほかにキャンセルやタイムアウトの仕組みをもつ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ctx := context.Background() // empty context
ctx, cancel = context.WithCancel(ctx)
ctx, cancel = context.WithDeadline(ctx, time.Now().Add(time.Second * 10))
ctx, cancel = context.WithTimeout(ctx, time.Second * 10)
ctx = context.WithValue(ctx, key, value)
ctx.Value(key).(Data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さっきdoneで待ってたところを&lt;code&gt;ctx.Done()&lt;/code&gt;にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	finished := make(chan interface{})
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // キャンセルしないとリークする

	go func() {
		if err := f1(ctx); err != nil {
			fmt.Printf(&amp;quot;main: %s\n&amp;quot;, err)
		} else {
			fmt.Println(&amp;quot;ok&amp;quot;)
		}
		close(finished)
	}()

	fmt.Println(&amp;quot;I will cancel!&amp;quot;)
	cancel()

	select {
	case &amp;lt;-finished:
		fmt.Println(&amp;quot;finished&amp;quot;)
	}
}

func f1(ctx context.Context) error {
	f2(ctx)
	select {
	case &amp;lt;-ctx.Done():
		fmt.Printf(&amp;quot;f1: %s\n&amp;quot;, ctx.Err())
		return ctx.Err()
	}
}

func f2(ctx context.Context) error {
	select {
	case &amp;lt;-ctx.Done():
		fmt.Printf(&amp;quot;f2: %s\n&amp;quot;, ctx.Err())
		return ctx.Err()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;I will cancel!
f2: context canceled
f1: context canceled
main: context canceled
finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、key-valueを受けわたすために使う場合は
type-safeにするために
NewContextで値を詰めて、FromContextで値を取り出すということがコメントに書いてある。
また、Contextはctxという名前で第一引数として渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type User struct {
	name string
}

type key int

var userKey key = 0

func NewContext(ctx context.Context, u *User) context.Context {
	return context.WithValue(ctx, userKey, u)
}

func FromContext(ctx context.Context) (*User, bool) {
	u, ok := ctx.Value(userKey).(*User)
	return u, ok
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.golang.org/pipelines&#34;&gt;Go Concurrency Patterns: Pipelines and cancellation - The Go Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/07/22/context/&#34;&gt;Go1.7のcontextパッケージ | SOTA&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentd自身のログを拾う</title>
          <link>http://sambaiz.net/article/64/</link>
          <pubDate>Tue, 14 Feb 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/64/</guid>
          <description>

&lt;p&gt;fluentdは自身のログも&lt;code&gt;fluent.error&lt;/code&gt;のようなタグでイベントとして流す。&lt;/p&gt;

&lt;p&gt;バッファを0にして意図的にエラーを発生させてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

# throw away
&amp;lt;match fluent.info&amp;gt;
  @type null
&amp;lt;/match&amp;gt;

&amp;lt;match fluent.**&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;

# error!
&amp;lt;match **&amp;gt;
  @type file
  path /var/log/td-agent/hoge.log
  buffer_chunk_limit 0
  buffer_queue_limit 0
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、こんなのがtd-agent.logに出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fluent.error: {&amp;quot;error&amp;quot;:&amp;quot;#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt;&amp;quot;,&amp;quot;error_class&amp;quot;:&amp;quot;Fluent::BufferQueueLimitError&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;forward error error=#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt; error_class=Fluent::BufferQueueLimitError&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただ、これだとaggregatorに集めたときにどのサーバーのfluentdに問題が発生してるのか分からない。
そこでホスト名を追加する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/55/&#34;&gt;fluentdのrecord_transformerでログを加工する - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter fluent.**&amp;gt;
  @type record_transformer
  enable_ruby

  &amp;lt;record&amp;gt;
    hostname &amp;quot;#{Socket.gethostname}&amp;quot;
    tag ${tag}
  &amp;lt;/record&amp;gt;
&amp;lt;/filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;fluent.error: {&amp;quot;error&amp;quot;:&amp;quot;#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt;&amp;quot;,&amp;quot;error_class&amp;quot;:&amp;quot;Fluent::BufferQueueLimitError&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;forward error error=#&amp;lt;Fluent::BufferQueueLimitError: queue size exceeds limit&amp;gt; error_class=Fluent::BufferQueueLimitError&amp;quot;,
&amp;quot;hostname&amp;quot;:&amp;quot;*****&amp;quot;,&amp;quot;tag&amp;quot;:&amp;quot;fluent.error&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://chopl.in/post/2013/04/27/fluentd_internal_log/&#34;&gt;fluentd自身のログにまつわるノウハウ - still deeper&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>GoでDynamoDBを使う</title>
          <link>http://sambaiz.net/article/63/</link>
          <pubDate>Sun, 12 Feb 2017 23:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/63/</guid>
          <description>

&lt;h2 id=&#34;テーブルを作成する&#34;&gt;テーブルを作成する&lt;/h2&gt;

&lt;h3 id=&#34;プライマリキー&#34;&gt;プライマリキー&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/GuidelinesForTables.html&#34;&gt;テーブルの操作のガイドライン - Amazon DynamoDB&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;プライマリキーとしてパーティションキー(ハッシュキー)とオプションのソートキー(レンジキー)を設定する。
DynamoDBはこのパーティションキーに基づいて、複数のパーティションに分散して保存する。
テーブルにプロビジョニングされたスループット性能はパーティション間で均等に使われるので、
ソートキーを設定する場合にこれを最大限に活用するためには、
あるパーティションにリクエストが集中しないよう、パーティションキーに特定の値ばかり集中しないようなフィールドを
選ぶ必要がある。&lt;/p&gt;

&lt;h3 id=&#34;セカンダリインデックス&#34;&gt;セカンダリインデックス&lt;/h3&gt;

&lt;p&gt;パーティションキーのグローバルセカンダリインデックス(GSI)と
ソートキーのローカルセカンダリインデックス(LSI)がある。
射影されるフィールドを選択でき、ここに含まれないフィールドは返さない。
ただし、すべてをインデックスに書き込むのはコストが高いのでなるべく絞る。&lt;/p&gt;

&lt;h3 id=&#34;キャパシティユニット-http-docs-aws-amazon-com-ja-jp-amazondynamodb-latest-developerguide-limits-html-limits-capacity-units-provisioned-throughpu&#34;&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/Limits.html#limits-capacity-units-provisioned-throughpu&#34;&gt;キャパシティユニット&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1読み込みキャパシティユニット: 4kbを超えないデータを1秒に1~2回(整合性による)読み込める&lt;/li&gt;
&lt;li&gt;1書き込みキャパシティユニット: 1kbを超えないデータを1秒に1回書き込める&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ユニットに応じて1時間あたりで&lt;a href=&#34;https://aws.amazon.com/jp/dynamodb/pricing/&#34;&gt;課金&lt;/a&gt;される。&lt;/p&gt;

&lt;p&gt;未使用のキャパシティがある場合、最大5分保持して&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/GuidelinesForTables.html#GuidelinesForTables.Bursting&#34;&gt;バーストに備えてくれる&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;読み書きする&#34;&gt;読み書きする&lt;/h2&gt;

&lt;p&gt;aws-sdk-goを直接使ってもいいけど、簡単に扱えるラッパー
&lt;a href=&#34;https://github.com/guregu/dynamo&#34;&gt;guregu/dynamo&lt;/a&gt;
を使うことにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Data struct {
	ID   int64 `dynamo:&amp;quot;id&amp;quot;`
	Name string
	Age  int
}

db := dynamo.New(session.New(), &amp;amp;aws.Config{Region: aws.String(&amp;quot;ap-northeast-1&amp;quot;)})
table := db.Table(&amp;quot;testtable&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-update&#34;&gt;Create &amp;amp; Update&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;d := Data{ID: 1, Name: &amp;quot;hogefuga&amp;quot;, Age: 123}
if err := table.Put(d).Run(); err != nil {
    return err
}

if err := table.Update(&amp;quot;id&amp;quot;, 1).Set(&amp;quot;name&amp;quot;, &amp;quot;fugafuga&amp;quot;).Run(); err != nil {
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get&#34;&gt;Get&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var data Data
// 結果整合性がある読み込み(1秒に2回/ユニット)　.Consistent(true)で強い整合性のある読み込み(1秒に1回/ユニット)にできる
if err := table.Get(&amp;quot;id&amp;quot;, 1).One(&amp;amp;data); err != nil {
    return err
}
fmt.Println(data)

if err := table.Get(&amp;quot;id&amp;quot;, 2).One(&amp;amp;data); err != nil {
    return err // dynamo: no item found
}
fmt.Println(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/AmazonWebServicesJapan/20150805-aws-blackbeltdynamodb&#34;&gt;AWS Black Belt Tech シリーズ 2015 - Amazon DynamoDB&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Elasticsearchのmapping</title>
          <link>http://sambaiz.net/article/62/</link>
          <pubDate>Thu, 09 Feb 2017 21:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/62/</guid>
          <description>

&lt;p&gt;Dynamic mappingがあるので、自分で設定しなくてもデータは入るけど、
自分でやるとindexやanalyzerなどの設定が詳細にできるし、意図しないmappingを避けることもできる。
バージョンは5.2。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPOST &#39;localhost:9200/test_hoge/fuga?pretty&#39; -d&#39;
{
    &amp;quot;name&amp;quot;: 0 
}
&#39;

$ curl -XPOST &#39;localhost:9200/test_hoge/fuga?pretty&#39; -d&#39;
{
    &amp;quot;name&amp;quot;: &amp;quot;sambaiz&amp;quot;
}
&#39;

{
  &amp;quot;error&amp;quot; : {
    &amp;quot;root_cause&amp;quot; : [
      {
        &amp;quot;type&amp;quot; : &amp;quot;mapper_parsing_exception&amp;quot;,
        &amp;quot;reason&amp;quot; : &amp;quot;failed to parse [name]&amp;quot;
      }
    ],
    &amp;quot;type&amp;quot; : &amp;quot;mapper_parsing_exception&amp;quot;,
    &amp;quot;reason&amp;quot; : &amp;quot;failed to parse [name]&amp;quot;,
    &amp;quot;caused_by&amp;quot; : {
      &amp;quot;type&amp;quot; : &amp;quot;number_format_exception&amp;quot;,
      &amp;quot;reason&amp;quot; : &amp;quot;For input string: \&amp;quot;sambaiz\&amp;quot;&amp;quot;
    }
  },
  &amp;quot;status&amp;quot; : 400
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mapping-parameters-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-params-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-params.html&#34;&gt;Mapping parameters&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;index-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-index-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-index.html&#34;&gt;index&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;falseにするとindexしない。クエリで必要ないものはfalseにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;memo&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;index&amp;quot;: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;store-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-store-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-store.html&#34;&gt;store&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;デフォルトでフィールドはindexされるがstoreはされず、metaの&lt;code&gt;_source&lt;/code&gt;としてオリジナルのJSONがstoreされている。
サイズの大きなフィールドがあるなど、選んでstoreする場合はtrueにする。stored_fieldsで必要なものだけとってくることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;memo&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;store&amp;quot;: true }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;meta-fields-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-fields-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-fields.html&#34;&gt;Meta fields&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;all-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-all-field-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-all-field.html&#34;&gt;_all&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;全てのフィールドをスペースでつなげた一つの文字列にしてanalyzeし、indexする。storeはされない。&lt;/p&gt;

&lt;p&gt;フィールドの区別なく検索できたりするけどindexするのにコストがかかるので必要ないならfalseにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;_all&amp;quot;: { &amp;quot;enabled&amp;quot;: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;source-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-source-field-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-source-field.html&#34;&gt;_source&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;オリジナルのJSONを含み、indexはされずstoreされる。&lt;/p&gt;

&lt;p&gt;無効にするとストレージを節約できるが、
まずは&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/index-modules.html#index-codec&#34;&gt;compression level&lt;/a&gt;を上げてみる。
無効にするとupdateやreindexができなくなったりするので有効のままにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;_source&amp;quot;: { &amp;quot;enabled&amp;quot;: false }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-analysis-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/analysis.html&#34;&gt;analysis&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;textをどのようにanalyzeするか。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/analyzer-anatomy.html&#34;&gt;Analyzer&lt;/a&gt;は
Character filtersで文字列を加工してTokenizerでトークンに分割してからToken filtersでトークンを取り除いたり変更したりするもの。
自分でこれらを組み合わせて&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/analysis-custom-analyzer.html&#34;&gt;定義する&lt;/a&gt;こともできる。&lt;/p&gt;

&lt;p&gt;日本語のAnalyzerとして&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/plugins/5.2/analysis-kuromoji.html&#34;&gt;kuromoji&lt;/a&gt;がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/elasticsearch-plugin install analysis-kuromoji
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;kuromoji&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XGET &#39;localhost:9200/_analyze?pretty&#39; -d &#39;
{
  &amp;quot;analyzer&amp;quot; : &amp;quot;kuromoji&amp;quot;,
  &amp;quot;text&amp;quot; : &amp;quot;Character filtersで文字列を加工します&amp;quot;
}&#39;

{
  &amp;quot;tokens&amp;quot; : [
    {
      &amp;quot;token&amp;quot; : &amp;quot;character&amp;quot;,
      &amp;quot;start_offset&amp;quot; : 0,
      &amp;quot;end_offset&amp;quot; : 9,
      &amp;quot;type&amp;quot; : &amp;quot;word&amp;quot;,
      &amp;quot;position&amp;quot; : 0
    },
    {
      &amp;quot;token&amp;quot; : &amp;quot;filters&amp;quot;,
      &amp;quot;start_offset&amp;quot; : 10,
      &amp;quot;end_offset&amp;quot; : 17,
      &amp;quot;type&amp;quot; : &amp;quot;word&amp;quot;,
      &amp;quot;position&amp;quot; : 1
    },
    {
      &amp;quot;token&amp;quot; : &amp;quot;文字&amp;quot;,
      &amp;quot;start_offset&amp;quot; : 18,
      &amp;quot;end_offset&amp;quot; : 20,
      &amp;quot;type&amp;quot; : &amp;quot;word&amp;quot;,
      &amp;quot;position&amp;quot; : 3
    },
    {
      &amp;quot;token&amp;quot; : &amp;quot;列&amp;quot;,
      &amp;quot;start_offset&amp;quot; : 20,
      &amp;quot;end_offset&amp;quot; : 21,
      &amp;quot;type&amp;quot; : &amp;quot;word&amp;quot;,
      &amp;quot;position&amp;quot; : 4
    },
    {
      &amp;quot;token&amp;quot; : &amp;quot;加工&amp;quot;,
      &amp;quot;start_offset&amp;quot; : 22,
      &amp;quot;end_offset&amp;quot; : 24,
      &amp;quot;type&amp;quot; : &amp;quot;word&amp;quot;,
      &amp;quot;position&amp;quot; : 6
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;datatype-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-mapping-types-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/mapping-types.html&#34;&gt;datatype&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;文字列-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-string-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/string.html&#34;&gt;文字列&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;5.Xからstringは廃止され
&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/text.html&#34;&gt;text&lt;/a&gt;と
&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/keyword.html&#34;&gt;keyword&lt;/a&gt;になった。&lt;/p&gt;

&lt;p&gt;textはメールの文章のようなfull-textの値で、ある単語がそれぞれの文章に含まれるかということを調べることができる。
メールアドレスのようなデータの場合はkeywordを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;email&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数値-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-number-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/number.html&#34;&gt;数値&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;long(64bit), integer(32bit), short(16bit, ~32767), byte(8bit, ~127), double, floatとか。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;age&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;short&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;日付-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-date-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/date.html&#34;&gt;日付&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;date&amp;quot;: {
  &amp;quot;type&amp;quot;:   &amp;quot;date&amp;quot;,
  &amp;quot;format&amp;quot;: &amp;quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;boolean-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-boolean-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/boolean.html&#34;&gt;Boolean&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;success&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;object-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-object-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/object.html&#34;&gt;Object&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;propertiesの中に書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hoge&amp;quot;: {
  &amp;quot;properties&amp;quot;: {
    &amp;quot;fuga&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot; }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nested-https-www-elastic-co-guide-en-elasticsearch-reference-5-2-nested-html&#34;&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/nested.html&#34;&gt;nested&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;objectの配列。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hoge&amp;quot;: {
  &amp;quot;type&amp;quot;: &amp;quot;nested&amp;quot;
  &amp;quot;properties&amp;quot;: {
    &amp;quot;fuga&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot; }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hoge&amp;quot;: [{&amp;quot;fuga&amp;quot;: true}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;登録&#34;&gt;登録&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT &#39;localhost:9200/test_index?pretty&#39; -d&#39;
{
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;test_type&amp;quot;: { 
      &amp;quot;_all&amp;quot;:       { &amp;quot;enabled&amp;quot;: false  }, 
      &amp;quot;properties&amp;quot;: { 
        &amp;quot;name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;, &amp;quot;store&amp;quot;: true },
        &amp;quot;description&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;analyzer&amp;quot;: &amp;quot;kuromoji&amp;quot; },
        &amp;quot;memo&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;index&amp;quot;: false }
      }
    }
  }
}
&#39;

$ curl -XPOST &#39;localhost:9200/test_index/test_type?pretty&#39; -d&#39;
{
    &amp;quot;name&amp;quot;: &amp;quot;sambaiz&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;青い海&amp;quot;,
    &amp;quot;memo&amp;quot;: &amp;quot;白い空&amp;quot;
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logstashのようにindex名に日付が付いているような場合は
&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/indices-templates.html&#34;&gt;indices-template&lt;/a&gt;で設定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT localhost:9200/_template/hogefuga-template -d &#39;
{
  &amp;quot;template&amp;quot; : &amp;quot;hogefuga-*&amp;quot;,
  &amp;quot;mappings&amp;quot; : {
    ...
  }
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;取得&#34;&gt;取得&lt;/h2&gt;

&lt;p&gt;まずはデータが入っていることを確認。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &#39;localhost:9200/test_index/test_type/_search?pretty&#39;
{
  &amp;quot;took&amp;quot; : 1,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;max_score&amp;quot; : 1.0,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;AVodMAubr8EtIroFs0eP&amp;quot;,
        &amp;quot;_score&amp;quot; : 1.0,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;name&amp;quot; : &amp;quot;sambaiz&amp;quot;,
          &amp;quot;description&amp;quot; : &amp;quot;青い海&amp;quot;,
          &amp;quot;memo&amp;quot; : &amp;quot;白い空&amp;quot;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stored_fieldsを付けてリクエスト。_sourceが含まれず、storeがtrueなnameだけが返ってくる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &#39;localhost:9200/test_index/_search?pretty&amp;amp;stored_fields=name,description,memo&#39;
{
  &amp;quot;took&amp;quot; : 1,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;max_score&amp;quot; : 1.0,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;AVodMAubr8EtIroFs0eP&amp;quot;,
        &amp;quot;_score&amp;quot; : 1.0,
        &amp;quot;fields&amp;quot; : {
          &amp;quot;name&amp;quot; : [
            &amp;quot;sambaiz&amp;quot;
          ]
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クエリを付けてリクエスト。indexされてないmemoではひっかからない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPOST &#39;localhost:9200/test_index/test_type/_search?pretty&#39; -d &#39;
{
  &amp;quot;query&amp;quot;:{
    &amp;quot;query_string&amp;quot;:{
      &amp;quot;default_field&amp;quot; : &amp;quot;description&amp;quot;,
      &amp;quot;query&amp;quot;: &amp;quot;青い海&amp;quot;
    }
  }
}&#39;

{
  &amp;quot;took&amp;quot; : 2,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPOST &#39;localhost:9200/test_index/test_type/_search?pretty&#39; -d &#39;
{
  &amp;quot;query&amp;quot;:{
    &amp;quot;query_string&amp;quot;:{
      &amp;quot;default_field&amp;quot; : &amp;quot;memo&amp;quot;,
      &amp;quot;query&amp;quot;: &amp;quot;白い空&amp;quot;
    }
  }
}&#39;

{
  &amp;quot;took&amp;quot; : 1,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 0,
    &amp;quot;max_score&amp;quot; : null,
    &amp;quot;hits&amp;quot; : [ ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.johtani.info/blog/2014/09/09/performance-considerations-for-elasticsearch-indexing/&#34;&gt;Elasticsearchのインデキシングに関するパフォーマンス検討 - @johtaniの日記 2nd&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのnet/httpとKeep-Alive</title>
          <link>http://sambaiz.net/article/61/</link>
          <pubDate>Tue, 07 Feb 2017 22:42:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/61/</guid>
          <description>

&lt;p&gt;Keep-AliveするとTCPコネクションを使い回し、名前解決やコネクション(3 way handshake)を毎回行わなくてよくなる。
Goの&lt;code&gt;net/http&lt;/code&gt;ではデフォルトでKeep-Aliveが
&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L129&#34;&gt;有効になっている&lt;/a&gt;が、
全体と同一ホストでそれぞれKeep-Aliveするコネクション数が制限される。
これらの値は&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L36&#34;&gt;Client&lt;/a&gt;のTransportが持っていて、
これがnullだと&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/transport.go#L39&#34;&gt;DefaultTransport&lt;/a&gt;が参照されるので、意識しなければこの値が使われる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L143&#34;&gt;MaxIdleConns&lt;/a&gt;: DefaultTransportでは&lt;a href=&#34;https://github.com/golang/go/blob/master/src/net/http/transport.go#L46&#34;&gt;100になっている&lt;/a&gt;。0にすると無制限。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L148&#34;&gt;MaxIdleConnsPerHost&lt;/a&gt;: &lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L54&#34;&gt;デフォルト値は2&lt;/a&gt;。0にするとデフォルト値が使われる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同一のホストに同時にたくさんリクエストする場合、2だとほとんど意味を持たない。これを増やして比較してみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;time&amp;quot;
)

var client = http.Client{
	Timeout: time.Millisecond * 100,
}

const TOTAL_REQUEST_NUM = 3000
const TARGET_URL = &amp;quot;*****&amp;quot;

func main() {

	http.DefaultTransport.(*http.Transport).MaxIdleConns = 0
	http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 3000

	okChan := make(chan int, TOTAL_REQUEST_NUM)
	ngChan := make(chan int, TOTAL_REQUEST_NUM)

	var okCount = 0
	var ngCount = 0

	// connect and keep-alive
	for i := 0; i &amp;lt; TOTAL_REQUEST_NUM; i++ {
		go request(okChan, ngChan)
	}

	for {
		select {
		case &amp;lt;-okChan:
			okCount++
		case &amp;lt;-ngChan:
			ngCount++
		}

		if okCount+ngCount == TOTAL_REQUEST_NUM {
			break
		}
	}

	okCount = 0
	ngCount = 0

	startNs := time.Now().UnixNano()

	for i := 0; i &amp;lt; TOTAL_REQUEST_NUM; i++ {
		go request(okChan, ngChan)
	}

	for {
		select {
		case &amp;lt;-okChan:
			okCount++
		case &amp;lt;-ngChan:
			ngCount++
		}

		if okCount+ngCount == TOTAL_REQUEST_NUM {
			break
		}
	}

	endNs := time.Now().UnixNano()

	fmt.Printf(&amp;quot;[RESULT] request: %d, ok: %d, ng: %d, time(ms) %d\n&amp;quot;,
		TOTAL_REQUEST_NUM, okCount, ngCount, (endNs-startNs)/(1000*1000))
}

func request(okch chan int, ngch chan int) {
	req, err := http.NewRequest(&amp;quot;GET&amp;quot;, TARGET_URL, nil)
	if err != nil {
		panic(err.Error())
	}

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println(err.Error())
		ngch &amp;lt;- 1
		return
	}
	defer resp.Body.Close()

	_, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err.Error())
		ngch &amp;lt;- 1
		return
	}

	okch &amp;lt;- 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;デフォルト設定: &lt;code&gt;[RESULT] request: 3000, ok: 530, ng: 2470, time(ms) 173&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MaxIdleConnsPerHostを3000に: &lt;code&gt;[RESULT] request: 3000, ok: 3000, ng: 0, time(ms) 88&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;全てのリクエストが時間内に捌けるようになったので効果があったようだ。&lt;/p&gt;

&lt;p&gt;ただ、このコードのようにgoroutineを無尽蔵に生成すると、限界を超えたときにタイムアウトが頻発してしまうので注意。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/74&#34;&gt;Goroutineの数をworkerで抑制する - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ちなみに、&lt;a href=&#34;https://github.com/tcnksm/go-httpstat&#34;&gt;tcnksm/go-httpstat&lt;/a&gt;でnet/http/httptraceすると各処理にかかっている時間が分かる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req, err := http.NewRequest(&amp;quot;GET&amp;quot;, TARGET_URL, nil)
if err != nil {
	panic(err.Error())
}

result := new(httpstat.Result)
ctx := httpstat.WithHTTPStat(req.Context(), result)
req = req.WithContext(ctx)

resp, err := client.Do(req)
if err != nil {
	fmt.Println(err.Error())
	ngch &amp;lt;- 1
	return
}
defer resp.Body.Close()

_, err = ioutil.ReadAll(resp.Body)
if err != nil {
	fmt.Println(err.Error())
	ngch &amp;lt;- 1
	return
}

result.End(time.Now())
fmt.Printf(&amp;quot;%+v\n&amp;quot;, result)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Start Transfer:   85 ms
Total:            86 ms

DNS lookup:           0 ms
TCP connection:       0 ms
TLS handshake:        0 ms
Server processing:   64 ms
Content transfer:     1 ms

Name Lookup:       0 ms
Connect:           0 ms
Pre Transfer:      0 ms
Start Transfer:   64 ms
Total:            65 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://shogo82148.github.io/blog/2017/01/14/re-golang-dns-cache/&#34;&gt;Re:golang の http.Client を速くする - Shogo&amp;rsquo;s Blog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>iftopでネットワークの帯域を見る</title>
          <link>http://sambaiz.net/article/60/</link>
          <pubDate>Tue, 07 Feb 2017 20:30:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/60/</guid>
          <description>&lt;pre&gt;&lt;code&gt;$ yum install --enablerepo=epel iftop
$ iftop -f &amp;quot;not dst net 10.0.0.0/8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-i eth0&lt;/code&gt;のようにしてインタフェースを指定し、&lt;code&gt;-f&lt;/code&gt;でフィルタをかけられる。フィルタの詳細は&lt;code&gt;man pcap-filter&lt;/code&gt;で。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                          12.5Kb                     25.0Kb                     37.5Kb                     50.0Kb		62.5Kb
└─────────────────────────┴──────────────────────────┴──────────────────────────┴──────────────────────────┴──────────────────────────
ip-172-31-9-9.ap-northeast-1.compute.internal         =&amp;gt; 61-121-217-66.dh-connect.net                          1.72Kb  6.57Kb  2.40Kb
                                                      &amp;lt;=                                                        416b   2.13Kb   702b
...
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
TX:             cum:   22.6KB   peak:   13.2Kb                                                        rates:   1.22Kb  1.27Kb  2.46Kb
RX:                    6.63KB           5.03Kb                                                                  208b    330b    748b
TOTAL:                 29.2KB           18.2Kb                                                                 1.42Kb  1.59Kb  3.19Kb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左から2, 10, 40秒間の平均kbps。TXが送信量、RXが受信量で、cumが総量、peakが最大。&lt;/p&gt;

&lt;p&gt;実行中に&lt;code&gt;S&lt;/code&gt;でソースのポートを&lt;code&gt;D&lt;/code&gt;でディスティネーションのポートが表示される。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>vmstatのメモ</title>
          <link>http://sambaiz.net/article/59/</link>
          <pubDate>Mon, 06 Feb 2017 22:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/59/</guid>
          <description>

&lt;pre&gt;&lt;code&gt;$ vmstat 間隔(秒)
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 118588  80388 2516284    0    0     2    77  141   85  1  0 98  0  0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;procs&#34;&gt;procs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;r: 実行待ちプロセス数。CPUの処理が追いついていない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;b: 割り込み不可能なスリープ中のプロセス数。I/O待ちらしい。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;memory&#34;&gt;memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;swpd: バーチャルメモリの使用量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;free: 空きメモリ量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;buff: バッファに使われてるメモリ量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cache: キャッシュに使われているメモリ量。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;swap&#34;&gt;swap&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;si: 秒あたりのスワップイン量。メモリが足りていない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;so: 秒あたりのスワップアウト量。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;io&#34;&gt;io&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;bi: 秒あたりのブロックデバイスから受け取ったブロック数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;bo: 秒あたりのブロックデバイスに送ったブロック数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;system&#34;&gt;system&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in: 秒あたりの割り込み回数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cs: 秒あたりの&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%B3%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B9%E3%82%A4%E3%83%83%E3%83%81&#34;&gt;コンテキストスイッチ&lt;/a&gt;の回数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cpu&#34;&gt;cpu&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;us: カーネル以外のコードでかかっている時間。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sy: カーネルコードでかかっている時間。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;id: アイドルタイム。0だとCPUが全力で仕事中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;wa: IO待ち時間。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;st: 要求したがCPUリソースを割り当ててもらえなかった時間。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://orebibou.com/2015/07/vmstat%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%A7%E8%A6%9A%E3%81%88%E3%81%A6%E3%81%8A%E3%81%8D%E3%81%9F%E3%81%84%E4%BD%BF%E3%81%84%E6%96%B98%E5%80%8B/&#34;&gt;vmstatコマンドで覚えておきたい使い方8個(+1個) | 俺的備忘録 〜なんかいろいろ〜&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blogs.oracle.com/yappri/entry/vmstat&#34;&gt;vmstat コマンドの読み方 (やっぱり Sun がスキ！)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>EC2のインスタンスストア</title>
          <link>http://sambaiz.net/article/58/</link>
          <pubDate>Mon, 06 Feb 2017 21:52:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/58/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/InstanceStorage.html&#34;&gt;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/InstanceStorage.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EC2ではインスタンスタイプによってはEBSに加えてインスタンスストアが使える。しかも追加料金なし。
対象はストレージが&amp;rdquo;EBSのみ&amp;rdquo;でないもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/ec2/instance-types/&#34;&gt;https://aws.amazon.com/jp/ec2/instance-types/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;インスタンスストアはインスタンスが停止したり、障害が起きると消える一時ストレージ。再起動では消えない。
ホストに物理的にアタッチされているので、バッファやキャッシュなどの頻繁に読み書きされ、消えてもいいデータに最適。
他のインスタンスにアタッチすることはできない。容量や性能もインスタンスタイプに依存する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/add-instance-store-volumes.html&#34;&gt;インスタンスストアボリュームの追加&lt;/a&gt;は
インスタンスの起動時に、新しいボリュームを追加し、ボリュームタイプをインスタンスストアにすることで行うことができる。&lt;/p&gt;

&lt;p&gt;今回はSSDストレージ1 x 4のm3.mediumで試す。これは4gbのボリュームが一つ追加できるという意味。&lt;/p&gt;

&lt;p&gt;まずはインスタンスストアを追加してないインスタンス。
lsblkというのはlist block devicesの略。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -h
ファイルシス   サイズ  使用  残り 使用% マウント位置
/dev/xvda1       7.8G  1.2G  6.6G   15% /
...
$ dd if=/dev/zero of=hoge bs=1M count=1000
$ ls -sh
合計 1001M
1001M hoge

$ df -h
ファイルシス   サイズ  使用  残り 使用% マウント位置
/dev/xvda1       7.8G  2.2G  5.6G   28% /
...

$ lsblk
NAME    MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
xvda    202:0    0   8G  0 disk 
└─xvda1 202:1    0   8G  0 part /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それに対してインスタンスストア(/dev/xvdb)を追加したインスタンス。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -h
ファイルシス   サイズ  使用  残り 使用% マウント位置
/dev/xvda1       7.8G  1.2G  6.6G   15% /
/dev/xvdb        4.0G   73M  3.7G    2% /media/ephemeral0

$ lsblk
NAME    MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
xvda    202:0    0   8G  0 disk 
└─xvda1 202:1    0   8G  0 part /
xvdb    202:16   0   4G  0 disk /media/ephemeral0

$ dd if=/dev/zero of=/media/ephemeral0/hoge bs=1M count=1000
$ df -h
ファイルシス   サイズ  使用  残り 使用% マウント位置
/dev/xvda1       7.8G  1.2G  6.6G   15% /
/dev/xvdb        4.0G  1.1G  2.7G   29% /media/ephemeral0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/imaifactory/ephemeral-ssd&#34;&gt;EC2のストレージどう使う? -Instance Storageを理解して高速IOを上手に活用!-&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HoloLensでGaze, Click, Hold, Voiceイベントを拾う</title>
          <link>http://sambaiz.net/article/57/</link>
          <pubDate>Sun, 05 Feb 2017 20:01:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/57/</guid>
          <description>

&lt;p&gt;こんなの。SparitalMappingを有効にしているので球が床で止まっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/57.png&#34; alt=&#34;こんなの&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/wQLn_SO9Ics&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity&#34;&gt;HoloToolKit&lt;/a&gt;
のインタフェースを実装することでイベントを拾えるようになっている。&lt;/p&gt;

&lt;h2 id=&#34;ifocusable&#34;&gt;IFocusable&lt;/h2&gt;

&lt;p&gt;Gazeしたとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void OnFocusEnter（）
{
    gazing = true;
}

public void OnFocusExit()
{
    gazing = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iinputclickhandler&#34;&gt;IInputClickHandler&lt;/h2&gt;

&lt;p&gt;クリックしたとき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void OnInputClicked(InputEventData eventData)
{
    if (!clicked)
    {
        clicked = true;
        clickedRotationFrame = 0;
    }
    countUp();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iholdhandler&#34;&gt;IHoldHandler&lt;/h2&gt;

&lt;p&gt;Hold(指を下げたまま維持する)したとき。
指を上げたときがCompletedで、Objectを外れたときCanceledになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void OnHoldStarted(HoldEventData eventData)
{
    holding = true;
    clicked = true;
}

public void OnHoldCompleted(HoldEventData eventData)
{
    holding = false;
}

public void OnHoldCanceled(HoldEventData eventData)
{
    holding = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ispeechhandler&#34;&gt;ISpeechHandler&lt;/h2&gt;

&lt;p&gt;声の入力。
InspectorからSpeech Input Source(Script)を追加して反応するキーワードを設定して使う。
MicrophoneのCapabilitiesが必要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void OnSpeechKeywordRecognized(SpeechKeywordRecognizedEventData eventData)
{
    switch (eventData.RecognizedText)
    {
        case &amp;quot;reset&amp;quot;:
            count = 0;
            num.GetComponent&amp;lt;TextMesh&amp;gt;().text = count.ToString();
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using HoloToolkit.Unity.InputModule;
using UnityEngine;

public class CounterCube : MonoBehaviour, IFocusable, IInputClickHandler, IHoldHandler, ISpeechHandler
{
    // rotate ANIMATION_FRAME * ANIMATION_PER_FRAME degrees
    private const int ANIMATION_FRAME = 30;
    private const float ANIMATION_ROTATE_PER_FRAME = 60f / ANIMATION_FRAME;

    public GameObject cube;
    public GameObject num;

    private int count = 0;

    private bool gazing = false;
    private bool clicked = false;
    private int clickedRotationFrame = 0;
    private bool holding = false;
	
	// Update is called once per frame
	void Update ()
    {
        if(clicked)
        {
            if(clickedRotationFrame &amp;lt; ANIMATION_FRAME)
            {
                clickedRotationFrame++;
                cube.transform.localRotation = Quaternion.Euler(clickedRotationFrame * ANIMATION_ROTATE_PER_FRAME, clickedRotationFrame * ANIMATION_ROTATE_PER_FRAME, 0);
            }
            else if (holding)
            {
                // continue to count up
                clickedRotationFrame = 0;
                countUp();
            }
            else
            {
                clicked = false;
            }

        }

        if (holding)
        {
            cube.GetComponent&amp;lt;Renderer&amp;gt;().material.color = Color.green;
        }
        else if (gazing)
        {
            cube.GetComponent&amp;lt;Renderer&amp;gt;().material.color = Color.blue;
        }
        else
        {
            cube.GetComponent&amp;lt;Renderer&amp;gt;().material.color = Color.gray;
        }
    }

    public void OnFocusEnter()
    {
        gazing = true;
    }

    public void OnFocusExit()
    {
        gazing = false;
    }

    public void OnInputClicked(InputEventData eventData)
    {
        if (!clicked)
        {
            clicked = true;
            clickedRotationFrame = 0;
        }
        countUp();
    }

    public void OnHoldStarted(HoldEventData eventData)
    {
        holding = true;
        clicked = true;
    }

    public void OnHoldCompleted(HoldEventData eventData)
    {
        holding = false;
    }

    public void OnHoldCanceled(HoldEventData eventData)
    {
        holding = false;
    }

    private void countUp()
    {
        num.GetComponent&amp;lt;TextMesh&amp;gt;().text = (++count).ToString();
        var sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        sphere.transform.position = transform.position;
        sphere.transform.localScale = Vector3.one * 0.1f;
        sphere.AddComponent&amp;lt;Rigidbody&amp;gt;();
    }

    public void OnSpeechKeywordRecognized(SpeechKeywordRecognizedEventData eventData)
    {
        switch (eventData.RecognizedText)
        {
            case &amp;quot;reset&amp;quot;:
                count = 0;
                num.GetComponent&amp;lt;TextMesh&amp;gt;().text = count.ToString();
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HoloLensの開発を始める</title>
          <link>http://sambaiz.net/article/56/</link>
          <pubDate>Sat, 04 Feb 2017 21:28:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/56/</guid>
          <description>

&lt;h2 id=&#34;hololensでのアプリケーション&#34;&gt;HoloLensでのアプリケーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/app_model&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/app_model&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ある点を見るGazeと指で選択するGesture、声で入力するVoiceで操作する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/hololens_shell_overview&#34;&gt;HoloLens shell&lt;/a&gt;
では壁などにタイルを配置することでアプリケーションが起動する。&lt;/p&gt;

&lt;p&gt;一度に動くアプリケーションは一つ。
他にアクティブなアプリケーションがあれば中断され、タイルは最後の状態のスクリーンショットになる。
タイルを削除するとプロセスが終了する。&lt;/p&gt;

&lt;p&gt;Viewには空間全体を使うHolographic Viewと、通常のウィンドウのような2D Viewがある。&lt;/p&gt;

&lt;h2 id=&#34;開発を始める&#34;&gt;開発を始める&lt;/h2&gt;

&lt;p&gt;Unityを使ってHolographic Viewのアプリケーションを開発する。&lt;/p&gt;

&lt;p&gt;必要なツールをインストールする。エミュレーターは空きメモリが2GB以上ないと立ち上がらない。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/install_the_tools&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/install_the_tools&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;チュートリアル&#34;&gt;チュートリアル&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/holograms_100&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/holograms_100&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;QualityのところでWindows Storeのマークがなかったら、
UnityのFile-&amp;gt;Build SettingsからWindows Storeモジュールをダウンロードする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/holograms_101e&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/holograms_101e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;エミュレーターはWASDキーで移動してカーソルキーで向きを変え、エンターキーで選択できる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/56-hololens.PNG&#34; alt=&#34;エミュレーターで実行した画面&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;エミュレーターで動かしてみる&#34;&gt;エミュレーターで動かしてみる&lt;/h2&gt;

&lt;p&gt;UnityProjectを作成してHolograms 100のように設定していく。&lt;/p&gt;

&lt;p&gt;まずはCamera。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Position: (0,0,0)&lt;/li&gt;
&lt;li&gt;Clear Flags: Solid Color&lt;/li&gt;
&lt;li&gt;Background: (0,0,0,0)&lt;/li&gt;
&lt;li&gt;Clipping Planes Near: 0.85&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とりあえず動くことを確認するため適当なオブジェクトを置いてビルドしてみる。&lt;/p&gt;

&lt;p&gt;Edit-&amp;gt;Project Settings-&amp;gt;QualityでWindows StoreをFastestにする。&lt;/p&gt;

&lt;p&gt;Build Settings-&amp;gt;Windows Storeで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SDK: Universal: 10&lt;/li&gt;
&lt;li&gt;Target device: HoloLens&lt;/li&gt;
&lt;li&gt;UWP Build Type: D3D&lt;/li&gt;
&lt;li&gt;Unity C# Projectにチェック&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;にする。&lt;/p&gt;

&lt;p&gt;BuildSettingsにあるPlayer Settingsボタンを押して
Other SettingsのVirtual Reality Supportedにチェックを入れ、
SDKsにWindows Holographicが出るのを確認する。&lt;/p&gt;

&lt;p&gt;あとはBuild SettingsでAdd Open ScenesしてBuild。適当なディレクトリを作って選ぶとUWPのVSプロジェクトができるので
上のところでRelease,x86,HoloLens Emulatrorにしてデバッグメニューからデバッグなしで開始する。
エミュレーターが立ち上がって置いたオブジェクトが見えたらうまくいっている。&lt;/p&gt;

&lt;h3 id=&#34;uwp-ユニバーサル-windows-プラットフォーム-とは-https-docs-microsoft-com-ja-jp-windows-uwp-get-started-universal-application-platform-guide&#34;&gt;&lt;a href=&#34;https://docs.microsoft.com/ja-jp/windows/uwp/get-started/universal-application-platform-guide&#34;&gt;UWP(ユニバーサル Windows プラットフォーム)とは&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Windows 8でWindowsランタイム(WinRT)として導入された、
PCだけではなく、タブレット、Xbox、HoloLensなど、様々なWindowsデバイス共通のアプリプラットフォーム。&lt;/p&gt;

&lt;p&gt;PCではデスクトップデバイスファミリ、タブレットではモバイルデバイスファミリといったような、デバイスファミリに基づいたOSが実行される。
UWPアプリでは、共通のWinRT APIだけではなく各デバイスファミリ固有のAPIも呼び出すこともでき、
アプリのターゲットとするデバイスファミリを選択することができる。&lt;/p&gt;

&lt;h2 id=&#34;holotoolkitを使う&#34;&gt;HoloToolKitを使う&lt;/h2&gt;

&lt;p&gt;実装やビルドを楽にするやつ。上のような初期設定はやらなくていい。&lt;/p&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/blob/master/GettingStarted.md&#34;&gt;https://github.com/Microsoft/HoloToolkit-Unity/blob/master/GettingStarted.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/HoloToolkit-Unity/releases&#34;&gt;ここ&lt;/a&gt;からunitypackageをダウンロードして
UnityのAssetsメニューからインポートする。&lt;/p&gt;

&lt;p&gt;HoloToolKitメニューができるのでConfigureする。&lt;/p&gt;

&lt;p&gt;Main CameraとDirectional Lightを消して
&lt;code&gt;HoloToolkit/Input/Prefabs/HoloLensCamera.prefab&lt;/code&gt;と、
&lt;code&gt;HoloToolkit/Input/Prefabs/Cursor/DefaultCursor.prefab&lt;/code&gt;を置く。&lt;/p&gt;

&lt;p&gt;Create Emptyして&amp;rdquo;Managers&amp;rdquo;にリネームし、この中に
&lt;code&gt;HoloToolkit/Input/Prefabs/InputManager.prefab&lt;/code&gt;を入れる。&lt;/p&gt;

&lt;p&gt;Managersの中にUI -&amp;gt; EventSystemを作成する。&lt;/p&gt;

&lt;p&gt;SparitalMappingする場合は、
&lt;code&gt;HoloToolkit/SpartialMapping/Prefabs/SpartialMapping.prefab&lt;/code&gt;をMangersに入れて
Editor -&amp;gt;　Project Settings -&amp;gt;　PlayerのPublishing Settingsから
SpartialPerceptionにチェックを入れる。&lt;/p&gt;

&lt;p&gt;HoloToolkitメニューからBuild Window -&amp;gt; Build Visual Studio SLNで
ビルドし、Open SLNでVisual Studioが立ち上がる。
ビルドの際にクラッシュしたらWindows Storeモジュールが入っているか確認する。&lt;/p&gt;

&lt;h2 id=&#34;実機での実行&#34;&gt;実機での実行&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/Using_Visual_Studio.html#deploying_an_app_over_wi-fi&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/Using_Visual_Studio.html#deploying_an_app_over_wi-fi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Visual StudioでDeviceをHoloLens EmulatorからRemote Deviceに変更する。
HoloLensのIPアドレスはSettings -&amp;gt; Network &amp;amp; Internet -&amp;gt; Advanced Optionで確認して、
認証モードはユニバーサルにしてデバッグなしで開始する。&lt;/p&gt;

&lt;p&gt;PINコードを要求されるので、Settings -&amp;gt;Update &amp;amp; Security -&amp;gt; For developersから
Developer modeをonにし、その下のPaired devicesで表示されるPINコードを入力する。&lt;/p&gt;

&lt;h2 id=&#34;スクリーンショットの撮り方&#34;&gt;スクリーンショットの撮り方&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/using_mixed_reality_capture&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/using_mixed_reality_capture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;カメラで撮れる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/56-hololens2.jpg&#34; alt=&#34;実機で実行した画面&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;windows-device-portal&#34;&gt;Windows Device Portal&lt;/h2&gt;

&lt;p&gt;PCのブラウザからいろいろできるツール。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/windows/holographic/Using_the_Windows_Device_Portal.html#mixed_reality_capture&#34;&gt;https://developer.microsoft.com/en-us/windows/holographic/Using_the_Windows_Device_Portal.html#mixed_reality_capture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Settings -&amp;gt;Update &amp;amp; Security -&amp;gt; For developersからDevice Portalをonにすると
&lt;a href=&#34;https://HoloLensのIPアドレス&#34;&gt;https://HoloLensのIPアドレス&lt;/a&gt;
でアクセスできる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdのrecord_transformerでログを加工する</title>
          <link>http://sambaiz.net/article/55/</link>
          <pubDate>Fri, 03 Feb 2017 21:14:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/55/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/v0.12/articles/filter_record_transformer&#34;&gt;http://docs.fluentd.org/v0.12/articles/filter_record_transformer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;追加したり、編集したり、削除したりできるフィルタ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;filter hoge.log&amp;gt;
  @type record_transformer
  enable_ruby
  auto_typecast true
  remove_keys b,d

  &amp;lt;record&amp;gt;
    what_is_tag ${tag}
    what_is_a ${record[&amp;quot;a&amp;quot;]}
    what_is_c_of_b_add_1 ${record[&amp;quot;b&amp;quot;][&amp;quot;c&amp;quot;] + 1}
  &amp;lt;/record&amp;gt;
&amp;lt;/filter&amp;gt;

&amp;lt;match hoge.log&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例だとタグを値に持つ&amp;rdquo;what_is_tag&amp;rdquo;、aを値に持つ&amp;rdquo;what_is_a&amp;rdquo;、b.cの値に1を足す&amp;rdquo;what_is_c_of_b_add_1&amp;rdquo;が追加され、
bとdが削除される。一旦まっさらにして入れるものだけを指定することもできる。&lt;/p&gt;

&lt;p&gt;auto_typecastをtrueにしないと&amp;rdquo;what_is_c_of_b_add_1&amp;rdquo;の値がstringになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;a&amp;quot;: &amp;quot;hoge&amp;quot;, &amp;quot;b&amp;quot;: {&amp;quot;c&amp;quot;: 1}, &amp;quot;d&amp;quot;: &amp;quot;fuga&amp;quot;}&#39; | /opt/td-agent/embedded/bin/fluent-cat hoge.log
$ tail /var/log/td-agent/td-agent.log
hoge.log: {&amp;quot;a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_tag&amp;quot;:&amp;quot;hoge.log&amp;quot;,&amp;quot;what_is_a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_c_of_b_add_1&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーが起きるとnullになるが、それ以外の処理はされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;a&amp;quot;: &amp;quot;hoge&amp;quot;, &amp;quot;b&amp;quot;: {&amp;quot;c&amp;quot;: &amp;quot;error!&amp;quot;}, &amp;quot;d&amp;quot;: &amp;quot;fuga&amp;quot;}&#39; | /opt/td-agent/embedded/bin/fluent-cat hoge.log
$ tail /var/log/td-agent/td-agent.log
[warn]: failed to expand `record[&amp;quot;b&amp;quot;][&amp;quot;c&amp;quot;] + 1` error_class=TypeError error=&amp;quot;no implicit conversion of Fixnum into String&amp;quot;
...
hoge.log: {&amp;quot;a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_tag&amp;quot;:&amp;quot;hoge.log&amp;quot;,&amp;quot;what_is_a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_c_of_b_add_1&amp;quot;:null}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィルタ適用前と後をそれぞれoutputしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;match hoge.log&amp;gt;
  @type copy

  &amp;lt;store&amp;gt;
    @type stdout
  &amp;lt;/store&amp;gt;
 
  &amp;lt;store&amp;gt;
    @type relabel
    @label @fuga
  &amp;lt;/store&amp;gt;
&amp;lt;/match&amp;gt;

&amp;lt;label @fuga&amp;gt;
  &amp;lt;filter hoge.log&amp;gt;
    @type record_transformer
    enable_ruby
    auto_typecast true
    remove_keys b,d
  
    &amp;lt;record&amp;gt;
      what_is_tag ${tag}
      what_is_a ${record[&amp;quot;a&amp;quot;]}
      what_is_c_of_b_add_1 ${record[&amp;quot;b&amp;quot;][&amp;quot;c&amp;quot;] + 1}
    &amp;lt;/record&amp;gt;
  &amp;lt;/filter&amp;gt;

  &amp;lt;match hoge.log&amp;gt;
    @type stdout
  &amp;lt;/match&amp;gt;
&amp;lt;/label&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hoge.log: {&amp;quot;a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;b&amp;quot;:{&amp;quot;c&amp;quot;:1},&amp;quot;d&amp;quot;:&amp;quot;fuga&amp;quot;}
hoge.log: {&amp;quot;a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_tag&amp;quot;:&amp;quot;hoge.log&amp;quot;,&amp;quot;what_is_a&amp;quot;:&amp;quot;hoge&amp;quot;,&amp;quot;what_is_c_of_b_add_1&amp;quot;:2}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdでElasticsearchに送る</title>
          <link>http://sambaiz.net/article/54/</link>
          <pubDate>Wed, 01 Feb 2017 21:51:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/54/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/uken/fluent-plugin-elasticsearch&#34;&gt;uken/fluent-plugin-elasticsearch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;必要なものをいれていく。Amazon LinuxのAMIから。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Failed to build gem native extension.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ yum install -y ruby-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;serverengine requires Ruby version &amp;gt;= 2.1.0.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rbenv/rbenv&#34;&gt;rbenv&lt;/a&gt;でバージョンを上げる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/rbenv/rbenv.git ~/.rbenv
$ cd ~/.rbenv &amp;amp;&amp;amp; src/configure &amp;amp;&amp;amp; make -C src
$ echo &#39;export PATH=&amp;quot;$HOME/.rbenv/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile
$ ~/.rbenv/bin/rbenv init
$ echo &#39;eval &amp;quot;$(rbenv init -)&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile
$ source ~/.bash_profile
$ git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ rbenv -v
rbenv 1.1.0-2-g4f8925a
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ruby install aborted due to missing extensions&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ yum install -y openssl-devel readline-devel zlib-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ rbenv install -l
1.8.5-p113
1.8.5-p114
1.8.5-p115
...

$ rbenv install 2.4.0
$ rbenv global 2.4.0
$ ruby -v
ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-linux]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ td-agent-gem install fluent-plugin-elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;td-agent.confはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;match hoge.log&amp;gt;
  @type elasticsearch
  host *****
  port 9200
  index_name test_index
  type_name test_type
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&#39; | /opt/td-agent/embedded/bin/fluent-cat hoge.log
$ curl *****:9200/test_index/test_type/_search?pretty
{
  &amp;quot;took&amp;quot; : 2,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;max_score&amp;quot; : 1.0,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;AVn5puy79PEDL_x5e_u3&amp;quot;,
        &amp;quot;_score&amp;quot; : 1.0,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;a&amp;quot; : &amp;quot;b&amp;quot;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logstash formatでも入れてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;match hoge.log&amp;gt;
  @type elasticsearch
  host *****
  port 9200
  logstash_format true
  logstash_prefix aaaa
  type_name test_type
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;}&#39; | /opt/td-agent/embedded/bin/fluent-cat hoge.log
$ curl *****:9200/aaaa-2017.02.02/_search?pretty
{
  &amp;quot;took&amp;quot; : 1,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;max_score&amp;quot; : 1.0,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;aaaa-2017.02.02&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;AVn_FyQP7q9Gyu5HC4Mq&amp;quot;,
        &amp;quot;_score&amp;quot; : 1.0,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;a&amp;quot; : &amp;quot;b&amp;quot;,
          &amp;quot;@timestamp&amp;quot; : &amp;quot;2017-02-02T22:49:33+09:00&amp;quot;
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;forwardと同じく
&lt;a href=&#34;http://docs.fluentd.org/v0.12/articles/buffer-plugin-overview&#34;&gt;Buffered Output plugin&lt;/a&gt;を
&lt;a href=&#34;https://github.com/uken/fluent-plugin-elasticsearch#buffered-output-options&#34;&gt;継承しているので&lt;/a&gt;
buffer_typeのデフォルトはmemory。必要ならfileにする。いずれにせよスパイクなどでbuffer_queue_limitを超えないように余裕をもっておく。
また、buffer_chunk_limitがElasticsearchのhttp.max_content_length(デフォルト100mb)を超えないようにする。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのnet/http.Client.Doの内部実装をたどったメモ</title>
          <link>http://sambaiz.net/article/53/</link>
          <pubDate>Mon, 30 Jan 2017 20:55:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/53/</guid>
          <description>

&lt;pre&gt;&lt;code&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;net/http&amp;quot;
        &amp;quot;io/ioutil&amp;quot;
)

var client = http.Client{}

func main() {

        req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://example.com&amp;quot;, nil)
        if err != nil{
                panic(err)
        }

        resp, err := client.Do(req)
        if err != nil{
                panic(err)
        }
        defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil{
                panic(err)
        }

        fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;

&lt;p&gt;TransportがTCPコネクションをキャッシュするのでClientは使い回すべき。複数のgoroutineでコンカレントに使っても大丈夫。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L36&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L36&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Client struct {

        // nilならDefaultTransportが使われる        
    	Transport RoundTripper

        // nilなら10回で止まる
        CheckRedirect func(req *Request, via []*Request) error

        // nilならcookieは無視される
        Jar CookieJar

        Timeout time.Duration
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MaxIdleConnsとは別に、ホストごとの制限がある。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/61/&#34;&gt;Goのnet/httpとKeep-Alive - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L39&#34;&gt;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L39&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DefaultTransport RoundTripper = &amp;amp;Transport{
	Proxy: ProxyFromEnvironment,
	DialContext: (&amp;amp;net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
		DualStack: true,
	}).DialContext,
	MaxIdleConns:          100,
	IdleConnTimeout:       90 * time.Second,
	TLSHandshakeTimeout:   10 * time.Second,
	ExpectContinueTimeout: 1 * time.Second,
}

const DefaultMaxIdleConnsPerHost = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;request&#34;&gt;Request&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/request.go#L690&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/request.go#L690&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewRequest(method, urlStr string, body io.Reader) (*Request, error) {
    ...
    
    u, err := url.Parse(urlStr)
    
    ...
    
    rc, ok := body.(io.ReadCloser)
    req := &amp;amp;Request{
            Method:     method,
            URL:        u,
            Proto:      &amp;quot;HTTP/1.1&amp;quot;,
            ProtoMajor: 1,
            ProtoMinor: 1,
            Header:     make(Header),
            Body:       rc,
            Host:       u.Host,
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;do&#34;&gt;Do&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L181&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L181&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Requestを渡してResponseを受け取る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) Do(req *Request) (*Response, error) {
    method := valueOrDefault(req.Method, &amp;quot;GET&amp;quot;)
    if method == &amp;quot;GET&amp;quot; || method == &amp;quot;HEAD&amp;quot; {
        return c.doFollowingRedirects(req, shouldRedirectGet)
    }
    if method == &amp;quot;POST&amp;quot; || method == &amp;quot;PUT&amp;quot; {
        return c.doFollowingRedirects(req, shouldRedirectPost)
    }
    return c.send(req, c.deadline())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dofollowingredirects&#34;&gt;doFollowingRedirects&lt;/h3&gt;

&lt;p&gt;リクエストを送り、リダイレクトする場合はして、そうでない場合はレスポンスを返す。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L440&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L440&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) doFollowingRedirects(req *Request, shouldRedirect func(int) bool) (*Response, error) {
    ...

    for{

        ...
        
        if resp, err = c.send(req, deadline); err != nil {
            if !deadline.IsZero() &amp;amp;&amp;amp; !time.Now().Before(deadline) {
                err = &amp;amp;httpError{
                    err:     err.Error() + &amp;quot; (Client.Timeout exceeded while awaiting headers)&amp;quot;,
                    timeout: true,
                }
            }
            return nil, uerr(err)
        }

        if !shouldRedirect(resp.StatusCode) {
            return resp, nil
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;send&#34;&gt;send&lt;/h3&gt;

&lt;p&gt;ClientのTransportのRoundTripを呼ぶ。ここからはTransport(RoundTripper)の仕事。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L140&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L140&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Client) send(req *Request, deadline time.Time) (*Response, error) {
    
    ...
    
    resp, err := send(req, c.transport(), deadline)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L208&#34;&gt;https://github.com/golang/go/blob/964639cc338db650ccadeafb7424bc8ebb2c0f6c/src/net/http/client.go#L208&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func send(ireq *Request, rt RoundTripper, deadline time.Time) (*Response, error) {
   
    ...
    
    resp, err := rt.RoundTrip(req)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;roundtrip&#34;&gt;RoundTrip&lt;/h3&gt;

&lt;p&gt;チャネルを通して接続先とやりとりする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L319&#34;&gt;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L319&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (t *Transport) RoundTrip(req *Request) (*Response, error) {
    
    ...
    
    treq := &amp;amp;transportRequest{Request: req, trace: trace}
    
    ...
	
    cm, err := t.connectMethodForRequest(treq)
    pconn, err := t.getConn(treq, cm)
   
    ...
    
    resp, err = pconn.roundTrip(treq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;writeとreadを同時に行っているのはサーバーがbodyのすべてを読む前にレスポンスを返すときのため。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L1823&#34;&gt;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L1823&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
    
    ...
    
    pc.writech &amp;lt;- writeRequest{req, writeErrCh, continueCh} // pc.writeLoopで読まれる

    resc := make(chan responseAndError)
	pc.reqch &amp;lt;- requestAndChan{ // pc.readLoopで読まれる
		req:        req.Request,
		ch:         resc,
		addedGzip:  requestedGzip,
		continueCh: continueCh,
		callerGone: gone,
	}
    var re responseAndError
    
    ...
    
    case re = &amp;lt;-resc: // pc.readLoopで書き込まれる
		re.err = pc.mapRoundTripErrorFromReadLoop(req.Request, startBytesWritten, re.err)
		break WaitResponse
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pconn-getconn-dialconn&#34;&gt;pconn.getConn/dialConn&lt;/h3&gt;

&lt;p&gt;接続し、チャネルを読むループ(readLoop, writeLoop)を回す。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L865&#34;&gt;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L865&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) {
    ...
    type dialRes struct {
		pc  *persistConn
		err error
	}
    dialc := make(chan dialRes)
    
    ...
    
    go func() {
		pc, err := t.dialConn(ctx, cm)
		dialc &amp;lt;- dialRes{pc, err}
	}()
    
    ...
    
    select {
	case v := &amp;lt;-dialc:
        if v.pc != nil {
            
            ...
			
            return v.pc, nil
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L967&#34;&gt;https://github.com/golang/go/blob/d986daec1375527ef78cd59d81d42be7406a9803/src/net/http/transport.go#L967&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error) {
    pconn := &amp;amp;persistConn{
		t:             t,
		cacheKey:      cm.key(),
		reqch:         make(chan requestAndChan, 1), // roundTripで書かれて、readLoopで読まれる
		writech:       make(chan writeRequest, 1), // roundTripで書かれて、writeLoopで読まれる
		closech:       make(chan struct{}),
		writeErrCh:    make(chan error, 1),
		writeLoopDone: make(chan struct{}),
	}

    ...
    
    conn, err := t.dial(ctx, &amp;quot;tcp&amp;quot;, cm.addr())
	pconn.conn = conn
    
    ...
    
    go pconn.readLoop()
	go pconn.writeLoop()
	return pconn, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ライセンス&#34;&gt;ライセンス&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Copyright (c) 2009 The Go Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&amp;quot;AS IS&amp;quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ElasticsearchをDockerで動かしてGrafanaで可視化する</title>
          <link>http://sambaiz.net/article/52/</link>
          <pubDate>Sun, 29 Jan 2017 17:08:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/52/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html&#34;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;vm.max_map_count
(&lt;a href=&#34;http://www.atmarkit.co.jp/flinux/special/proctune/proctune02b.html&#34;&gt;バーチャルメモリにマッピングできる最大ページ数&lt;/a&gt;)
を262144以上にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sysctl vm.max_map_count
$ grep vm.max_map_count /etc/sysctl.conf
vm.max_map_count=262144
# sysctl -w vm.max_map_count=262144
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;30日トライアル後、有償ライセンスが必要になるxpackのsecurity(旧sheild)がデフォルトで有効になっているのでfalseにしている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-cap-add=IPC_LOCK&lt;/code&gt;でLock memory(スワップアウトしないようにする)を
&lt;a href=&#34;https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities&#34;&gt;許可&lt;/a&gt;する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/heap-size.html&#34;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/5.2/heap-size.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ES_HEAP_SIZEでヒープ領域を設定する。デフォルトでは2GB。多いほどキャッシュに使用できる。
ただし、物理RAMの50%以下で、&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html#compressed_oops&#34;&gt;32GB近辺の境界を超えないようにする&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir -p ~/do/elasticsearch/data
$ docker run -itd -v elasticsearch:/usr/share/elasticsearch/data \
--name elasticsearch \
-p 9200:9200 \
-e xpack.security.enabled=false \
-e bootstrap.memory_lock=true -e cluster.name=hogehoge-cluster -e ES_JAVA_OPTS=&amp;quot;-Xms28g -Xmx28g&amp;quot; \
--cap-add=IPC_LOCK --ulimit memlock=-1:-1 --ulimit nofile=65536:65536 \
--restart=always \
docker.elastic.co/elasticsearch/elasticsearch:5.1.2

$ docker volume ls
local               elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;問題なく起動しているか確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:9200 | jq
{
  &amp;quot;name&amp;quot;: &amp;quot;eqIkJ48&amp;quot;,
  &amp;quot;cluster_name&amp;quot;: &amp;quot;docker-cluster&amp;quot;,
  &amp;quot;cluster_uuid&amp;quot;: &amp;quot;Lsu_C7wORS6G-0m9PJ9sFQ&amp;quot;,
  &amp;quot;version&amp;quot;: {
    &amp;quot;number&amp;quot;: &amp;quot;5.1.2&amp;quot;,
    &amp;quot;build_hash&amp;quot;: &amp;quot;c8c4c16&amp;quot;,
    &amp;quot;build_date&amp;quot;: &amp;quot;2017-01-11T20:18:39.146Z&amp;quot;,
    &amp;quot;build_snapshot&amp;quot;: false,
    &amp;quot;lucene_version&amp;quot;: &amp;quot;6.3.0&amp;quot;
  },
  &amp;quot;tagline&amp;quot;: &amp;quot;You Know, for Search&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-mapping.html&#34;&gt;dynamic mapping&lt;/a&gt;
を無効にする場合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT &#39;localhost:9200/_template/template_all?pretty&#39; -d&#39;
{
  &amp;quot;template&amp;quot;: &amp;quot;*&amp;quot;,
  &amp;quot;order&amp;quot;:0,
  &amp;quot;settings&amp;quot;: {
    &amp;quot;index.mapper.dynamic&amp;quot;: false 
  }
}
&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kuromojiを入れる場合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker exec -it ***** bin/elasticsearch-plugin install analysis-kuromoji
$ docker restart  *****
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grafanaで可視化する&#34;&gt;Grafanaで可視化する&lt;/h2&gt;

&lt;p&gt;前は&lt;a href=&#34;http://sambaiz.net/article/19/&#34;&gt;InfluxDBとつなげた&lt;/a&gt;が、Elasticsearchにも対応している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir -p /var/lib/grafana/plugins
$ docker run -itd --restart=always -p 3000:3000 -v grafana:/var/lib/grafana grafana/grafana
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.grafana.org/datasources/elasticsearch/&#34;&gt;http://docs.grafana.org/datasources/elasticsearch/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;admin/adminでログインして、data sourceを追加する。AccessはProxyにする。&lt;/p&gt;

&lt;p&gt;適当にデータを入れて表示してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -XPUT &#39;localhost:9200/test_index?pretty&#39; -H &#39;Content-Type: application/json&#39; -d&#39;
{
  &amp;quot;mappings&amp;quot;: {
    &amp;quot;test_type&amp;quot;: { 
      &amp;quot;_all&amp;quot;:       { &amp;quot;enabled&amp;quot;: false  }, 
      &amp;quot;properties&amp;quot;: { 
        &amp;quot;name&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot; },
        &amp;quot;age&amp;quot;:    { &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;  },
        &amp;quot;timestamp&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;date&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;epoch_millis&amp;quot; }
      }
    }
  }
}
&#39;

$ curl &#39;localhost:9200/_cat/indices?format=json&amp;amp;pretty&#39;
[
  {
    &amp;quot;health&amp;quot; : &amp;quot;yellow&amp;quot;,
    &amp;quot;status&amp;quot; : &amp;quot;open&amp;quot;,
    &amp;quot;index&amp;quot; : &amp;quot;test_index&amp;quot;,
    &amp;quot;uuid&amp;quot; : &amp;quot;kVbt2V-rS2m6vhplIkMKNg&amp;quot;,
    &amp;quot;pri&amp;quot; : &amp;quot;5&amp;quot;,
    &amp;quot;rep&amp;quot; : &amp;quot;1&amp;quot;,
    &amp;quot;docs.count&amp;quot; : &amp;quot;0&amp;quot;,
    &amp;quot;docs.deleted&amp;quot; : &amp;quot;0&amp;quot;,
    &amp;quot;store.size&amp;quot; : &amp;quot;260b&amp;quot;,
    &amp;quot;pri.store.size&amp;quot; : &amp;quot;260b&amp;quot;
  },
  ...
]

$ curl -XPOST &#39;localhost:9200/test_index/test_type?pretty&#39; -H &#39;Content-Type: application/json&#39; -d&#39;
{
    &amp;quot;name&amp;quot;: &amp;quot;hoge fuga&amp;quot;,
    &amp;quot;age&amp;quot;: 24,
    &amp;quot;timestamp&amp;quot;: 1485676393044
}
&#39;

$ curl &#39;localhost:9200/test_index/test_type/_search?pretty&#39;
{
  &amp;quot;took&amp;quot; : 2,
  &amp;quot;timed_out&amp;quot; : false,
  &amp;quot;_shards&amp;quot; : {
    &amp;quot;total&amp;quot; : 5,
    &amp;quot;successful&amp;quot; : 5,
    &amp;quot;failed&amp;quot; : 0
  },
  &amp;quot;hits&amp;quot; : {
    &amp;quot;total&amp;quot; : 1,
    &amp;quot;max_score&amp;quot; : 1.0,
    &amp;quot;hits&amp;quot; : [
      {
        &amp;quot;_index&amp;quot; : &amp;quot;test_index&amp;quot;,
        &amp;quot;_type&amp;quot; : &amp;quot;test_type&amp;quot;,
        &amp;quot;_id&amp;quot; : &amp;quot;AVnpOGrseo3fDHi0SK-P&amp;quot;,
        &amp;quot;_score&amp;quot; : 1.0,
        &amp;quot;_source&amp;quot; : {
          &amp;quot;name&amp;quot; : &amp;quot;hoge fuga&amp;quot;,
          &amp;quot;age&amp;quot; : 24,
          &amp;quot;timestamp&amp;quot; : 1485676393044
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/52.png&#34; alt=&#34;表示してみた&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>fluentdのforward</title>
          <link>http://sambaiz.net/article/51/</link>
          <pubDate>Wed, 25 Jan 2017 22:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/51/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/articles/high-availability#network-topology&#34;&gt;td-agent間でログをやりとりするとき&lt;/a&gt;
に使われるforwardについて。内部では&lt;a href=&#34;http://docs.fluentd.org/articles/in_forward#protocol&#34;&gt;MessagePackを使っている&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;forward-input&#34;&gt;forward input&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/articles/in_forward&#34;&gt;http://docs.fluentd.org/articles/in_forward&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;受け取る側。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;match **&amp;gt;
  @type stdout
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/init.d/td-agent restart&lt;/code&gt;してfluent-catで送ってみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;{&amp;quot;hoge&amp;quot;: &amp;quot;fuga&amp;quot;}&#39; | /opt/td-agent/embedded/bin/fluent-cat -h xx.xx.xx.xx test.tag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/log/td-agent/td-agent.log&lt;/code&gt;に出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test.tag: {&amp;quot;hoge&amp;quot;:&amp;quot;fuga&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;forward-output&#34;&gt;forward output&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/articles/out_forward&#34;&gt;http://docs.fluentd.org/articles/out_forward&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/articles/buffer-plugin-overview&#34;&gt;http://docs.fluentd.org/articles/buffer-plugin-overview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;送る側。&lt;/p&gt;

&lt;p&gt;ポートはデフォルトで24224で、イベントの送信にTCPを、heartbeatにUDP(heartbeat_typeで変えられる)を使う。&lt;/p&gt;

&lt;p&gt;flush_intervalははデフォルトで&lt;a href=&#34;http://docs.fluentd.org/articles/out_forward#flushinterval&#34;&gt;60秒&lt;/a&gt;。
確認のときは短くしておくと分かりやすい。
buffer_queueの一番上のチャンクがこの時間経過するか、サイズがbuffer_chunk_limitを超えると、一番下のチャンクが書き込まれ、新しいチャンクがpushされる。
chunkの数がbuffer_queue_limitに到達してしまうと新しいイベントは破棄されてしまうので
リソースを圧迫(buffer_chunk_limit * buffer_queue_limit)しない程度に十分大きな数にしておき、
スパイクや障害時に備えておく。
buffer_typeはデフォルトがmemory。fileだと&lt;a href=&#34;http://docs.fluentd.org/articles/out_forward#flushatshutdown&#34;&gt;flush_at_shutdownのデフォルトがfalse&lt;/a&gt;なので注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;match **&amp;gt;
  @type forward

  flush_interval 1s

  buffer_type file
  buffer_path /var/log/td-agent/forward-buf
  flush_at_shutdown true
  buffer_chunk_limit 256m

  &amp;lt;server&amp;gt;
    name log_server
    host xx.xx.xx.xx
    port 24224
  &amp;lt;/server&amp;gt;
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;冗長化&#34;&gt;冗長化&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.fluentd.org/articles/out_forward#ltservergt-at-least-one-is-required&#34;&gt;server&lt;/a&gt;は複数書くことができ、
それぞれにweight(デフォルトは60)を設定したり、
&lt;a href=&#34;http://docs.fluentd.org/articles/out_forward#standby&#34;&gt;standby&lt;/a&gt;を付けることでActive-Standbyの構成にすることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  @type forward
  port 24224
  bind 0.0.0.0
&amp;lt;/source&amp;gt;

&amp;lt;match **&amp;gt;
  @type forward

  ...

  &amp;lt;server&amp;gt;
    name log_server
    host xx.xx.xx.xx
    port 24224
    weight 60
  &amp;lt;/server&amp;gt;

  &amp;lt;server&amp;gt;
    name log_server2
    host yy.yy.yy.yy
    port 24224
    weight 60
  &amp;lt;/server&amp;gt;
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;片方のサーバーをtd-agentをstopしてstartしてみるとこんなログが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;detached forwarding server &#39;log_server2&#39; host=&amp;quot;yy.yy.yy.yy&amp;quot; port=24224 phi=16.06814271743242 phi_threshold=16
recovered forwarding server &#39;log_server2&#39; host=&amp;quot;yy.yy.yy.yy&amp;quot; port=24224
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにtd-agentはrootで動かしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/sysconfig/td-agent 
TD_AGENT_USER=root
TD_AGENT_GROUP=root
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのinterface/structの埋め込み</title>
          <link>http://sambaiz.net/article/50/</link>
          <pubDate>Wed, 18 Jan 2017 01:39:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/50/</guid>
          <description>

&lt;p&gt;Goには継承が存在しない。その代わりstructを埋め込み、委譲することができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html#embedding&#34;&gt;https://golang.org/doc/effective_go.html#embedding&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;挙動&#34;&gt;挙動&lt;/h2&gt;

&lt;h3 id=&#34;interfaceにinterfaceを埋め込む&#34;&gt;interfaceにinterfaceを埋め込む&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type I interface {
	Hoge()
}

type J interface {
	Fuga()
}

type K interface {
	I
	J
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インタフェースKはIとJを合わせたものになる。IとJに重複する関数がある場合はエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type L struct {
}

func (l L) Hoge() {
	fmt.Println(&amp;quot;hoge&amp;quot;)
}
func (l L) Fuga() {
	fmt.Println(&amp;quot;fuga&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var k K
k = L{}
k.Hoge()
k.Fuga()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;structにinterfaceを埋め込む&#34;&gt;structにinterfaceを埋め込む&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type K interface {
	Hoge()
	Fuga()
}

type M struct {
	K
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;埋め込むと&lt;code&gt;m.Hoge()&lt;/code&gt;のように透過的にKを扱うことができるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m := M{L{}}
m.Hoge()
// m.K.Hoge() これでも呼べる
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;埋め込まないとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type M struct {
	k K
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;m := M{L{}}
m.k.Hoge()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;structにstructを埋め込む&#34;&gt;structにstructを埋め込む&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type A struct {
	name string
}

type B struct {
	A
}

func (a A) hoge() {
	fmt.Println(&amp;quot;hoge&amp;quot;, a.name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上と同様、&lt;code&gt;b.name&lt;/code&gt;や、&lt;code&gt;b.hoge()&lt;/code&gt;のように扱える。
Aの関数も呼べて一見継承しているように見えるが、実際はAへの委譲となる。なのでhogeのレシーバーはA。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b := B{}
b.name = &amp;quot;a&amp;quot;
// b = B{A{name: &amp;quot;a&amp;quot;}} 
b.hoge()
// b.A.hoge()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、Bにもhogeを実装すると、&lt;code&gt;b.hoge()&lt;/code&gt;でこちらが呼ばれることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b B) hoge() {
	fmt.Println(&amp;quot;fuga&amp;quot;, b.name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;b := B{}
b.name = &amp;quot;piyo&amp;quot;
b.hoge() // =&amp;gt; fuga piyo
b.A.hoge() // =&amp;gt; hoge piyo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;継承との違い&#34;&gt;継承との違い&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type A struct {
	name string
}

type B struct {
	A
}

func (a A) hoge() {
	fmt.Println(&amp;quot;hoge&amp;quot;, a.name)
}

func (a A) fuga() {
	a.hoge()
}

// override?
func (b B) hoge() {
	fmt.Println(&amp;quot;fuga&amp;quot;, b.name)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もし、BがAを継承しているとするとb.fuga()内でhoge()を呼ぶと、オーバーライドした、Bをレシーバーとするhoge()が呼ばれ、&amp;rdquo;fuga&amp;rdquo;が出力されるはずだ。
しかし、fuga()のレシーバーはAなので、呼ばれるのはAをレシーバーとする方のhoge()となり、&amp;rdquo;hoge&amp;rdquo;が出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b := B{}
b.name = &amp;quot;piyo&amp;quot;
b.fuga() // =&amp;gt; hoge piyo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、type Aの変数にBを代入することもできない。&lt;/p&gt;

&lt;h2 id=&#34;用途を探る&#34;&gt;用途を探る&lt;/h2&gt;

&lt;h3 id=&#34;interfaceのデフォルト実装&#34;&gt;interfaceのデフォルト実装&lt;/h3&gt;

&lt;p&gt;interfaceのデフォルトの実装を用意したstructを埋めることで、各structでは差分だけを実装すればいいようにできる。
ただデフォルト実装が他のデフォルト実装の関数を呼んでいる場合、呼び先の関数だけ実装しても元々の関数の動作は変わらないので注意。
レシーバーを意識する必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Student interface {
	Plus(x int, y int) int
	Minus(x int, y int) int
}

type defaultStudent struct{}

func (defaultStudent) Plus(x int, y int) int {
	return x + y
}

func (defaultStudent) Minus(x int, y int) int {
	return x - y
}

type BadStudent struct {
	defaultStudent
}

func (BadStudent) Minus(x int, y int) int {
	return 0
}

type GeniusStudent struct {
	defaultStudent
}

func (GeniusStudent) Plus(x int, y int) int {
	if ans, err := strconv.Atoi(fmt.Sprintf(&amp;quot;%d%d&amp;quot;, x, y)); err != nil {
		fmt.Errorf(&amp;quot;genius student fails to %d + %d&amp;quot;, x, y)
		return 0
	} else {
		return ans
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;publicな機能の追加&#34;&gt;Publicな機能の追加&lt;/h3&gt;

&lt;p&gt;Publicな関数を提供するstructを埋め込み、それを直接外からも呼べるようにする。&lt;/p&gt;

&lt;p&gt;試しに、&lt;code&gt;sync.RWMutex()&lt;/code&gt;を埋め込んでみた。これはゼロ値でロックしていない状態なので初期化する必要はない。
一見良さそうに見えるが、この例だとLockとUnlockは内側でのみ呼ぶことを想定していて、外からうっかり呼んでしまうとおかしなことになってしまうだめな例。まあでもこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Twin struct {
	num     int
	sameNum int
	sync.RWMutex
}

func (l *Twin) Set(n int) {
	l.Lock()
	l.num = n
	l.sameNum = n
	l.Unlock()
}

func (l *Twin) Check() (ok bool) {
	l.RLock()
	ok = l.num == l.sameNum
	l.RUnlock()
	return
}

func main() {

	twin := new(Twin)

	for i := 0; i &amp;lt; 1000; i++ {
		go twin.Set(i)
		if !twin.Check() {
			panic(&amp;quot;broken&amp;quot;)
		}
	}

	fmt.Println(&amp;quot;success&amp;quot;)

	twin.Unlock() // panic!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;privateな共通処理をまとめる&#34;&gt;Privateな共通処理をまとめる&lt;/h3&gt;

&lt;p&gt;privateな共通処理を埋め込むことでDRYに書けるように試みる。&lt;/p&gt;

&lt;p&gt;まず、状態を持たないような処理の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (defaultStudent) hoge() bool {
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはパッケージが適切に切られていれば&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func hoge() bool {
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と変わらず、埋め込む必要はないと思う。埋め込むとレシーバーから補完が効いて探しやすいかもしれないけれど。&lt;/p&gt;

&lt;p&gt;一方、状態を持つような処理の場合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (n defaultStudent) counter() int {
    n.counter += 1
    return n.counter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは埋め込むか、明示的にフィールドを持つかのどちらかになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type BadStudent struct {
	defaultStudent
}

or 

type BadStudent struct {
	d defaultStudent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の場合、defaultStudentにPublicなデフォルト実装があってそれを使うので埋め込んだ方が自然なような気もするけど、
そうでなければ埋め込まない方が移譲していることが分かりやすいと思う。せいぜい数文字増えるだけだし。&lt;/p&gt;

&lt;p&gt;埋め込みは便利だけど、継承ではないことを理解して使おう。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/sonatard/items/2b4b70694fd680f6297c&#34;&gt;オブジェクト指向言語としてGolangをやろうとするとハマる点を整理してみる - Qiita&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goのpanicとrecover</title>
          <link>http://sambaiz.net/article/49/</link>
          <pubDate>Tue, 17 Jan 2017 23:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/49/</guid>
          <description>

&lt;h2 id=&#34;panic&#34;&gt;panic&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/builtin/#panic&#34;&gt;https://golang.org/pkg/builtin/#panic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;panicは現在のgoroutineの通常の実行を停止する組み込み関数。
&lt;a href=&#34;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/runtime/panic.go#L26&#34;&gt;index out of range&lt;/a&gt;や
&lt;a href=&#34;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/runtime/panic.go#L61&#34;&gt;invalid memory address or nil pointer dereference&lt;/a&gt;
のときなどでも呼ばれる。&lt;/p&gt;

&lt;p&gt;deferを実行して呼び出し元に戻り、panicの実行-&amp;gt;deferの実行-&amp;gt;呼び出し元に戻る、を繰り返して
最後まで戻ったらプログラムを終了し、panicに渡した引数と共にエラーをレポートする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	a()
}

func a() {
	defer fmt.Println(&amp;quot;a&amp;quot;)
	b()
	fmt.Println(&amp;quot;a2&amp;quot;)
}

func b() {
	defer fmt.Println(&amp;quot;b1&amp;quot;)
	panic(&amp;quot;b2&amp;quot;)
	defer fmt.Println(&amp;quot;b3&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;b1
a
panic: b2

goroutine 1 [running]:
panic(0x89840, 0xc42000a2c0)
	/*****/libexec/src/runtime/panic.go:500 +0x1a1
main.b()
	/*****/main.go:19 +0x107
main.a()
	/*****/main.go:13 +0xce
main.main()
	/*****/main.go:8 +0x14
exit status 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;recover&#34;&gt;recover&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/builtin/#recover&#34;&gt;https://golang.org/pkg/builtin/#recover&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;deferで呼ぶことによってpanicを停止させることができる組み込み関数。
panicの引数に渡した値を取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	fmt.Println(a())
	fmt.Println(&amp;quot;main&amp;quot;)
}

func a() (ret string) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(&amp;quot;recover -&amp;gt;&amp;quot;, err)
			ret = &amp;quot;panicked&amp;quot;
		}
	}()
	b()
	fmt.Println(&amp;quot;a2&amp;quot;)
	return &amp;quot;ok&amp;quot;
}

func b() {
	defer fmt.Println(&amp;quot;b1&amp;quot;)
	panic(&amp;quot;b2&amp;quot;)
	defer fmt.Println(&amp;quot;b3&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;b1
recover -&amp;gt; b2
panicked
main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常はpanicもrecoverもあまり使わず、errorを返すことでハンドリングする。&lt;/p&gt;

&lt;p&gt;ではどんな時に使われるかというと、例えばWebフレームワーク&lt;a href=&#34;https://github.com/labstack/echo&#34;&gt;echo&lt;/a&gt;のRecover middlewareは
panicをrecoverしてinternal server errorとしてレスポンスを返すようにしている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/labstack/echo/blob/a96c564fc34b3fcbc5a1a67eeb9402243cdac6b2/middleware/recover.go#L66&#34;&gt;https://github.com/labstack/echo/blob/a96c564fc34b3fcbc5a1a67eeb9402243cdac6b2/middleware/recover.go#L66&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/labstack/echo/blob/54fb1015c1a51aed1c8e5ef6bf9e643b1a079acb/context.go#L525&#34;&gt;https://github.com/labstack/echo/blob/54fb1015c1a51aed1c8e5ef6bf9e643b1a079acb/context.go#L525&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/labstack/echo/blob/b2c623b07dd1362011f2677147ffbbe48ea3b178/echo.go#L284&#34;&gt;https://github.com/labstack/echo/blob/b2c623b07dd1362011f2677147ffbbe48ea3b178/echo.go#L284&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
        // Echo instance
        e := echo.New()

        // Middleware
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())

        // Route =&amp;gt; handler
        e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error {
                panic(&amp;quot;fail&amp;quot;)
                return c.String(http.StatusOK, &amp;quot;Hello, World!\n&amp;quot;)
        })

        // Start server
        e.Logger.Fatal(e.Start(&amp;quot;:1323&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;message&amp;quot;:&amp;quot;Internal Server Error&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ではRecover middlewareを使わなかったらアプリケーションが終了するかというと、
net/httpのserveでもrecoverしてるのでここでひっかかる(レスポンスは返らない)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/net/http/server.go#L2625&#34;&gt;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/net/http/server.go#L2625&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/net/http/server.go#L1718&#34;&gt;https://github.com/golang/go/blob/b2a3b54b9520ce869d79ac8bce836a540ba45d09/src/net/http/server.go#L1718&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo: http: panic serving [::1]:53992: AA
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.golang.org/defer-panic-and-recover&#34;&gt;Defer, Panic, and Recover - The Go Blog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>OAuth2.0のメモ</title>
          <link>http://sambaiz.net/article/48/</link>
          <pubDate>Sun, 08 Jan 2017 02:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/48/</guid>
          <description>

&lt;h2 id=&#34;認可-authorization-と認証-authentication&#34;&gt;認可(Authorization)と認証(Authentication)&lt;/h2&gt;

&lt;p&gt;それぞれAuthZ、AuthNとも書かれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;認可: リソースへのアクセスを許可する&lt;/li&gt;
&lt;li&gt;認証: ユーザーが何者かを検証する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;oauth2-0&#34;&gt;OAuth2.0&lt;/h2&gt;

&lt;p&gt;認可のプロトコル。
それによってアクセスできるようになったリソースの情報をもとに他のサービスが認証を行ったりしている。&lt;/p&gt;

&lt;h3 id=&#34;authorization-code-flow&#34;&gt;Authorization Code Flow&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/48_authcode.png&#34; alt=&#34;シーケンス図&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OAuthクライアントがアプリケーションサーバーのときのフロー。&lt;/p&gt;

&lt;p&gt;まずユーザーがOAuth認可ページで認可する。
このリクエストには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;client_id&lt;/li&gt;
&lt;li&gt;redirect_uri&lt;/li&gt;
&lt;li&gt;scope: アクセスできるリソースの種類&lt;/li&gt;
&lt;li&gt;response_type=code: 認可コードが返される&lt;/li&gt;
&lt;li&gt;state: CSRFを防ぐためのランダムで一意な文字列。アプリケーションサーバーが保持して、前後で一致するかチェックする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が含まれる。&lt;/p&gt;

&lt;p&gt;認可されると認可コードとstateを付けてredirect_uriにリダイレクトするので、
アプリケーションサーバーは認可コードをアクセストークンに交換する。
この際、client_idとclient_secretも送って認証する。&lt;/p&gt;

&lt;p&gt;オプションでリフレッシュトークンを含み、これを使うと期限が切れたとき新しいアクセストークンを取得できる。&lt;/p&gt;

&lt;p&gt;アクセストークンは通常Bearer Token(Authorization: Bearer ***)としてリクエストに含まれる。&lt;/p&gt;

&lt;h3 id=&#34;implicit-flow&#34;&gt;Implicit Flow&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/48_implicit.png&#34; alt=&#34;シーケンス図&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OAuthクライアントがブラウザのときのフロー。
つまりclient_secretの機密性を保てないパターン。&lt;/p&gt;

&lt;p&gt;認可コードは不要なので&lt;code&gt;response_type=token&lt;/code&gt;でリクエストし、アクセストークンをブラウザで取得する。
リフレッシュトークンは含まない。
これをそのまま認証に使うと、他のサービスで発行された他人のトークンを使うことでなりすませてしまうので、
そのトークンがどのサービスに対して発行されたかを確認する術が必要。&lt;/p&gt;

&lt;p&gt;redirect_uriは&lt;a href=&#34;https://tools.ietf.org/html/rfc6749#section-3.1.2.2&#34;&gt;事前に登録しておく必要がある。&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873115580/&#34;&gt;O&amp;rsquo;Reilly Japan - OAuth 2.0をはじめよう&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://oauth.jp/blog/2014/05/07/covert-redirect-in-implicit-flow/&#34;&gt;Implicit Flow では Covert Redirect で Token 漏れるね - OAuth.jp&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>go testでベンチマークを取ってpprofで時間がかかっている箇所を調べる</title>
          <link>http://sambaiz.net/article/47/</link>
          <pubDate>Wed, 04 Jan 2017 23:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/47/</guid>
          <description>&lt;p&gt;この関数のベンチマークを取る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package cal

import (
	&amp;quot;math/big&amp;quot;
)

var cache = map[int]*big.Int{}

func resetCache() {
	cache = map[int]*big.Int{}
}

func Fibonacci(n int) *big.Int {

	if c := cache[n]; c != nil {
		return c
	}

	ret := new(big.Int)
	before := big.NewInt(1)
	for i := 1; i &amp;lt; n; i++ {
		tmp := new(big.Int).Add(ret, before)
		before = ret
		ret = tmp
		cache[i] = ret
	}
	cache[n] = ret
	return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数にtesting.Bを取る、Benchmarkから始まる関数を書いて、b.N回ループさせる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package cal

import (
	&amp;quot;math/big&amp;quot;
	&amp;quot;testing&amp;quot;
)

func TestFibonacci(t *testing.T) {
	if f := Fibonacci(10); f.String() != big.NewInt(34).String() {
		t.Errorf(&amp;quot;%d != %d (expected)&amp;quot;, f, big.NewInt(34))
	}
}

func BenchmarkFibonacci(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		b.StopTimer()
		resetCache()
		b.StartTimer()
		Fibonacci(100)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;go test -bench&lt;/code&gt;で実行するとベンチマークが取れる。さらに&lt;code&gt;-benchmem&lt;/code&gt;を付けるとメモリアロケーションの情報も出る。
また、&lt;code&gt;-cpuprofile&lt;/code&gt;でCPUのプロファイルを出力し、pprocに渡すことでどの部分で時間がかかっているかを調べることができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/cmd/go/#hdr-Description_of_testing_flags&#34;&gt;https://golang.org/cmd/go/#hdr-Description_of_testing_flags&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go test -bench Fibonacci -benchmem -o pprof/test.bin  -cpuprofile pprof/cpu.out ./cal
BenchmarkFibonacci-4   	   50000	     32788 ns/op	   13344 B/op	     211 allocs/op
PASS
ok  	github.com/sambaiz/try-pprof/cal	3.406s

$ go tool pprof --text pprof/test.bin pprof/cpu.out
3.80s of 3.83s total (99.22%)
Dropped 17 nodes (cum &amp;lt;= 0.02s)
      flat  flat%   sum%        cum   cum%
     2.31s 60.31% 60.31%      2.31s 60.31%  runtime.mach_semaphore_signal
     0.38s  9.92% 70.23%      0.38s  9.92%  runtime.mach_semaphore_timedwait
     0.32s  8.36% 78.59%      0.32s  8.36%  runtime.mach_semaphore_wait
     0.27s  7.05% 85.64%      0.27s  7.05%  runtime.usleep
     0.14s  3.66% 89.30%      0.14s  3.66%  runtime.deductSweepCredit
     0.09s  2.35% 91.64%      0.28s  7.31%  runtime.mallocgc
     0.04s  1.04% 92.69%      0.14s  3.66%  runtime.mapassign1
     0.04s  1.04% 93.73%      0.05s  1.31%  runtime.updatememstats
     0.03s  0.78% 94.52%      0.13s  3.39%  math/big.nat.add
     0.03s  0.78% 95.30%      0.03s  0.78%  runtime.aeshash64
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;graphvizをインストールすることでsvgのグラフを出すこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install graphviz
$ go tool pprof --svg pprof/test.bin pprof/cpu.out &amp;gt; pprof/test.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/47.png&#34; alt=&#34;svgで出力したもの&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>GoogleのkvsライブラリLevelDBを使う</title>
          <link>http://sambaiz.net/article/45/</link>
          <pubDate>Sat, 24 Dec 2016 21:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/45/</guid>
          <description>

&lt;h2 id=&#34;leveldbとは&#34;&gt;LevelDBとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;https://github.com/google/leveldb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Googleが作った高速なkey-valueストレージライブラリ。&lt;/p&gt;

&lt;p&gt;ChromeのIndexedDBや&lt;a href=&#34;https://prometheus.io/docs/operating/storage/&#34;&gt;prometheus&lt;/a&gt;などで使われている。&lt;/p&gt;

&lt;h3 id=&#34;特徴-https-github-com-google-leveldb-features&#34;&gt;&lt;a href=&#34;https://github.com/google/leveldb#features&#34;&gt;特徴&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keyと任意のバイト配列のValue&lt;/li&gt;
&lt;li&gt;データはKeyでソートされる。ソートのための比較関数はオーバーライドできる。&lt;/li&gt;
&lt;li&gt;基本的な操作はPut, Get, Delete。&lt;/li&gt;
&lt;li&gt;複数の変更を一つのatomicなバッチで行える&lt;/li&gt;
&lt;li&gt;一環したデータのビューを取得するために、一時的なスナップショットを作成できる&lt;/li&gt;
&lt;li&gt;データを前にも後ろにもイテレーションできる&lt;/li&gt;
&lt;li&gt;データは&lt;a href=&#34;http://google.github.io/snappy/&#34;&gt;Snappy compression library&lt;/a&gt;で自動で圧縮される。&lt;/li&gt;
&lt;li&gt;ファイルシステムの操作など外部のアクティビティを仮想的なインタフェースを通して行うので、OSとのやりとりをカスタマイズできる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;制限-https-github-com-google-leveldb-limitations&#34;&gt;&lt;a href=&#34;https://github.com/google/leveldb#limitations&#34;&gt;制限&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SQLデータベースではない。リレーショナルなデータモデルは持てないし、SQLやインデックスにも対応していない。&lt;/li&gt;
&lt;li&gt;一度に一つのプロセスしかDBにアクセスできない。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;キャッシュ-https-rawgit-com-google-leveldb-master-doc-index-html&#34;&gt;&lt;a href=&#34;https://rawgit.com/google/leveldb/master/doc/index.html&#34;&gt;キャッシュ&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;DBはファイルシステムのディレクトリに対応する名前を持ち、内容はそのディレクトリに保存される。&lt;/li&gt;
&lt;li&gt;各ファイルには圧縮したブロックが保存され、良く使うものについては非圧縮のブロックがキャッシュされる。&lt;/li&gt;
&lt;li&gt;ソートして隣接するキーは通常、同じブロックに配置される。ディスク転送とキャッシュはブロック単位。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;フィルタ&#34;&gt;フィルタ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Getの際、不要なデータを読まなくていいようにフィルタ(Bloom Filter)を用いることができる。&lt;/li&gt;
&lt;li&gt;独自の比較関数(末尾のスペースを無視するなど)を使う場合、Bloom Filterを使うことができないことがあるので、その場合は独自のフィルタが必要。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;レベル-https-rawgit-com-google-leveldb-master-doc-impl-html&#34;&gt;&lt;a href=&#34;https://rawgit.com/google/leveldb/master/doc/impl.html&#34;&gt;レベル&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;最近の更新はログファイルに保存される。これが決められたサイズ(デフォルトでは約4MB)に達すると、sorted table(sst)に変換され、新しいログファイルが生成される。&lt;/li&gt;
&lt;li&gt;現在のログファイルのコピーがメモリ(memtable)にも乗って読み取りで参照される。&lt;/li&gt;
&lt;li&gt;sstはキーによってソートされたエントリーを保存する。エントリーはキーの値か、削除マーカー。&lt;/li&gt;
&lt;li&gt;sstはレベルによってまとめられる。ログファイルから変換されると、特別なyoungレベル(level-0とも呼ばれる)に配置される。&lt;/li&gt;
&lt;li&gt;youngファイルの数があるしきい値(現在4つ)を超えると全てのyoungファイルを全てのlevel-1ファイルとマージし、新しいlevel-1ファイルを生成する(2MBごとに1ファイル)。&lt;/li&gt;
&lt;li&gt;youngレベルのファイルにはキーが重複していることがある。しかし、他のレベルでは重複しないキーの範囲がある。&lt;/li&gt;
&lt;li&gt;level-L(L&amp;gt;=1)のファイルの合計サイズが&lt;code&gt;10^L MB&lt;/code&gt;を超えたとき、level-Lのファイルと、level-(L+1)の全てのファイルをマージし、新しいlevel-(L+1)ファイルを生成する。&lt;/li&gt;
&lt;li&gt;これによって、バルク読み込み/書き込みのみを使い、コストが高いシークを最小限にして、youngレベルから大きいレベルに更新を徐々にマイグレーションすることができる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;LevelDBのgo実装。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/syndtr/goleveldb&#34;&gt;syndtr/goleveldb&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/syndtr/goleveldb/leveldb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずDBを開く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// open
db, err := leveldb.OpenFile(&amp;quot;/Users/sambaiz/leveldb&amp;quot;, nil)
defer db.Close()
if err != nil {
    panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;普通に5個(key0~4)、バッチで5個(key5~9)のデータを入れて、そのうち一つを消す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// put
for i := 0; i &amp;lt; 5; i++ {
    if err = db.Put([]byte(fmt.Sprintf(&amp;quot;key%d&amp;quot;, i)), []byte(fmt.Sprintf(&amp;quot;value%d&amp;quot;, i)), nil); err != nil {
        panic(err)
    }
}

// batch
batch := new(leveldb.Batch)
for i := 5; i &amp;lt; 10; i++ {
    batch.Put([]byte(fmt.Sprintf(&amp;quot;key%d&amp;quot;, i)), []byte(fmt.Sprintf(&amp;quot;value%d&amp;quot;, i)))
}
if err = db.Write(batch, nil); err != nil{
    panic(err)
}

// delete
if err = db.Delete([]byte(&amp;quot;key2&amp;quot;), nil); err != nil {
    panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この時点でこんなファイルが生成され、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
000001.log	CURRENT		LOCK		LOG		MANIFEST-000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;000001.logの中身はこんな感じになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ od -c 000001.log 
0000000    Z 221   @ 300 031  \0 001 001  \0  \0  \0  \0  \0  \0  \0 001
0000020   \0  \0  \0 001 004   k   e   y   0 006   v   a   l   u   e   0
0000040    o 037   = 373 031  \0 001 002  \0  \0  \0  \0  \0  \0  \0 001
0000060   \0  \0  \0 001 004   k   e   y   1 006   v   a   l   u   e   1
0000100  256 343   &amp;gt; 311 031  \0 001 003  \0  \0  \0  \0  \0  \0  \0 001
0000120   \0  \0  \0 001 004   k   e   y   2 006   v   a   l   u   e   2
0000140    = 006 330 341 031  \0 001 004  \0  \0  \0  \0  \0  \0  \0 001
0000160   \0  \0  \0 001 004   k   e   y   3 006   v   a   l   u   e   3
0000200  002 005   4 016 031  \0 001 005  \0  \0  \0  \0  \0  \0  \0 001
0000220   \0  \0  \0 001 004   k   e   y   4 006   v   a   l   u   e   4
0000240    d 240 344   {   M  \0 001 006  \0  \0  \0  \0  \0  \0  \0 005
0000260   \0  \0  \0 001 004   k   e   y   5 006   v   a   l   u   e   5
0000300  001 004   k   e   y   6 006   v   a   l   u   e   6 001 004   k
0000320    e   y   7 006   v   a   l   u   e   7 001 004   k   e   y   8
0000340  006   v   a   l   u   e   8 001 004   k   e   y   9 006   v   a
0000360    l   u   e   9   ! 233 277 371 022  \0 001  \v  \0  \0  \0  \0
0000400   \0  \0  \0 001  \0  \0  \0  \0 004   k   e   y   2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取得するにはkeyを指定して&lt;code&gt;Get()&lt;/code&gt;したり、Iteratorを使う。
IteratorはSeekしたり、StartやLimitを設定したり、Prefixを指定して取ってくることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// get
fmt.Println(&amp;quot;-- get --&amp;quot;)
for i := 0; i &amp;lt; 10; i++ {
    var data []byte
    if data, err = db.Get([]byte(fmt.Sprintf(&amp;quot;key%d&amp;quot;, i)), nil); err != nil {
        fmt.Printf(&amp;quot;key%d: %s\n&amp;quot;, i, err.Error())
    } else {
        fmt.Printf(&amp;quot;key%d: %s\n&amp;quot;, i, string(data))
    }
}

// iterate
fmt.Println(&amp;quot;-- iterate --&amp;quot;)
iter := db.NewIterator(nil, nil)
for iter.Next() {
    key := iter.Key()
    value := iter.Value()
    fmt.Printf(&amp;quot;%s: %s\n&amp;quot;, string(key), string(value))
}
iter.Release()
if err = iter.Error(); err != nil {
    panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- get --
key0: value0
key1: value1
key2: leveldb: not found
key3: value3
key4: value4
key5: value5
key6: value6
key7: value7
key8: value8
key9: value9
-- iterate --
key0: value0
key1: value1
key3: value3
key4: value4
key5: value5
key6: value6
key7: value7
key8: value8
key9: value9
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>gvmでGoのバージョン管理</title>
          <link>http://sambaiz.net/article/44/</link>
          <pubDate>Tue, 20 Dec 2016 20:52:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/44/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/moovweb/gvm&#34;&gt;moovweb/gvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;必要なものはREADMEを見て入れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
$ source ${HOME}/.gvm/scripts/gvm
$ gvm install go1.7 -B
$ gvm use go1.7
$ go version
go version go1.7 linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$GOPATH&lt;/code&gt;と&lt;code&gt;$GOROOT&lt;/code&gt;が書き変わる(&lt;code&gt;${HOME}/.gvm/pkgsets/go1.7/global/&lt;/code&gt;)ので注意。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>複数EC2インスタンスを立ち上げてvegetaで負荷試験する</title>
          <link>http://sambaiz.net/article/43/</link>
          <pubDate>Sun, 18 Dec 2016 20:52:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/43/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/tsenart/vegeta&#34;&gt;vegeta&lt;/a&gt;で負荷をかける。&lt;/p&gt;

&lt;h2 id=&#34;インスタンスを立ち上げるスクリプト&#34;&gt;インスタンスを立ち上げるスクリプト&lt;/h2&gt;

&lt;p&gt;コードはここ。 &lt;a href=&#34;https://github.com/sambaiz/loadtest&#34;&gt;sambaiz/loadtest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;まずキーペアを作成し、EC2インスタンスを立ち上げて、全てのインスタンスが使えるようになるまで待つ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws ec2 create-key-pair --key-name LoadTestKeyPare --query &#39;KeyMaterial&#39; --output text &amp;gt; LoadTestKeyPare.pem
chmod 400 LoadTestKeyPare.pem
aws ec2 run-instances --image-id $AMI_ID --count $INSTANCE_NUM --instance-type t2.micro --key-name LoadTestKeyPare --security-group-ids $SECURITY_GROUP_IDS --subnet-id $SUBNET_ID
...
aws ec2 wait instance-status-ok --instance-ids $INSTANCE_IDS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このAMIは事前にPackerでつくったもの。vegetaをインストールしてファイルディスクリプタの上限を増やしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;variables&amp;quot;: {
    &amp;quot;aws_access_key&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;aws_secret_key&amp;quot;: &amp;quot;&amp;quot;
  },
  &amp;quot;builders&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;amazon-ebs&amp;quot;,
    &amp;quot;access_key&amp;quot;: &amp;quot;{{user `aws_access_key`}}&amp;quot;,
    &amp;quot;secret_key&amp;quot;: &amp;quot;{{user `aws_secret_key`}}&amp;quot;,
    &amp;quot;region&amp;quot;: &amp;quot;ap-northeast-1&amp;quot;,
    &amp;quot;source_ami&amp;quot;: &amp;quot;ami-0c11b26d&amp;quot;,
    &amp;quot;instance_type&amp;quot;: &amp;quot;t2.micro&amp;quot;,
    &amp;quot;ssh_username&amp;quot;: &amp;quot;ec2-user&amp;quot;,
    &amp;quot;ami_name&amp;quot;: &amp;quot;loadtest {{timestamp}}&amp;quot;
  }],
  &amp;quot;provisioners&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
    &amp;quot;inline&amp;quot;: [
      &amp;quot;wget https://github.com/tsenart/vegeta/releases/download/v6.1.1/vegeta-v6.1.1-linux-amd64.tar.gz&amp;quot;,
      &amp;quot;sudo tar xzf vegeta-v6.1.1-linux-amd64.tar.gz -C /usr/local/bin/&amp;quot;,
      &amp;quot;sudo sh -c \&amp;quot;echo &#39;* hard nofile 65536&#39; &amp;gt;&amp;gt; /etc/security/limits.conf\&amp;quot;&amp;quot;,
      &amp;quot;sudo sh -c \&amp;quot;echo &#39;* soft nofile 65536&#39; &amp;gt;&amp;gt; /etc/security/limits.conf\&amp;quot;&amp;quot;
    ]
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;立ち上がったインスタンスに対して&lt;a href=&#34;https://code.google.com/p/pdsh/&#34;&gt;pdsh&lt;/a&gt;で
各マシンでvegetaを実行させ($VEGETA_CMD)、結果のファイルを集めてreportのinputsで指定すると
まとめてレポートを出力してくれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pdsh -l ec2-user -w `echo &amp;quot;$PUBLIC_DNS_NAMES&amp;quot; |  paste -d, -s -` &amp;quot;$VEGETA_CMD &amp;gt; result.bin&amp;quot;

for machine in $PUBLIC_DNS_NAMES; do
  scp -i ./LoadTestKeyPare.pem -oStrictHostKeyChecking=no ec2-user@$machine:~/result.bin $machine
done

vegeta report -inputs=`echo $PUBLIC_DNS_NAMES |  paste -d, -s -`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;終わったら後片付けをする。trapでCtrl+C等での終了時もインスタンスが残らないようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cleanup() {
  echo &amp;quot;---- Clean up ----&amp;quot;
  aws ec2 terminate-instances --instance-ids $INSTANCE_IDS
  aws ec2 delete-key-pair --key-name LoadTestKeyPare
  rm -f LoadTestKeyPare.pem
  rm $PUBLIC_DNS_NAMES
}
trap cleanup EXIT SIGHUP SIGINT SIGQUIT SIGTERM
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;実行する&#34;&gt;実行する&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ brew install awscli pdsh jq vegeta packer
$ aws configure
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのスクリプト(sample/sample.sh)から実行する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

export INSTANCE_NUM=3

export AMI_ID=ami-*****
export SECURITY_GROUP_IDS=sg-*****
export SUBNET_ID=subnet-*****

export RESOURCES_DIR=res

# https://github.com/tsenart/vegeta#attack
export VEGETA_CMD=&#39;vegeta attack -targets=res/targets.txt -rate=1000 -duration=10s&#39;

sh run.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sample/res/targets.txt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET http://example.com/

POST http://example.com/
@res/post.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;何も指定しないとこんな感じ(-reporter=text)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Requests      [total, rate]            10000, 1000.10
Duration      [total, attack, wait]    10.011642793s, 9.998999835s, 12.642958ms
Latencies     [mean, 50, 95, 99, max]  14.781775ms, 4.262304ms, 68.475899ms, 97.492882ms, 1.096072997s
Bytes In      [total, mean]            15285000, 1528.50
Bytes Out     [total, mean]            110000, 11.00
Success       [ratio]                  100.00%
Status Codes  [code:count]             200:10000  
Error Set:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもjsonだったり、plotを指定するとレイテンシのグラフのhtmlが出力される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/43_plot.jpg&#34; alt=&#34;グラフ&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>SSHポートフォワーディングとnetstatのメモ</title>
          <link>http://sambaiz.net/article/42/</link>
          <pubDate>Sat, 17 Dec 2016 12:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/42/</guid>
          <description>

&lt;h2 id=&#34;sshポートフォワーディング&#34;&gt;SSHポートフォワーディング&lt;/h2&gt;

&lt;p&gt;ローカルの8080ポートを、example.comを通したexample2.comの80ポートに向ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh hoge@example.com -Nf -L 8080:example2.com:80 
$ curl localhost:8080 # =&amp;gt; example2.com:80
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt;: リモートでコマンドを実行しない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;: バックグラウンドで実行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;netstat&#34;&gt;netstat&lt;/h2&gt;

&lt;p&gt;ネットワークの状態を確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ netstat -ant
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN 
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt;: non-listening(TCPではESTABLISHED状態)しているソケットだけではなく、listeningしている情報も出す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;: 数値のアドレスで表示する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt;: TCPで制限&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ファイルディスクリプタの上限を増やす</title>
          <link>http://sambaiz.net/article/41/</link>
          <pubDate>Thu, 08 Dec 2016 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/41/</guid>
          <description>

&lt;h2 id=&#34;ファイルディスクリプタとは&#34;&gt;ファイルディスクリプタとは&lt;/h2&gt;

&lt;p&gt;プロセスの外部とやりとりするための識別子。POSIXではint型で、0がstdin、1がstdout、2がstderrといったもの。
ファイルやデバイスに対するopen()や、
ネットワーク(INETドメインソケット)やホスト内(UNIXドメインソケット)で
通信するためのソケットを生成するsocket()などのシステムコールで生成される。&lt;/p&gt;

&lt;h2 id=&#34;ファイルディスクリプタの上限&#34;&gt;ファイルディスクリプタの上限&lt;/h2&gt;

&lt;p&gt;一つのプロセスがリソースを食いつぶさないように
使えるファイルディスクリプタの上限が決まっていて、&lt;code&gt;ulimit -n&lt;/code&gt;で確認できる。デフォルトは大体1024。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -n
1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各プロセスの上限と使っているファイルディスクリプタはこれで確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /proc/&amp;lt;プロセスID&amp;gt;/limits
...
Max open files            1024                 4096                 files     
...

$ ls -l /proc/&amp;lt;プロセスID&amp;gt;/fd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webサーバーのように同時にたくさん通信したりすると上限に達してしまい、&lt;code&gt;Too many open files&lt;/code&gt;になってしまうので増やす必要がある。&lt;/p&gt;

&lt;h3 id=&#34;etc-security-limits-conf-で変更する&#34;&gt;&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;で変更する&lt;/h3&gt;

&lt;p&gt;PAM認証時(ログインするときなど)に適用されるので、サーバーの起動時に立ち上がったデーモンには使えない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /etc/pam.d/sshd
...
session    required     pam_limits.so
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全てのユーザー(&lt;code&gt;*&lt;/code&gt;)のプロセスが使える
ファイルディスクリプタ(nofile)のsoft(ユーザーが設定できる)とhard(rootが設定できる)上限を共に64000にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;* hard nofile 64000&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
$ echo &amp;quot;* soft nofile 64000&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
$ ulimit -n
64000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ulimit-n-で変更する&#34;&gt;&lt;code&gt;ulimit -n&lt;/code&gt;で変更する&lt;/h3&gt;

&lt;p&gt;シェルと、起動したプロセスで有効。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -n 64000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dockerコンテナでは&#34;&gt;dockerコンテナでは&lt;/h3&gt;

&lt;p&gt;run時に&lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/run/#/set-ulimits-in-container---ulimit&#34;&gt;ulimitオプション&lt;/a&gt;で
&lt;code&gt;--ulimit nofile=11111&lt;/code&gt;のように指定することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -itd --ulimit nofile=11111 ubuntu
$ docker exec -it &amp;lt;id&amp;gt; /bin/bash -c &amp;quot;ulimit -n&amp;quot;
11111
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://open-groove.net/linux/memo-etcsecuritylimits-conf/&#34;&gt;/etc/security/limits.confに関するメモ | OpenGroove&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://staffblog.yumemi.jp/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E6%95%B0%E3%81%AE%E4%B8%8A%E9%99%90%E5%A4%89%E6%9B%B4%E3%81%A8limits-conf%E3%81%AE%E7%BD%A0-2/&#34;&gt;ファイルディスクリプタ数の上限変更とlimits.confの罠&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.koikikukan.com/archives/2013/03/14-005555.php&#34;&gt;Linuxのファイルディスクリプタ数を変更・確認する方法: 小粋空間&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/ファイル記述子&#34;&gt;ファイル記述子 - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/kuni-nakaji/items/d11219e4ad7c74ece748&#34;&gt;調べなきゃ寝れない！と調べたら余計に寝れなくなったソケットの話 - Qiita&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Angular2とangular-cliでTODOを作る</title>
          <link>http://sambaiz.net/article/40/</link>
          <pubDate>Mon, 05 Dec 2016 00:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/40/</guid>
          <description>

&lt;p&gt;コード: &lt;a href=&#34;https://github.com/sambaiz/angular2-todo&#34;&gt;https://github.com/sambaiz/angular2-todo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/40.gif&#34; alt=&#34;動いているところ&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;アプリケーションの作成と立ち上げ&#34;&gt;アプリケーションの作成と立ち上げ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular-cli&#34;&gt;angular-cli&lt;/a&gt;をインストールしてサーバーを立ち上げるまで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install angular-cli -g
$ ng -v
angular-cli: 1.0.0-beta.21
node: 5.12.0
os: darwin x64

$ ng new mytodo
$ cd mytodo
$ ng server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:4200/&#34;&gt;http://localhost:4200/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;新しいコンポーネントを作る&#34;&gt;新しいコンポーネントを作る&lt;/h2&gt;

&lt;p&gt;新しいコンポーネントを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component todo-list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでtodo-listディレクトリにコンポーネントクラスとテンプレートとCSS、テストとindexが出力される。&lt;/p&gt;

&lt;p&gt;また、app.module.ts(BootstrapするRoot Module)にも追加されている。
NgModuleのdeclartionsなどに入っているものは、各Componentで指定しなくても使えるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { NgModule } from &#39;@angular/core&#39;;
import { FormsModule } from &#39;@angular/forms&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import { AppComponent } from &#39;./app.component&#39;;
import { TodoListComponent } from &#39;./todo-list/todo-list.component&#39;;

@NgModule({
  declarations: [
    AppComponent,
    TodoListComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、この状態でAppComponentのtemplateに追加するだけでTodoListComponentが表示される。
このapp-todo-listというのはコンポーネントのselectorと対応している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;
  {{title}}
&amp;lt;/h1&amp;gt;
&amp;lt;app-todo-list&amp;gt;&amp;lt;/app-todo-list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;@Component({
  selector: &#39;app-todo-list&#39;,
  templateUrl: &#39;./todo-list.component.html&#39;,
  styleUrls: [&#39;./todo-list.component.css&#39;]
})
export class TodoListComponent {
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;todoリストを表示する&#34;&gt;TODOリストを表示する&lt;/h2&gt;

&lt;p&gt;TODOリストを入力として受け取って表示するコンポーネントを作る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@Input&lt;/code&gt;で入力を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit, Input } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-todo-list&#39;,
  templateUrl: &#39;./todo-list.component.html&#39;,
  styleUrls: [&#39;./todo-list.component.css&#39;]
})
export class TodoListComponent implements OnInit {

  @Input() todos: string[] = [];

  constructor() { }

  ngOnInit() {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;渡すときは&lt;code&gt;[@Inputの変数名]=&amp;quot;値&amp;quot;&lt;/code&gt;。分かりやすいように変数名を変えてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;app-todo-list [todos]=&amp;quot;todos_&amp;quot;&amp;gt;&amp;lt;/app-todo-list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-root&#39;,
  templateUrl: &#39;./app.component.html&#39;,
  styleUrls: [&#39;./app.component.css&#39;]
})
export class AppComponent {
  title = &#39;app works!&#39;;
  todos_ = [&amp;quot;朝起きる&amp;quot;, &amp;quot;昼ご飯を食べる&amp;quot;, &amp;quot;夜ご飯を食べる&amp;quot;, &amp;quot;寝る&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;todosは&lt;code&gt;*ngFor&lt;/code&gt;でループさせて表示させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
  &amp;lt;li
    *ngFor=&amp;quot;let todo of todos&amp;quot;
  &amp;gt;
  {{todo}}
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、出力する/しないを制御する&lt;code&gt;*ngIf&lt;/code&gt;もあって、
これらの頭に付いている
&lt;code&gt;*&lt;/code&gt;はStructural directivesの&lt;a href=&#34;https://angular.io/docs/dart/latest/guide/structural-directives.html#!#asterisk&#34;&gt;糖衣構文&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Directiveは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コンポーネント&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/dart/latest/guide/structural-directives.html&#34;&gt;Structual directives&lt;/a&gt; (DOM elementを追加したり削除したりする)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/dart/latest/guide/attribute-directives.html&#34;&gt;Attribute directives&lt;/a&gt; (Dom elementの見た目や挙動を変える)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の3種類ある。&lt;/p&gt;

&lt;h2 id=&#34;todoを登録する&#34;&gt;TODOを登録する&lt;/h2&gt;

&lt;p&gt;登録する用のコンポーネントを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ng g component todo-form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度は&lt;code&gt;@Output&lt;/code&gt;で出力する方。
onCreateTodoでEventEmitterのnextに次の状態を渡してイベントを発火させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iimport { Component, OnInit, Output, EventEmitter } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-todo-form&#39;,
  templateUrl: &#39;./todo-form.component.html&#39;,
  styleUrls: [&#39;./todo-form.component.css&#39;]
})
export class TodoFormComponent implements OnInit {

  @Output() createTodo = new EventEmitter();

  newTodo = &amp;quot;&amp;quot;;

  constructor() { }

  ngOnInit() {
  }

  onCreateTodo() {
    if(this.newTodo !== &amp;quot;&amp;quot;) this.createTodo.next(this.newTodo);
    this.newTodo = &amp;quot;&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フォームでは&lt;code&gt;(ngSubmit)&lt;/code&gt;でonsubmitイベント時にonCreateTodoが呼ばれるようにしている。
また、&lt;code&gt;[(ngModel)]=&amp;quot;newTodo&amp;quot;&lt;/code&gt;でnewTodoを
&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/template-syntax.html#!#ngModel&#34;&gt;Two-way binding&lt;/a&gt;して
フォームと変数の値を同期させる。これにはFormsModuleが必要で、既にRoot Moduleに含まれている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;form (ngSubmit)=&amp;quot;onCreateTodo()&amp;quot;&amp;gt;
    &amp;lt;input
      type=&amp;quot;text&amp;quot;
      name=&amp;quot;todo&amp;quot;
      [(ngModel)]=&amp;quot;newTodo&amp;quot;
    &amp;gt;
    &amp;lt;button
      type=&amp;quot;submit&amp;quot;
    &amp;gt;
    登録
    &amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Output&lt;/code&gt;はこんな感じでハンドリングする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;app-todo-form (createTodo)=&amp;quot;onCreateTodo($event)&amp;quot;&amp;gt;&amp;lt;/app-todo-form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登録イベントが起きたらtodos_に追加していく。これでリストの方も更新される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;app-root&#39;,
  templateUrl: &#39;./app.component.html&#39;,
  styleUrls: [&#39;./app.component.css&#39;]
})
export class AppComponent {
  title = &#39;app works!&#39;;
  todos_ = [&amp;quot;朝起きる&amp;quot;, &amp;quot;昼ご飯を食べる&amp;quot;, &amp;quot;夜ご飯を食べる&amp;quot;, &amp;quot;寝る&amp;quot;]

  onCreateTodo(todo) {
    this.todos_.push(todo);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;apiを叩くサービスを作る&#34;&gt;APIを叩くサービスを作る&lt;/h2&gt;

&lt;p&gt;データを保存して取得する簡易的なAPIを用意した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&#39;express&#39;)
var bodyParser = require(&#39;body-parser&#39;)
var app = express()
app.use(bodyParser());

data = []

app.get(&#39;/&#39;, function (req, res) {
  res.send(data)
})

app.post(&#39;/&#39;, function (req, res) {
  data.push(req.body)
  res.send(req.body)
})

app.listen(3000, function () {
  console.log(&#39;listening on port 3000&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir services
$ ng g service services/todo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サービスクラスとテストができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/server-communication.html&#34;&gt;HTTP Client - ts - GUIDE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Angularで用意されているHTTPクライアントは&lt;a href=&#34;https://github.com/ReactiveX/RxJS&#34;&gt;RxJS&lt;/a&gt;のObservableな値を返す。
これを扱うために&lt;code&gt;import &#39;rxjs/Rx&#39;&lt;/code&gt;するとサイズがとても大きくなってしまうので必要なものだけをimportする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &#39;rxjs/add/operator/map&#39;;
import &#39;rxjs/add/operator/catch&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタのhttpはAngularによって
providerから&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/dependency-injection.html&#34;&gt;DI&lt;/a&gt;される。
Root Moduleのprovidersは空になっているが、HttpModuleで提供されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iimport { Injectable } from &#39;@angular/core&#39;;
import { Http, Response, Headers, RequestOptions } from &#39;@angular/http&#39;;
import { Observable }     from &#39;rxjs/Observable&#39;;

@Injectable()
export class TodoService {
  private apiUrl = &#39;http://localhost:3000&#39;;

  constructor(private http: Http) { }

  getTodos (): Observable&amp;lt;string[]&amp;gt; {
    return this.http.get(this.apiUrl)
                    .map(this.extractData)
                    .catch(this.handleError);
  }

  addTodo (todo: string): Observable&amp;lt;string&amp;gt; {
    let headers = new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39; });
    let options = new RequestOptions({ headers: headers });

    return this.http.post(this.apiUrl, { todo }, options)
                    .map(this.extractData)
                    .catch(this.handleError);
  }

  private extractData(res: Response) {
    let body = res.json();
    return body || { };
  }

  private handleError (error: Response | any) {
    // In a real world app, we might use a remote logging infrastructure
    let errMsg: string;
    if (error instanceof Response) {
      const body = error.json() || &#39;&#39;;
      const err = body.error || JSON.stringify(body);
      errMsg = `${error.status} - ${error.statusText || &#39;&#39;} ${err}`;
    } else {
      errMsg = error.message ? error.message : error.toString();
    }
    console.error(errMsg);
    return Observable.throw(errMsg);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このサービスがDIされるようにprovidersに追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { NgModule } from &#39;@angular/core&#39;;
import { FormsModule } from &#39;@angular/forms&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import { AppComponent } from &#39;./app.component&#39;;
import { TodoListComponent } from &#39;./todo-list/todo-list.component&#39;;
import { TodoFormComponent } from &#39;./todo-form/todo-form.component&#39;;

import { TodoService } from &#39;./services/todo.service&#39;;

// RxJS
import &#39;rxjs/add/operator/map&#39;;
import &#39;rxjs/add/operator/catch&#39;;

@NgModule({
  declarations: [
    AppComponent,
    TodoListComponent,
    TodoFormComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [TodoService],
  bootstrap: [AppComponent]
})
export class AppModule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サービスを使うようにする。ngOnInitはコンポーネントのプロパティが初期化されたあと一度だけ呼ばれる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html&#34;&gt;Lifecycle Hooks - ts - GUIDE&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component, OnInit } from &#39;@angular/core&#39;;
import { TodoService } from &#39;./services/todo.service&#39;;

@Component({
  selector: &#39;app-root&#39;,
  templateUrl: &#39;./app.component.html&#39;,
  styleUrls: [&#39;./app.component.css&#39;]
})
export class AppComponent implements OnInit {
  title = &#39;app works!&#39;;
  todos_: string[] = []

  constructor(private todoService: TodoService) { }

  ngOnInit() {
    this.todoService.getTodos().subscribe(
                       todos =&amp;gt; this.todos_ = todos.map((t) =&amp;gt; t[&amp;quot;todo&amp;quot;]),
                       error =&amp;gt; this.todos_ = [&amp;quot;&amp;lt;error&amp;gt;&amp;quot;]);
  }

  onCreateTodo(todo: string) {
    this.todoService.addTodo(todo).subscribe(
                       todo =&amp;gt; this.todos_.push(todo[&amp;quot;todo&amp;quot;]),
                       error =&amp;gt; this.todos_ = [&amp;quot;&amp;lt;error&amp;gt;&amp;quot;]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テストは気が向いたら書く。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>OpenVPNサーバーPritunlをDockerで動かす</title>
          <link>http://sambaiz.net/article/39/</link>
          <pubDate>Fri, 02 Dec 2016 21:05:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/39/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://pritunl.com/&#34;&gt;Pritunl&lt;/a&gt;でVPNサーバーを立てる。&lt;/p&gt;

&lt;p&gt;Dockerfileはこんな感じ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/sambaiz/pritunl/&#34;&gt;https://hub.docker.com/r/sambaiz/pritunl/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM mongo:3.4

# https://docs.pritunl.com/docs/installation
RUN echo &#39;deb http://repo.pritunl.com/stable/apt jessie main&#39; &amp;gt; /etc/apt/sources.list.d/pritunl.list &amp;amp;&amp;amp; \
    apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv 7568D9BB55FF9E5287D586017AE645C0CF8E292A &amp;amp;&amp;amp; \
    apt-get --assume-yes update &amp;amp;&amp;amp; \
    apt-get --assume-yes upgrade &amp;amp;&amp;amp; \
    apt-get --assume-yes install pritunl iptables

EXPOSE 80 443 12345/udp

CMD mongod --fork --logpath /data/db/mongod.log &amp;amp;&amp;amp; echo &#39;Setup Key:&#39; `pritunl setup-key` &amp;amp;&amp;amp; pritunl start
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -itd -p 80:80 -p 443:443 -p 12345:12345/udp --privileged sambaiz/pritunl
$ docker logs &amp;lt;id&amp;gt;
...
Setup Key: ***********
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--privileged&lt;/code&gt;を付けているのはStart Server時にこれで失敗しないように。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CalledProcessError: Command &#39;[&#39;sysctl&#39;, &#39;-w&#39;, &#39;net.ipv4.ip_forward=1&#39;]&#39; returned non-zero exit status 255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;httpsでアクセスして、Setup Keyを入力すると初期設定が始まり、ログイン画面になる。
初期パスワードは&lt;code&gt;pritunl/pritunl&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;あとは、OrganizationとUser、Server(ポートはudpの12345にする)を登録し、ServerにOrganizationを紐付け、
ServerにRouteを追加して、アクセスしたいCIDRを入力したらStart Serverする。
ovpnファイルをダウンロードできる24時間有効のリンクを発行でき、これでクライアントに設定すると
RouteにVPNを通してアクセスできるようになる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>aws-sdk-goでs3にput/get</title>
          <link>http://sambaiz.net/article/38/</link>
          <pubDate>Wed, 30 Nov 2016 20:29:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/38/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/aws/aws-sdk-go&#34;&gt;aws-sdk-go&lt;/a&gt;でS3にputしてgetする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/aws&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/aws/session&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/service/s3&amp;quot;
)

const REGION = &amp;quot;ap-northeast-1&amp;quot;
const BUCKET_NAME = &amp;quot;faweijojio4f3e4&amp;quot;

func main() {

	sess, err := session.NewSession(aws.NewConfig().WithRegion(REGION))
	if err != nil {
		fmt.Println(err.Error())
		return
	}

	svc := s3.New(sess)

	// put
	data := []byte(&amp;quot;BBBBBB&amp;quot;)
	key := &amp;quot;AAA.txt&amp;quot;

	params := &amp;amp;s3.PutObjectInput{
		Bucket:        aws.String(BUCKET_NAME),
		Key:           aws.String(key),
		Body:          bytes.NewReader(data),
		ContentLength: aws.Int64(int64(len(data))),
		ContentType:   aws.String(&amp;quot;text/plain&amp;quot;),
	}
	if _, err = svc.PutObject(params); err != nil {
		fmt.Println(err.Error())
		return
	}

	// bucket list
	keys := []string{}
	err = svc.ListObjectsPages(&amp;amp;s3.ListObjectsInput{
		Bucket: aws.String(BUCKET_NAME),
	}, func(p *s3.ListObjectsOutput, last bool) (shouldContinue bool) {
		for _, obj := range p.Contents {
			keys = append(keys, *obj.Key)
			fmt.Println(*obj.Key)
		}
		return true
	})

	if err != nil {
		fmt.Println(err.Error())
		return
	}

	// get
	resp, err2 := svc.GetObject(&amp;amp;s3.GetObjectInput{
		Bucket: aws.String(BUCKET_NAME),
		Key:    aws.String(keys[0]),
	})
	if err2 != nil {
		fmt.Println(err2.Error())
		return
	}

	buf := new(bytes.Buffer)
	buf.ReadFrom(resp.Body)
	fmt.Println(keys[0] + &amp;quot; -&amp;gt; &amp;quot; + buf.String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ AWS_ACCESS_KEY_ID=**** AWS_SECRET_ACCESS_KEY=**** go run main.go
AAA.txt
bbbb.txt
AAA.txt -&amp;gt; BBBBBB
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Goでstructをリフレクションしてcsvを出力する</title>
          <link>http://sambaiz.net/article/37/</link>
          <pubDate>Mon, 28 Nov 2016 21:29:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/37/</guid>
          <description>&lt;p&gt;こんなstructとデータがあったら、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Result struct{
 Name string `col:&amp;quot;who&amp;quot;`
 Point int
}

x := Result{&amp;quot;sam&amp;quot;, 100}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;フィールド名と、値、タグはrefrectで取れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x := Result{&amp;quot;sam&amp;quot;, 100}
v := reflect.ValueOf(x)
fmt.Println(v.Type().Field(0).Name) // -&amp;gt; Name
fmt.Println(v.Type().Field(1).Name) // -&amp;gt; Point
fmt.Println(v.Field(0).Interface()) // -&amp;gt; sam
fmt.Println(v.Field(1).Interface()) // -&amp;gt; 100
fmt.Println(v.Type().Field(0).Tag.Get(&amp;quot;col&amp;quot;)) // -&amp;gt; who
fmt.Println(v.Type().Field(1).Tag.Get(&amp;quot;col&amp;quot;)) // -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらをencoding/csvで書く。&lt;/p&gt;

&lt;p&gt;ただ、引数を&lt;code&gt;[]interface{}&lt;/code&gt;にすると&lt;a href=&#34;https://golang.org/doc/faq#convert_slice_of_interface&#34;&gt;interface{}のスライスしか渡せない&lt;/a&gt;ので、
一旦&lt;code&gt;interface{}&lt;/code&gt;で受け取ってスライスにする。このときにもrefrectを使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;encoding/csv&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;reflect&amp;quot;
	&amp;quot;strings&amp;quot;
)

type Result struct {
	Name  string `col:&amp;quot;who&amp;quot;`
	Point int
	Age   int `col:&amp;quot;-&amp;quot;` // ignore
}

const COLTAG = &amp;quot;col&amp;quot;

func main() {

	x := []Result{Result{&amp;quot;sam&amp;quot;, 100, 24}, Result{&amp;quot;tom&amp;quot;, 0, 100025}}

	file, err := os.OpenFile(&amp;quot;aaaa.csv&amp;quot;, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	WriteCSV(file, x)
}

// Convert interface{} to []interface{}
func toSlice(src interface{}) []interface{} {

	ret := []interface{}{}

	if v := reflect.ValueOf(src); v.Kind() == reflect.Slice {
		for i := 0; i &amp;lt; v.Len(); i++ {
			ret = append(ret, v.Index(i).Interface())
		}
	} else {
		ret = append(ret, v.Interface())
	}

	return ret
}

// Generate csv rows including header from interface{} slice or object
func genRows(src interface{}) [][]string {

	sl := toSlice(src)
	rows := make([][]string, 1)
	ignoreColIndex := map[int]bool{}

	for n, d := range sl {
		rows = append(rows, []string{})
		v := reflect.ValueOf(d)

		for i := 0; i &amp;lt; v.NumField(); i++ {
			if n == 0 {
				// Header
				colName := v.Type().Field(i).Tag.Get(COLTAG)
				if colName == &amp;quot;&amp;quot; {
					colName = strings.ToLower(v.Type().Field(i).Name)
				} else if colName == &amp;quot;-&amp;quot; {
					ignoreColIndex[i] = true
					continue
				}
				rows[0] = append(rows[0], colName)
			}

			if !ignoreColIndex[i] {
				rows[len(rows)-1] = append(rows[len(rows)-1], fmt.Sprint(v.Field(i).Interface()))
			}
		}
	}
	return rows
}

// Write csv file to path
func WriteCSV(file *os.File, data interface{}) {
	rows := genRows(data)

	writer := csv.NewWriter(file)
	for _, row := range rows {
		writer.Write(row)
	}
	writer.Flush()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;who,point
sam,100
tom,0
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>WebVRを動かす</title>
          <link>http://sambaiz.net/article/36/</link>
          <pubDate>Wed, 16 Nov 2016 00:46:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/36/</guid>
          <description>

&lt;h3 id=&#34;webvrとは&#34;&gt;WebVRとは&lt;/h3&gt;

&lt;p&gt;Webブラウザ上でVRアプリケーションを動かすためのAPI。
ヘッドマウントディスプレイの動きを3D空間上の動きに変換してくれる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/WebVR_API&#34;&gt;WebVR API - Web API インターフェイス | MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただし、まだほとんどのブラウザがVR APIをサポートしていないので、
実際は&lt;a href=&#34;https://github.com/googlevr/webvr-polyfill&#34;&gt;Polyfill&lt;/a&gt;で動かすことになる。&lt;/p&gt;

&lt;h3 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h3&gt;

&lt;p&gt;まず、&lt;a href=&#34;https://github.com/borismus/webvr-boilerplate&#34;&gt;webvr-boilerplate&lt;/a&gt;を動かしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm init
$ npm install node-static
$ git clone https://github.com/borismus/webvr-boilerplate.git
$ cd webvr-boilerplate/ &amp;amp;&amp;amp; npm install &amp;amp; cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var static = require(&#39;node-static&#39;);

var fileServer = new static.Server(&#39;./webvr-boilerplate&#39;);

require(&#39;http&#39;).createServer(function (request, response) {
    request.addListener(&#39;end&#39;, function () {
        fileServer.serve(request, response);
    }).resume();
}).listen(8080);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;を見ると箱が回っているのが映る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/36_webvr1.png&#34; alt=&#34;箱が回っている&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ただ、start_modeに3を指定してVRモードにしようとしたところ、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080/index.html?start_mode=3&#34;&gt;http://localhost:8080/index.html?start_mode=3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PCのChromeから見ると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;base.js:191 Uncaught (in promise) Error: VRDisplay is not capable of presenting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーが出てしまった。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Only enable VR mode if there&amp;rsquo;s a VR device attached or we are running the polyfill on mobile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書いてあったので、Android端末から見てみたところ
Cardboardのマークが出てきて、それを押したら二眼の表示になった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/36_vrview.png&#34; alt=&#34;二眼で映っている&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;描画&#34;&gt;描画&lt;/h3&gt;

&lt;p&gt;webvr-boilerplateでは、描画に&lt;a href=&#34;https://threejs.org/&#34;&gt;Three.js&lt;/a&gt;を使っている。&lt;/p&gt;

&lt;p&gt;まずシーンやカメラを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、cameraをTHREE.VRControlsに渡す。この中でVR APIを呼んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var controls = new THREE.VRControls(camera);
controls.standing = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをupdateしていくことでVRデバイスにcameraが連動するようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;controls.update();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分でVR APIを呼んでいるところもあって、
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/Navigator/getVRDisplays&#34;&gt;Navigator.getVRDisplays()&lt;/a&gt;で
VRDisplayを取得し、
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/VRDevice/requestAnimationFrame&#34;&gt;VRDisplay.requestAnimationFrame()&lt;/a&gt;で、VRDisplayのリフレッシュレートでアニメーションさせるコールバックが呼ばれるようにしている。
このコールバックの中で&lt;code&gt;controls.update()&lt;/code&gt;を呼んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length &amp;gt; 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
      }
      vrDisplay.requestAnimationFrame(animate);
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>JVMのヒープ領域とFull GC</title>
          <link>http://sambaiz.net/article/35/</link>
          <pubDate>Mon, 14 Nov 2016 23:46:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/35/</guid>
          <description>

&lt;h3 id=&#34;ヒープ領域&#34;&gt;ヒープ領域&lt;/h3&gt;

&lt;p&gt;ヒープ領域というのはメモリ上の動的に確保する領域のこと。
JVMでは、ヒープ領域のNew領域とOld領域、非ヒープ領域のPermanent領域が存在する(した)。&lt;/p&gt;

&lt;h3 id=&#34;permanent領域&#34;&gt;Permanent領域&lt;/h3&gt;

&lt;p&gt;ロードしたクラスやメソッドが入る。
Java8版のHotspotVM(OracleのJVM)ではMetaspace領域となり、ネイティブメモリに乗るようになったらしい。&lt;/p&gt;

&lt;h3 id=&#34;new領域&#34;&gt;New領域&lt;/h3&gt;

&lt;p&gt;New領域の中はさらに分かれている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Eden領域: オブジェクトが作られて最初に配置される。&lt;/li&gt;
&lt;li&gt;To領域(Survivor領域1): Edenが一杯になると、EdenとFromから送られる。&lt;/li&gt;
&lt;li&gt;From領域(Survivor領域0): Edenが一杯になると、Toから送られる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Edenが一杯になったときに不要なオブジェクトは破棄、必要なものは領域を移動させるのがScavenge GC。
つまり、Edenが一杯になるたびにToに飛んだオブジェクトはFromと往復し続ける。
ただし、MaxTenuringThresholdの回数を超えるとOld領域に送られることになる。&lt;/p&gt;

&lt;h3 id=&#34;old領域&#34;&gt;Old領域&lt;/h3&gt;

&lt;p&gt;Old領域も一杯になったらどうしようもないのでFull GCが走る。
Full GCでは全ての領域のオブジェクトをチェックして不要なものを探す。
これに集中するので他のことはできなくなり、時間もかかる。
Full GCばかり起きていたらまともに動かないので、
Old領域にまで行かないようにオブジェクトの寿命を短くするか、
ヒープ領域の大きさ(&lt;code&gt;-Xms&lt;/code&gt;, &lt;code&gt;-Xmx&lt;/code&gt;)を変えたりしてなるべく起きないようにしたい。&lt;/p&gt;

&lt;h3 id=&#34;どれくらいfull-gcしているかどうか&#34;&gt;どれくらいFull GCしているかどうか&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;-Xloggc&lt;/code&gt;でGCのログが出せる。&lt;code&gt;-XX:+UseGCLogFileRotation&lt;/code&gt;でローテーションしたりもできる。
あと手軽に&lt;code&gt;jps&lt;/code&gt;からの&lt;code&gt;jstat -gc &amp;lt;pid&amp;gt;&lt;/code&gt;、あるいはグラフで可視化できるようなやつでヒープ領域の状態を確認する。
&lt;code&gt;jstat&lt;/code&gt;の結果の意味は&lt;a href=&#34;https://docs.oracle.com/javase/jp/8/docs/technotes/tools/windows/jstat.html&#34;&gt;ここ&lt;/a&gt;に書いてある。
例えばFGCがフルGCイベントの数。&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/ogin_s57/20120623/1340463194&#34;&gt;JVMとGCのしくみ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://equj65.net/tech/java8hotspot/&#34;&gt;Java8のHotSpotVMからPermanent領域が消えた理由とその影響 | ギークを目指して&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/i_matsui/items/aabbdaa169c6ae51ecb3&#34;&gt;Java開発の性能改善！ その２ GCログの解析とHeepの設定&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>API BlueprintでAPI仕様を書く</title>
          <link>http://sambaiz.net/article/34/</link>
          <pubDate>Thu, 10 Nov 2016 00:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/34/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://apiblueprint.org/&#34;&gt;API Blueprint&lt;/a&gt;というのはAPIの仕様を書くための言語で、
これを元にHTMLのドキュメントにしたり、モックサーバーを立てたりする&lt;a href=&#34;https://apiblueprint.org/tools.html&#34;&gt;ツール&lt;/a&gt;がある。&lt;/p&gt;

&lt;p&gt;最初にMetadataとして、API Blueprintのバージョンを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FORMAT: 1A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本的にはMarkdownのように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# テストAPI
テスト
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;頭にGroupと書くとグループができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Group echo
やまびこ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;終わりに&lt;code&gt;[]&lt;/code&gt;で囲んでリソースを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## echo [/echo]
やっほー
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アクション。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### echo [POST]
叫ぶ

+ say (string) - 発声
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエスト例とレスポンス例はこんな感じ。&lt;a href=&#34;https://apiblueprint.org/documentation/advanced-tutorial.html#json-schema&#34;&gt;JSON Schemaを書くこともできる&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ Request (application/json)

    {
        &amp;quot;say&amp;quot;: &amp;quot;yahho&amp;quot;
    }

+ Response 200 (application/json)

  + Headers

    Hoge: Fuga

  + Body

    {
        &amp;quot;echo&amp;quot;: &amp;quot;yahho&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全体&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FORMAT: 1A

# テストAPI
テスト

# Group echo
やまびこ

## echo [/echo]
やっほー

### echo [POST]
叫ぶ

+ say (string) - 発声

+ Request (application/json)

    {
        &amp;quot;say&amp;quot;: &amp;quot;yahho&amp;quot;
    }

+ Response 200 (application/json)

  + Headers

    Hoge: Fuga

  + Body

    {
        &amp;quot;echo&amp;quot;: &amp;quot;yahho&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使って、&lt;a href=&#34;https://github.com/danielgtaylor/aglio&#34;&gt;aglio&lt;/a&gt;でHTMLにしたり、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g aglio
$ aglio -i test.apib -o test.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/34_api_html.png&#34; alt=&#34;HTMLに出力したもの&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/localmed/api-mock&#34;&gt;api-mock&lt;/a&gt;でモックを立てたりすることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g api-mock
$ api-mock --version
api-mock v0.3.2

$ api-mock test.apib
info:    Enabled Cross-Origin-Resource-Sharing (CORS)
info:    	Allow-Origin: *
info:    	Allow-Methods: GET, PUT, POST, PATCH, DELETE, TRACE, OPTIONS
info:    	Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, Authorization, Referer, Prefer
info:    Listening on port 3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただnode v6でインストールしたらprotagonistのところで失敗してしまったので、5.12.0に下げて実行した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/8/&#34;&gt;nでNode.jsのバージョン管理&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ n 5.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl -X POST -H &amp;quot;Content-Type: application/json&amp;quot; -d &#39;{&amp;quot;say&amp;quot;: &amp;quot;ho&amp;quot;}&#39; &amp;quot;http://localhost:3000/echo&amp;quot;
{
    &amp;quot;echo&amp;quot;: &amp;quot;yahho&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>logrotateでログをローテーションする</title>
          <link>http://sambaiz.net/article/33/</link>
          <pubDate>Wed, 09 Nov 2016 22:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/33/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/Sirupsen/logrus&#34;&gt;logrus&lt;/a&gt;がローテーションする仕組みを持っていなかったので、
READMEに書いてあったlogrotateを使う。/etc/logrotate.dの中に設定ファイルを入れて、cronで回して使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM ubuntu:14.04

ADD logrotate /etc/logrotate.d/app
RUN echo &amp;quot;/usr/sbin/logrotate /etc/logrotate.conf&amp;quot; &amp;gt; /etc/cron.daily/logrotate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定ファイル(logrotate)はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/log/app.log {
  daily
  rotate 4
  missingok
  delaycompress
  dateext
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;daily&lt;/code&gt;で1日に1回、&lt;code&gt;rotate 4&lt;/code&gt;で過去4日分残し、
&lt;code&gt;missingok&lt;/code&gt;でファイルがなくてもエラーにせず、&lt;code&gt;delaycompress&lt;/code&gt;で圧縮するのをローテーションした次の回にして、
&lt;code&gt;dateext&lt;/code&gt;でローテーションしたファイルの末尾を数字ではなく日付にする。&lt;/p&gt;

&lt;p&gt;実際に動かして確かめる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;logrotate&lt;/code&gt;を実行すると、&lt;code&gt;/var/lib/logrotate/status&lt;/code&gt;に過去に見た時間が入る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;aaaaa&amp;quot; &amp;gt; /var/log/app.log
$ logrotate /etc/logrotate.conf
$ cat /var/lib/logrotate/status
logrotate state -- version 2
...
&amp;quot;/var/log/app.log&amp;quot; 2016-11-9-11:0:0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;強制的にローテーションさせてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;aaaa&amp;quot; &amp;gt; /var/log/app.log
$ logrotate -f /etc/logrotate.conf
$ ls /var/log | grep app
app.log
app.log-20161109

$ cat /var/log/app.log-20161109
aaaaa
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>td-agentをビルドしてfluentdのバージョンを上げる</title>
          <link>http://sambaiz.net/article/32/</link>
          <pubDate>Sun, 06 Nov 2016 11:17:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/32/</guid>
          <description>&lt;pre&gt;&lt;code&gt;$td-agent --version
td-agent 0.12.26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;td-agentって書いてあるけど、これがfluentdのバージョンらしい。&lt;/p&gt;

&lt;p&gt;fluentdはv0.14から&lt;a href=&#34;http://www.fluentd.org/blog/fluentd-v0.14.0-has-been-released&#34;&gt;ナノ秒で時間を持つようになった。&lt;/a&gt;
ただ、現行のtd-agent(v2.3.2)は上の通り古いバージョンを使っている。
0.14になる&lt;a href=&#34;https://github.com/treasure-data/omnibus-td-agent/tree/td-agent-3&#34;&gt;td-agent-3&lt;/a&gt;はまだリリースされていないので、
自分でfluentdを&lt;a href=&#34;https://github.com/fluent/fluentd/releases/tag/v0.14.8&#34;&gt;v0.14.8&lt;/a&gt;に上げてビルドすることにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM ubuntu:14.04

WORKDIR /tmp

RUN apt-get update &amp;amp;&amp;amp; \
    apt-get install -y git software-properties-common build-essential curl &amp;amp;&amp;amp; \
    add-apt-repository -y ppa:brightbox/ruby-ng &amp;amp;&amp;amp; \
    apt-get update &amp;amp;&amp;amp; \
    apt-get install -y ruby2.3 ruby2.3-dev &amp;amp;&amp;amp; \
    gem install bundler &amp;amp;&amp;amp; \
    git clone https://github.com/treasure-data/omnibus-td-agent

WORKDIR /tmp/omnibus-td-agent

RUN sed -ie &amp;quot;s/^default_version.*$/default_version &#39;3d1dd53f31d1fe49508f230a71a2b4c2ceb20f47&#39;/&amp;quot; config/software/fluentd.rb &amp;amp;&amp;amp; \
    sed -ie &amp;quot;s/^license_file.*$/license_file &#39;LICENSE&#39;/&amp;quot; config/projects/td-agent2.rb &amp;amp;&amp;amp; \
    bundle install --binstubs &amp;amp;&amp;amp; \
    bin/gem_downloader core_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader plugin_gems.rb &amp;amp;&amp;amp; \
    bin/gem_downloader ui_gems.rb &amp;amp;&amp;amp; \
    git config --global user.email &amp;quot;root@example.com&amp;quot; &amp;amp;&amp;amp; \
    mkdir -p /opt/td-agent /var/cache/omnibus &amp;amp;&amp;amp; \
    bin/omnibus build td-agent2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config/projects/td-agent2.rb&lt;/code&gt;を書き換えているのは、ビルド時に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/lib/gems/2.3.0/gems/omnibus-5.5.0/lib/omnibus/licensing.rb:223:in `read&#39;: No such file or directory @ rb_sysopen - /tmp/omnibus-td-agent/https://raw.githubusercontent.com/treasure-data/omnibus-td-agent/master/LICENSE (Errno::ENOENT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなエラーが出たため。&lt;a href=&#34;https://github.com/chef/omnibus/blob/v5.5.0/lib/omnibus/licensing.rb#L223&#34;&gt;licensing.rb&lt;/a&gt;を見てみたところ、相対パスを想定しているようだった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;g++: internal compiler error: Killed (program cc1plus)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が出たらメモリが足りないかもしれない。&lt;/p&gt;

&lt;p&gt;ビルドが成功したらpkgにdebが出来ている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker cp &amp;lt;Container ID&amp;gt;:/tmp/omnibus-td-agent/pkg/td-agent_2.3.3-0_amd64.deb .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ dpkg -i td-agent_2.3.3-0_amd64.deb
$ td-agent --version
td-agent 0.14.8
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>d3.jsで折れ線グラフを書くコードを読む</title>
          <link>http://sambaiz.net/article/31/</link>
          <pubDate>Thu, 03 Nov 2016 00:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/31/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://bl.ocks.org/mbostock/3883245&#34;&gt;http://bl.ocks.org/mbostock/3883245&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CSSと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;

.axis--x path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;グラフを書くsvgとd3.js。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg width=&amp;quot;960&amp;quot; height=&amp;quot;500&amp;quot;&amp;gt;&amp;lt;/svg&amp;gt;
&amp;lt;script src=&amp;quot;https://d3js.org/d3.v4.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var svg = d3.select(&amp;quot;svg&amp;quot;),
    margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = +svg.attr(&amp;quot;width&amp;quot;) - margin.left - margin.right,
    height = +svg.attr(&amp;quot;height&amp;quot;) - margin.top - margin.bottom,
    g = svg.append(&amp;quot;g&amp;quot;).attr(&amp;quot;transform&amp;quot;, &amp;quot;translate(&amp;quot; + margin.left + &amp;quot;,&amp;quot; + margin.top + &amp;quot;)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;d3.select&lt;/code&gt;でsvg要素を選択。widthとheightを取得したり、中にg(グループ)を入れてtransformでmarginを作っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg width=&amp;quot;960&amp;quot; height=&amp;quot;500&amp;quot;&amp;gt;&amp;lt;g transform=&amp;quot;translate(50,20)&amp;quot;&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;svg.attr&lt;/code&gt;の前に+を付けるとnullの場合でも数値として扱える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; +null
0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var parseTime = d3.timeParse(&amp;quot;%d-%b-%y&amp;quot;);

var x = d3.scaleTime()
    .rangeRound([0, width]);

var y = d3.scaleLinear()
    .rangeRound([height, 0]);

var line = d3.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.close); });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;d3.scaleTime()&lt;/code&gt;や&lt;code&gt;d3.scaleLinear()&lt;/code&gt;は&lt;code&gt;domain&lt;/code&gt;で値域を指定し、&lt;code&gt;range&lt;/code&gt;の範囲にマッピングさせる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; d3.scaleLinear().rangeRound([0, 100]).domain([0, 66525])(33262)
50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;d3.line()&lt;/code&gt;で点を結ぶ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; d3.line()
  .x(function(d) { return d.a; })
  .y(function(d) { return d.b; })([{a: 10, b: 20},{a: 20, b:10}])
M10,20L20,10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;d3.tsv(&amp;quot;data.tsv&amp;quot;, function(d) {
  d.date = parseTime(d.date);
  d.close = +d.close;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(d3.extent(data, function(d) { return d.date; }));
  y.domain(d3.extent(data, function(d) { return d.close; }));

  g.append(&amp;quot;g&amp;quot;)
      .attr(&amp;quot;class&amp;quot;, &amp;quot;axis axis--x&amp;quot;)
      .attr(&amp;quot;transform&amp;quot;, &amp;quot;translate(0,&amp;quot; + height + &amp;quot;)&amp;quot;)
      .call(d3.axisBottom(x));

  g.append(&amp;quot;g&amp;quot;)
      .attr(&amp;quot;class&amp;quot;, &amp;quot;axis axis--y&amp;quot;)
      .call(d3.axisLeft(y))
    .append(&amp;quot;text&amp;quot;)
      .attr(&amp;quot;fill&amp;quot;, &amp;quot;#000&amp;quot;)
      .attr(&amp;quot;transform&amp;quot;, &amp;quot;rotate(-90)&amp;quot;)
      .attr(&amp;quot;y&amp;quot;, 6)
      .attr(&amp;quot;dy&amp;quot;, &amp;quot;0.71em&amp;quot;)
      .style(&amp;quot;text-anchor&amp;quot;, &amp;quot;end&amp;quot;)
      .text(&amp;quot;Price ($)&amp;quot;);

  g.append(&amp;quot;path&amp;quot;)
      .datum(data)
      .attr(&amp;quot;class&amp;quot;, &amp;quot;line&amp;quot;)
      .attr(&amp;quot;d&amp;quot;, line);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tsvを読んで加工した後、&lt;code&gt;d3.extent&lt;/code&gt;で[最小値, 最大値]の配列を作ってdomainに渡す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(d3.extent([4, 1, 2, 4, 9, 3], function(d){ return d }))
[1, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あと縦軸と横軸を書いてパスを書く。&lt;/p&gt;

&lt;p&gt;`&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>mp4をエンコードしてMPEG-DASHにして再生する</title>
          <link>http://sambaiz.net/article/30/</link>
          <pubDate>Sun, 30 Oct 2016 23:51:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/30/</guid>
          <description>

&lt;h2 id=&#34;mpeg-dashとは&#34;&gt;MPEG-DASHとは&lt;/h2&gt;

&lt;p&gt;HTTPで動画をストリーミングするための規格。似たようなのにAppleの独自規格であるHLSなどがある。&lt;/p&gt;

&lt;p&gt;サーバーはMPD(Media Presentation Description)ファイルと、セグメントに分けられた動画や音声ファイルを持っていて、
クライアントはMPDファイルをリクエストし、この内容をもとにセグメントをリクエストしていく。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ffmpeg.org/ffmpeg.html&#34;&gt;ffmpeg&lt;/a&gt;と
&lt;a href=&#34;https://gpac.wp.mines-telecom.fr/mp4box/&#34;&gt;MP4Box&lt;/a&gt;を使うので、これらを実行できるようにする。
Docker上で実行することもできて、その場合は以下のようにエイリアスを付けると便利。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ alias ffmpeg=&#39;docker run --rm -v `pwd`:/tmp/workdir jrottenberg/ffmpeg&#39;
$ alias MP4Box=&#39;docker run --rm -v `pwd`:/work sambaiz/mp4box&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;エンコード&#34;&gt;エンコード&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ffmpeg -i input.mp4 -vcodec libx264 -vb 448k -r 30 -x264opts no-scenecut -g 15 -acodec libfaac -ac 2 -ab 128k -frag_duration 5000000 -movflags empty_moov output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションの意味は多分こんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-vcodec libx264&lt;/code&gt;: 動画を&lt;a href=&#34;https://ja.wikipedia.org/wiki/H.264&#34;&gt;H.264&lt;/a&gt;にエンコードする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-vb 448k&lt;/code&gt;: 動画のビットレート(bps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r 30&lt;/code&gt;: 動画のフレームレート(fps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x264opts no-scenecut&lt;/code&gt;: キーフレームの間隔を動画の内容によらず固定にする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g 15&lt;/code&gt;: キープレームの間隔。フレームレート(&lt;code&gt;-r&lt;/code&gt;) * フラグメントの時間(&lt;code&gt;-frag_duration&lt;/code&gt;) / キーフレームの間隔(&lt;code&gt;-g&lt;/code&gt;)が整数になるようにする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-acodec libfaac&lt;/code&gt;: 音声を&lt;a href=&#34;https://ja.wikipedia.org/wiki/AAC&#34;&gt;AAC&lt;/a&gt;にエンコードする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ac 2&lt;/code&gt;: 音声チャンネル数2(ステレオ)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ab 128k&lt;/code&gt;: 音声のビットレート(bps)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-frag_duration 5000000&lt;/code&gt;: フラグメント(セグメント)の時間(μs)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-movflags empty_moov&lt;/code&gt;: 頭にmdat atom(データが含まれる)なしで、moov atom(メタ情報が含まれている)を書き始めるらしい。これがにしないとMP4Boxに入れるときに失敗した。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ MP4Box -info -v input.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
[iso file] Current top box start before parsing 0
[iso file] Read Box type ftyp size 24 start 0
[iso file] Current top box start before parsing 24
[iso file] Read Box type free size 8 start 24
[iso file] Current top box start before parsing 32
[iso file] Read Box type mdat size 5216803 start 32 &amp;lt;--
[iso file] Current top box start before parsing 5216835
[iso file] Read Box type moov size 13332 start 5216835 &amp;lt;--
...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ MP4Box -info -v output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[iso file] Current top box start before parsing 0
[iso file] Read Box type ftyp size 36 start 0
[iso file] Current top box start before parsing 36
[iso file] Read Box type moov size 1186 start 36 &amp;lt;--
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mpeg-dashにする&#34;&gt;MPEG-DASHにする&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ MP4Box -dash 5000 output.mp4
$ ls
input.mp4 output.mp4 output_dash.mpd output_dashinit.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-dash&lt;/code&gt;はセグメントの時間。ただ、このmpdだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と出てしまい再生できない。中を見てみると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Representation id=&amp;quot;1&amp;quot; mimeType=&amp;quot;video/mp4&amp;quot; codecs=&amp;quot;avc1.64000d,mp4a.40.2&amp;quot; width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; frameRate=&amp;quot;30&amp;quot; sar=&amp;quot;1:1&amp;quot; audioSamplingRate=&amp;quot;44100&amp;quot; startWithSAP=&amp;quot;1&amp;quot; bandwidth=&amp;quot;564201&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていて、動画と音声が一つのRepresentationになっているのがまずそうだったので、動画と音声を分けて実行した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ MP4Box -dash 5000 output.mp4#video output.mp4#audio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果、できたmpdがこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;!-- MPD file Generated with GPAC version 0.6.1-rev14-g8eb0297-master  at 2016-10-30T14:47:02.962Z--&amp;gt;
&amp;lt;MPD xmlns=&amp;quot;urn:mpeg:dash:schema:mpd:2011&amp;quot; minBufferTime=&amp;quot;PT1.500S&amp;quot; type=&amp;quot;static&amp;quot; mediaPresentationDuration=&amp;quot;PT0H0M21.545S&amp;quot; maxSegmentDuration=&amp;quot;PT0H0M10.000S&amp;quot; profiles=&amp;quot;urn:mpeg:dash:profile:full:2011&amp;quot;&amp;gt;
 &amp;lt;ProgramInformation moreInformationURL=&amp;quot;http://gpac.sourceforge.net&amp;quot;&amp;gt;
  &amp;lt;Title&amp;gt;output_dash.mpd generated by GPAC&amp;lt;/Title&amp;gt;
 &amp;lt;/ProgramInformation&amp;gt;

 &amp;lt;Period duration=&amp;quot;PT0H0M21.545S&amp;quot;&amp;gt;
  &amp;lt;AdaptationSet segmentAlignment=&amp;quot;true&amp;quot; maxWidth=&amp;quot;320&amp;quot; maxHeight=&amp;quot;240&amp;quot; maxFrameRate=&amp;quot;30&amp;quot; par=&amp;quot;4:3&amp;quot; lang=&amp;quot;eng&amp;quot;&amp;gt;
   &amp;lt;Representation id=&amp;quot;1&amp;quot; mimeType=&amp;quot;video/mp4&amp;quot; codecs=&amp;quot;avc3.64000d&amp;quot; width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; frameRate=&amp;quot;30&amp;quot; sar=&amp;quot;1:1&amp;quot; startWithSAP=&amp;quot;1&amp;quot; bandwidth=&amp;quot;437781&amp;quot;&amp;gt;
    &amp;lt;BaseURL&amp;gt;output_track1_dashinit.mp4&amp;lt;/BaseURL&amp;gt;
    &amp;lt;SegmentList timescale=&amp;quot;15360&amp;quot; duration=&amp;quot;153600&amp;quot;&amp;gt;
     &amp;lt;Initialization range=&amp;quot;0-1128&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;1129-556172&amp;quot; indexRange=&amp;quot;1129-1172&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;556173-1134265&amp;quot; indexRange=&amp;quot;556173-556216&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;1134266-1172888&amp;quot; indexRange=&amp;quot;1134266-1134309&amp;quot;/&amp;gt;
    &amp;lt;/SegmentList&amp;gt;
   &amp;lt;/Representation&amp;gt;
  &amp;lt;/AdaptationSet&amp;gt;
  &amp;lt;AdaptationSet segmentAlignment=&amp;quot;true&amp;quot; lang=&amp;quot;eng&amp;quot;&amp;gt;
   &amp;lt;Representation id=&amp;quot;2&amp;quot; mimeType=&amp;quot;audio/mp4&amp;quot; codecs=&amp;quot;mp4a.40.2&amp;quot; audioSamplingRate=&amp;quot;44100&amp;quot; startWithSAP=&amp;quot;1&amp;quot; bandwidth=&amp;quot;129622&amp;quot;&amp;gt;
    &amp;lt;AudioChannelConfiguration schemeIdUri=&amp;quot;urn:mpeg:dash:23003:3:audio_channel_configuration:2011&amp;quot; value=&amp;quot;2&amp;quot;/&amp;gt;
    &amp;lt;BaseURL&amp;gt;output_track2_dashinit.mp4&amp;lt;/BaseURL&amp;gt;
    &amp;lt;SegmentList timescale=&amp;quot;44100&amp;quot; duration=&amp;quot;441000&amp;quot;&amp;gt;
     &amp;lt;Initialization range=&amp;quot;0-1060&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;1061-163674&amp;quot; indexRange=&amp;quot;1061-1104&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;163675-326023&amp;quot; indexRange=&amp;quot;163675-163718&amp;quot;/&amp;gt;
      &amp;lt;SegmentURL mediaRange=&amp;quot;326024-349091&amp;quot; indexRange=&amp;quot;326024-326067&amp;quot;/&amp;gt;
    &amp;lt;/SegmentList&amp;gt;
   &amp;lt;/Representation&amp;gt;
  &amp;lt;/AdaptationSet&amp;gt;
 &amp;lt;/Period&amp;gt;
&amp;lt;/MPD&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;再生する&#34;&gt;再生する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Dash-Industry-Forum/dash.js&#34;&gt;dash.js&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
     &amp;lt;script src=&amp;quot;http://cdn.dashjs.org/latest/dash.all.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
     &amp;lt;style&amp;gt;
         video {
             width: 640px;
             height: 360px;
          }
     &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
     &amp;lt;div&amp;gt;
         &amp;lt;video data-dashjs-player autoplay src=&amp;quot;http://localhost:8080/output_dash.mpd&amp;quot; controls&amp;gt;&amp;lt;/video&amp;gt;
     &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルでサーバーを立ち上げる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var static = require(&#39;node-static&#39;);

var fileServer = new static.Server(&#39;./public&#39;);

require(&#39;http&#39;).createServer(function (request, response) {
    request.addListener(&#39;end&#39;, function () {
        fileServer.serve(request, response);
    }).resume();
}).listen(8080);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jstage.jst.go.jp/article/itej/67/2/67_109/_pdf&#34;&gt;次世代動画配信技術「MPEG-DASH」技術概要と標準化・関連技術動向&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/tomoyukilabs/items/c4eb7a829baac880797c&#34;&gt;FFmpegでHTML5 readyな動画ファイルを作成 (MP4, WebM) - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yebisupress.dac.co.jp/2015/11/04/profile%EF%BC%9Fatom%EF%BC%9Fmp4%E3%81%AE%E3%82%88%E3%81%8F%E3%82%8F%E3%81%8B%E3%82%89%E3%81%AA%E3%81%84%E3%81%82%E3%82%8C%E3%81%93%E3%82%8C%EF%BC%88atom%E7%B7%A8/&#34;&gt;profile？atom？mp4のよくわからないあれこれ（atom編)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>剣を振るVRゲームを作った</title>
          <link>http://sambaiz.net/article/29/</link>
          <pubDate>Sun, 30 Oct 2016 19:05:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/29/</guid>
          <description>

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_game.png&#34; alt=&#34;ゲーム画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Tlonh7D5UzY&#34;&gt;プレイ動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vr.google.com/intl/ja_jp/cardboard/&#34;&gt;Cardboard&lt;/a&gt;にAndroidを入れて、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_card.jpg&#34; alt=&#34;Cardboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;iPhoneをくくりつけた傘を動かすと、画面の剣も動くのでこれで敵を倒すゲーム。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_sword.jpg&#34; alt=&#34;iPhoneをくくりつけた傘&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;h3 id=&#34;剣-ios&#34;&gt;剣(iOS)&lt;/h3&gt;

&lt;p&gt;剣にくくりつけたiPhoneの傾きの値をUnity(Android)に送信している。
iOSはClassic Bluetoothを自由に使えないので、Androidと通信する場合はBLEを使う。
BLEは通常だと20byteしか一度に送れないので、これを超えないよう注意する必要がある。&lt;/p&gt;

&lt;p&gt;BLEで通信するところは&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/26&#34;&gt;iOS端末をBLEのPeripheralにする&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で作ったので、端末の傾きを取得して送るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import CoreMotion

class Motion{

    let peripheral: BLEPeripheral
    let accelHandler:CMDeviceMotionHandler
    let manager = CMMotionManager()

    public init(peripheral :BLEPeripheral, label :UILabel){
        self.peripheral = peripheral

        accelHandler = {
            (data: CMDeviceMotion?, error: Error?) -&amp;gt; Void in
            let str = String(format: &amp;quot;%.1f %.1f %.1f&amp;quot;,
                             arguments: [data!.attitude.pitch * 180 / M_PI,
                                         data!.attitude.roll * 180 / M_PI,
                                         data!.attitude.yaw * 180 / M_PI]
                )
            let res = peripheral.update(str.data(using: String.Encoding.utf8))
            label.text = str + &amp;quot; &amp;quot; + String(res)
        }
    }

    func start(){
        if manager.isDeviceMotionAvailable {
            manager.deviceMotionUpdateInterval = 1 / 12;
            manager.startDeviceMotionUpdates(to: OperationQueue.current!, withHandler: accelHandler)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ゲーム-unity-android&#34;&gt;ゲーム(Unity &amp;amp; Android)&lt;/h3&gt;

&lt;p&gt;オライリーから&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873117577/&#34;&gt;UnityによるVRアプリケーション開発――作りながら学ぶバーチャルリアリティ入門&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;という本が出ていたので買った。Unityの初歩的なところやBlenderとかも説明があるのでおすすめ。
とりあえず&lt;a href=&#34;https://developers.google.com/vr/unity/&#34;&gt;GoogleのSDK&lt;/a&gt;をimportして、
Prefabの&lt;code&gt;GvrViewerMain&lt;/code&gt;を置くと二眼のそれっぽい感じになる。&lt;/p&gt;

&lt;p&gt;スコアとかゲームオーバーの状態と処理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class Game : MonoBehaviour {

	public static int score = 0;
	public static bool gameOver = false;
	public static bool killed = false;

	public Text gameOverText;
	public Text scoreText;
	public GameObject enemy;

	void Start () {
		gameOverText.enabled = false;
	}

	void Update () {
		scoreText.text = &amp;quot;Score: &amp;quot; + score;
		if (gameOver) gameOverText.enabled = true;
		if (killed) {
			nextLevel ();
			killed = false;
		}
	}

	public void nextLevel(){
		var old = enemy;
		var x = Random.Range (-10, 10);
		enemy = (GameObject) Instantiate (
			enemy, new Vector3(x, 0, Mathf.Sqrt(10 * 10 - x * x)), Quaternion.Euler(0, 0, 0));
		Destroy (old);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵の当たり判定。剣に当たったら爆発して次のが出てくる。
体(見えないCapsule Colliderを設定している)に当たるとゲームオーバー。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class MonsterHit : MonoBehaviour {

	public GameObject killEffect;

	void OnCollisionEnter(Collision collision) {
		switch (collision.gameObject.name) {
		case &amp;quot;sword&amp;quot;:
			if (!Game.gameOver) {
				Game.score += 1;
				Instantiate (killEffect, transform.position, transform.rotation);
				Game.killed = true;
			}
			break;

		case &amp;quot;Body&amp;quot;:
			Game.gameOver = true;
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵を動かす。スコアが上がるとスピードも上がる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class MonsterMove : MonoBehaviour {

	private float moveRate;

	void Start () {
		moveRate = 0.0f;
	}

	void Update () {
		transform.position = Vector3.Lerp (transform.position, new Vector3 (0, 0, -1.5f), moveRate);
		moveRate += 0.0001f * (Game.score + 1);
		transform.LookAt (new Vector3 (0, 0, -1.5f));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;センサーの値を受け取って、剣を動かす。ここで使っているネイティブライブラリは前作ったもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/27&#34;&gt;UnityでAndroidのBLEを使うネイティブプラグインを作る&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class SwordMotion : MonoBehaviour {

	private AndroidJavaObject ble;
	private Quaternion q;

	void Start () {
		ble = new AndroidJavaObject (&amp;quot;net.sambaiz.unity_ble.BLE&amp;quot;, this.gameObject.name, &amp;quot;received&amp;quot;);
		q = Quaternion.Euler (0, 0, 0);
	}

	void Update () {
		transform.rotation = q;
	}

	void received(string message){
		var motionData = message.Split (&#39; &#39;); // pitch roll yaw
		q = Quaternion.Euler (
				90 - float.Parse (motionData [0]),
				float.Parse (motionData [1]),
				0) ;
	}

	void OnApplicationPause (bool pauseStatus)
	{
		if (ble != null) {
			if (pauseStatus) {
				ble.Call (&amp;quot;onPause&amp;quot;);
			} else {
				ble.Call (&amp;quot;onActive&amp;quot;);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>gcloudのアカウント切り替えとkubectlのcontext変更</title>
          <link>http://sambaiz.net/article/28/</link>
          <pubDate>Tue, 25 Oct 2016 20:29:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/28/</guid>
          <description>

&lt;p&gt;いつも迷うのでまとめた。&lt;/p&gt;

&lt;h2 id=&#34;gcloudのアカウント一覧と切り替え&#34;&gt;gcloudのアカウント一覧と切り替え&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ gcloud auth list
$ gcloud config set account `ACCOUNT`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kubectlのcontext変更&#34;&gt;kubectlのcontext変更&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl config current-context
$ kubectl config view # contexts
$ kubectl config use-context minikube
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityでAndroidのBLEを使うネイティブプラグインを作る</title>
          <link>http://sambaiz.net/article/27/</link>
          <pubDate>Sun, 23 Oct 2016 20:39:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/27/</guid>
          <description>

&lt;p&gt;UnityからBLEを使うためのネイティブプラグインを作る。&lt;/p&gt;

&lt;h2 id=&#34;android側&#34;&gt;Android側&lt;/h2&gt;

&lt;p&gt;まず、Activityなしのプロジェクトを作って、New ModuleからAndroid Libraryを選択。
これらのパッケージ名がUnityで使うものと被らないようにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes/classes.jar&lt;/code&gt;
をModuleの方のlibsに置く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import com.unity3d.player.UnityPlayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このjarは元々のやつとかぶってしまうので除外(build.gradleに追加)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.libraryVariants.all { variant -&amp;gt;
    variant.outputs.each { output -&amp;gt;
        output.packageLibrary.exclude(&#39;libs/classes.jar&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activiyは&lt;code&gt;UnityPlayer.currentActivity&lt;/code&gt;で取得でき、
Unity側のメソッドを呼ぶのも
&lt;code&gt;UnityPlayer.UnitySendMessage(mGameObjName, mCallBackName, new String(characteristic.getValue()));&lt;/code&gt;
のようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BLE {

    private final static String TAG = BLE.class.getSimpleName();
    private static final int REQUEST_ENABLE_BT = 1;
    private static final int MY_PERMISSION_RESPONSE = 2;

    private static final String PERIPHERAL_LOCAL_NAME = &amp;quot;my-ble&amp;quot;;
    private static final UUID PERIPHERAL_SERIVCE_UUID = UUID.fromString(&amp;quot;BF9CB85F-620C-4A67-BDD2-1A64213F74CA&amp;quot;);
    private static final UUID PERIPHERAL_CHARACTERISTIC_UUID = UUID.fromString(&amp;quot;5F83E23F-BCA1-42B3-B6F2-EA82BE46A93D&amp;quot;);
    private static final UUID CLIENT_CHARACTERISTIC_CONFIG = UUID.fromString(&amp;quot;00002902-0000-1000-8000-00805f9b34fb&amp;quot;);

    private String mGameObjName;
    private String mCallBackName;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothGattCharacteristic mCharacteristic;
    private Handler mHandler;

    // Stops scanning after 30 seconds.
    private static final long SCAN_PERIOD = 30000;

    public BLE(String gameObjName, String callBackName) {

        this.mGameObjName = gameObjName;
        this.mCallBackName = callBackName;

        mHandler = new Handler();

        if (!UnityPlayer.currentActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
            Toast.makeText(UnityPlayer.currentActivity, &amp;quot;BLEをサポートしていません&amp;quot;, Toast.LENGTH_SHORT).show();
            UnityPlayer.currentActivity.finish();
            return;
        }

        final BluetoothManager bluetoothManager =
                (BluetoothManager) UnityPlayer.currentActivity.getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = bluetoothManager.getAdapter();

        if (mBluetoothAdapter == null) {
            Toast.makeText(UnityPlayer.currentActivity, &amp;quot;Bluetoothをサポートしていません&amp;quot;, Toast.LENGTH_SHORT).show();
            UnityPlayer.currentActivity.finish();
            return;
        }

        onActive();
    }

    public void onActive() {
        Log.d(TAG, &amp;quot;onActive&amp;quot;);
        if (!mBluetoothAdapter.isEnabled()) {
            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            UnityPlayer.currentActivity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
        }

        scanLeDevice(true);
    }

    public void onPause() {
        Log.d(TAG, &amp;quot;onPause&amp;quot;);
        scanLeDevice(false);

        if(mCharacteristic != null){
            mBluetoothGatt.setCharacteristicNotification(
                    mCharacteristic,
                    false
            );
        }

        if(mBluetoothGatt != null) {
            mBluetoothGatt.close();
            mBluetoothGatt = null;
        }
    }

    private void scanLeDevice(final boolean enable) {
        if (enable) {
            mHandler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    mBluetoothAdapter.stopLeScan(mLeScanCallback);
                }
            }, SCAN_PERIOD);

            mBluetoothAdapter.startLeScan(mLeScanCallback);
        } else {
            mBluetoothAdapter.stopLeScan(mLeScanCallback);
        }
    }

    private BluetoothAdapter.LeScanCallback mLeScanCallback =
            new BluetoothAdapter.LeScanCallback() {

                @Override
                public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {
                    if(PERIPHERAL_LOCAL_NAME.equals(device.getName())){
                        scanLeDevice(false);
                        connect(device);
                    }
                }
            };

    private boolean connect(BluetoothDevice device) {
        if (mBluetoothAdapter == null) {
            Log.w(TAG, &amp;quot;BluetoothAdapter not initialized or unspecified address.&amp;quot;);
            return false;
        }

        // Previously connected device.  Try to reconnect.
        if (mBluetoothGatt != null) {
            Log.d(TAG, &amp;quot;Trying to use an existing mBluetoothGatt for connection.&amp;quot;);
            if (mBluetoothGatt.connect()) {
                return true;
            } else {
                return false;
            }
        }

        mBluetoothGatt = device.connectGatt(UnityPlayer.currentActivity, false, mGattCallback);
        Log.d(TAG, &amp;quot;Trying to create a new connection.&amp;quot;);
        return true;
    }


    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (newState == BluetoothProfile.STATE_CONNECTED) {

                scanLeDevice(false);
                Log.i(TAG, &amp;quot;Connected to GATT server.&amp;quot;);
                gatt.discoverServices();

            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                Log.i(TAG, &amp;quot;Disconnected from GATT server.&amp;quot;);
            } else{
                Log.i(TAG, &amp;quot;onConnectionStateChange:&amp;quot; + newState);
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                mCharacteristic = gatt.getService(PERIPHERAL_SERIVCE_UUID).
                        getCharacteristic(PERIPHERAL_CHARACTERISTIC_UUID);

                gatt.setCharacteristicNotification(
                        mCharacteristic,
                        true
                );
                BluetoothGattDescriptor descriptor = mCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
                descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                mBluetoothGatt.writeDescriptor(descriptor);
            } else {
                Log.w(TAG, &amp;quot;onServicesDiscovered received: &amp;quot; + status);
            }
        }

        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt,
                                            BluetoothGattCharacteristic characteristic) {
            UnityPlayer.UnitySendMessage(mGameObjName, mCallBackName, new String(characteristic.getValue()));
        }
    };

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manifestに追加した分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-feature android:name=&amp;quot;android.hardware.bluetooth_le&amp;quot; android:required=&amp;quot;true&amp;quot;/&amp;gt;

&amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH_ADMIN&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_COARSE_LOCATION&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できたらaarを生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gradlew assembleRelease
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build/outputs/aar/*-release.aar&lt;/code&gt;をUnityの&lt;code&gt;Assets/Plugins/Android/libs&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;あと、依存aarはこの中に含まれないようなのでそれもまとめてコピーする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;task copyLibs(type: Copy) {
    from configurations.compile
    into &#39;build/outputs/aar&#39;
    exclude { details -&amp;gt; details.file.name.endsWith(&amp;quot;.jar&amp;quot;) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manifetstのmergeに失敗したのでSDKVersionを合わせる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compileSdkVersion 22

defaultConfig {
    minSdkVersion 19
    targetSdkVersion 22
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unity側&#34;&gt;Unity側&lt;/h2&gt;

&lt;p&gt;こんな感じでインスタンスを作り、
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/AndroidJavaObject.Call.html&#34;&gt;メソッドを呼べる&lt;/a&gt;。
ただし、unity editor上では&lt;code&gt;Init&#39;d AndroidJavaClass with null ptr!&lt;/code&gt;のエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugin = new AndroidJavaObject(&amp;quot;net.sambaiz.unity_ble.BLE&amp;quot;, this.gameObject.name, &amp;quot;received&amp;quot;);

void received(string message){
	Debug.Log (&amp;quot;BLE:&amp;quot; + message);
}

void OnApplicationPause (bool pauseStatus)
{
	if (pauseStatus) {
		plugin.Call (&amp;quot;onPause&amp;quot;);
	} else {
		plugin.Call (&amp;quot;onActive&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>iOS端末をBLEのPeripheralにする</title>
          <link>http://sambaiz.net/article/26/</link>
          <pubDate>Sun, 23 Oct 2016 01:29:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/26/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/jp/documentation/CoreBluetoothPG.pdf&#34;&gt;CoreBluetoothプログラミングガイド&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;流れ&#34;&gt;流れ&lt;/h2&gt;

&lt;p&gt;まず、CoreBluetooth.frameworkを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import CoreBluetooth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CBPeripheralManagerを生成。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peripheralManager = CBPeripheralManager(delegate: self, queue: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stateが変化したらdelegateメソッドが呼ばれるので&lt;code&gt;.poweredOn&lt;/code&gt;であることを確認できれば
Managerの準備は完了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager){        
    switch (peripheral.state){
    case .poweredOn:
        print(&amp;quot;PeripheralManager state is ok&amp;quot;)
        ready = true

    default:
        print(&amp;quot;PeripheralManager state is ng:&amp;quot;, peripheral.state)
        ready = false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Characteristicを作成。&lt;code&gt;CBCharacteristicProperties.read.union(CBCharacteristicProperties.notify)&lt;/code&gt;で、
Centralが読みにくることも、通知を受け取ることもできるようにし、&lt;code&gt;CBAttributePermissions.readable&lt;/code&gt;でreadのみ許可する。
このvalueをnilにしておかないと、キャッシュされあとで変更できなくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;characteristic = CBMutableCharacteristic(
    type: CHARACTERISTIC_UUID,
    properties: CBCharacteristicProperties.read.union(CBCharacteristicProperties.notify),
    value:nil,
    permissions:CBAttributePermissions.readable)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このCharacteristicのServiceを作成し、Managerに登録する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let service = CBMutableService(type: SERVICE_UUID, primary: true)
service.characteristics = [characteristic]
peripheralManager!.add(service)
ready = true         
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?){
    if(error != nil){
        print(&amp;quot;Add Service error:&amp;quot;, error)
    }else{
        print(&amp;quot;Add Service ok&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServiceをAdvertiseする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peripheral.startAdvertising([
    CBAdvertisementDataLocalNameKey: LOCAL_NAME,
    CBAdvertisementDataServiceUUIDsKey: [SERVICE_UUID]
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?){
    if(error != nil){
        print(&amp;quot;Start Advertising error:&amp;quot;, error)
    }else{
        print(&amp;quot;Start Advertising ok&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通知要求してきたCentralに向けて通知する。&lt;code&gt;onSubscribedCentrals: nil&lt;/code&gt;で全てのCentralに送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peripheralManager!.updateValue(d, for: characteristic, onSubscribedCentrals: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;読みにきたときのdelegateメソッド。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest){
    if (request.characteristic.uuid.isEqual(self.characteristic.uuid)) {
        if let value = self.characteristic.value{
            if (request.offset &amp;gt; value.count) {
                peripheral.respond(to: request, withResult: CBATTError.invalidOffset)
                print(&amp;quot;Read fail: invalid offset&amp;quot;)
                return;
            }
        }

        request.value = self.characteristic.value?.subdata(
            in: Range(uncheckedBounds: (request.offset, (self.characteristic.value?.count)! - request.offset))
        )
        peripheral.respond(to: request, withResult: CBATTError.success)
        print(&amp;quot;Read success&amp;quot;)
    }else{
        print(&amp;quot;Read fail: wrong characteristic uuid:&amp;quot;, request.characteristic.uuid)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;全体&#34;&gt;全体&lt;/h2&gt;

&lt;p&gt;エラーハンドリングは適当だけど、とりあえず動くものができた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import CoreBluetooth

class BLEPeripheral : NSObject, CBPeripheralManagerDelegate {

    let CHARACTERISTIC_UUID = CBUUID(string:&amp;quot;5F83E23F-BCA1-42B3-B6F2-EA82BE46A93D&amp;quot;)
    let SERVICE_UUID = CBUUID(string:&amp;quot;BF9CB85F-620C-4A67-BDD2-1A64213F74CA&amp;quot;)
    let LOCAL_NAME = &amp;quot;my-ble&amp;quot;

    private var peripheralManager : CBPeripheralManager?
    private var characteristic: CBMutableCharacteristic
    private var ready = false

    public override init(){
        characteristic = CBMutableCharacteristic(
            type: CHARACTERISTIC_UUID,
            properties: CBCharacteristicProperties.read.union(CBCharacteristicProperties.notify),
            value:nil,
            permissions:CBAttributePermissions.readable)

        super.init()

        peripheralManager = CBPeripheralManager(delegate: self, queue: nil)
    }

    public func update(_ data: Data?) -&amp;gt; Bool {
        if(ready){
            if let d = data{
                characteristic.value = d
                return peripheralManager!.updateValue(d, for: characteristic, onSubscribedCentrals: nil)
            }else{
                print(&amp;quot;data is null&amp;quot;)
            }
        }else{
            print(&amp;quot;not ready&amp;quot;)
        }
        return false
    }



    /*
     CBPeripheralManagerDelegate
    */

    public func peripheralManagerDidUpdateState(_ peripheral: CBPeripheralManager){        
        switch (peripheral.state){
        case .poweredOn:
            print(&amp;quot;PeripheralManager state is ok&amp;quot;)

            let service = CBMutableService(type: SERVICE_UUID, primary: true)
            service.characteristics = [characteristic]
            peripheralManager!.add(service)
            ready = true

        default:
            print(&amp;quot;PeripheralManager state is ng:&amp;quot;, peripheral.state)
            ready = false
        }
    }

    public func peripheralManager(_ peripheral: CBPeripheralManager, didAdd service: CBService, error: Error?){
        if(error != nil){
            print(&amp;quot;Add Service error:&amp;quot;, error)
        }else{
            print(&amp;quot;Add Service ok&amp;quot;)
            peripheral.startAdvertising([
                CBAdvertisementDataLocalNameKey: LOCAL_NAME,
                CBAdvertisementDataServiceUUIDsKey: [SERVICE_UUID]
                ])
        }
    }

    public func peripheralManagerDidStartAdvertising(_ peripheral: CBPeripheralManager, error: Error?){
        if(error != nil){
            print(&amp;quot;Start Advertising error:&amp;quot;, error)
        }else{
            print(&amp;quot;Start Advertising ok&amp;quot;)
        }
    }

    public func peripheralManager(_ peripheral: CBPeripheralManager, didReceiveRead request: CBATTRequest){
        var value: Data?
        switch request.characteristic.uuid {
        case characteristic.uuid:
            value = characteristic.value

        default: break
        }

        if let v = value{
            if (request.offset &amp;gt; v.count) {
                peripheral.respond(to: request, withResult: CBATTError.invalidOffset)
                print(&amp;quot;Read fail: invalid offset&amp;quot;)
                return;
            }

            request.value = v.subdata(
                in: Range(uncheckedBounds: (request.offset, v.count - request.offset))
            )
            peripheral.respond(to: request, withResult: CBATTError.success)
            print(&amp;quot;Read success&amp;quot;)
        }else{
            print(&amp;quot;Read fail: wrong characteristic uuid:&amp;quot;, request.characteristic.uuid)
        }
    }

    public func peripheralManager(_ peripheral: CBPeripheralManager, central: CBCentral, didSubscribeTo characteristic: CBCharacteristic){
        print(&amp;quot;Subscribe to&amp;quot;, characteristic.uuid)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在の時間を1秒ごとに更新して通知がくることを確認した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(self.update), userInfo: nil, repeats: true)
timer!.fire()

public func update(){
    let now = String(format: &amp;quot;%.0f&amp;quot;, arguments: [Date().timeIntervalSince1970])
    peripheral.update(now.data(using: String.Encoding.utf8))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>android-BluetoothLeGattを読む</title>
          <link>http://sambaiz.net/article/25/</link>
          <pubDate>Fri, 21 Oct 2016 14:10:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/25/</guid>
          <description>

&lt;p&gt;BLEのサンプルコード。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/googlesamples/android-BluetoothLeGatt&#34;&gt;https://github.com/googlesamples/android-BluetoothLeGatt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;devicescanactivity&#34;&gt;DeviceScanActivity&lt;/h2&gt;

&lt;p&gt;BLEをサポートしているかチェックする。
&lt;a href=&#34;http://sambaiz.net/article/23&#34;&gt;BluetoothChat&lt;/a&gt;ではBluetoothAdapterを取得するのに
&lt;code&gt;BluetoothAdapter.getDefaultAdapter()&lt;/code&gt;のようにしていたが、
BLEをサポートしているような新しいバージョンでは、BluetoothManagerの&lt;code&gt;getAdapter()&lt;/code&gt;を使うらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getActionBar().setTitle(R.string.title_devices);
    mHandler = new Handler();

    // Use this check to determine whether BLE is supported on the device.  Then you can
    // selectively disable BLE-related features.
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
        Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
        finish();
    }

    // Initializes a Bluetooth adapter.  For API level 18 and above, get a reference to
    // BluetoothAdapter through BluetoothManager.
    final BluetoothManager bluetoothManager =
            (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
    mBluetoothAdapter = bluetoothManager.getAdapter();

    // Checks if Bluetooth is supported on the device.
    if (mBluetoothAdapter == null) {
        Toast.makeText(this, R.string.error_bluetooth_not_supported, Toast.LENGTH_SHORT).show();
        finish();
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BluetoothChatと同様にBluetoothを有効にさせるのと、scanの開始。
&lt;code&gt;mBluetoothAdapter.startLeScan(mLeScanCallback)&lt;/code&gt;で
見つかったらcallbackの&lt;code&gt;onLeScan&lt;/code&gt;が呼ばれるのでデバイスリストに追加していく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onResume() {
    super.onResume();

    // Ensures Bluetooth is enabled on the device.  If Bluetooth is not currently enabled,
    // fire an intent to display a dialog asking the user to grant permission to enable it.
    if (!mBluetoothAdapter.isEnabled()) {
        if (!mBluetoothAdapter.isEnabled()) {
            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
        }
    }

    // Initializes list view adapter.
    mLeDeviceListAdapter = new LeDeviceListAdapter();
    setListAdapter(mLeDeviceListAdapter);
    scanLeDevice(true);
}

private void scanLeDevice(final boolean enable) {
    if (enable) {
        // Stops scanning after a pre-defined scan period.
        mHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                mScanning = false;
                mBluetoothAdapter.stopLeScan(mLeScanCallback);
                invalidateOptionsMenu();
            }
        }, SCAN_PERIOD);

        mScanning = true;
        mBluetoothAdapter.startLeScan(mLeScanCallback);
    } else {
        mScanning = false;
        mBluetoothAdapter.stopLeScan(mLeScanCallback);
    }
    invalidateOptionsMenu();
}

private BluetoothAdapter.LeScanCallback mLeScanCallback =
            new BluetoothAdapter.LeScanCallback() {
    @Override
    public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mLeDeviceListAdapter.addDevice(device);
                mLeDeviceListAdapter.notifyDataSetChanged();
            }
        });
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pause時はscanを止め、Listをクリアする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onPause() {
    super.onPause();
    scanLeDevice(false);
    mLeDeviceListAdapter.clear();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リストが選択されたら、scanを止め、そのデバイスの情報を渡してDeviceControlActivityを始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onListItemClick(ListView l, View v, int position, long id) {
    final BluetoothDevice device = mLeDeviceListAdapter.getDevice(position);
    if (device == null) return;
    final Intent intent = new Intent(this, DeviceControlActivity.class);
    intent.putExtra(DeviceControlActivity.EXTRAS_DEVICE_NAME, device.getName());
    intent.putExtra(DeviceControlActivity.EXTRAS_DEVICE_ADDRESS, device.getAddress());
    if (mScanning) {
        mBluetoothAdapter.stopLeScan(mLeScanCallback);
        mScanning = false;
    }
    startActivity(intent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;devicecontrolactivity&#34;&gt;DeviceControlActivity&lt;/h2&gt;

&lt;p&gt;bindServiceでBluetoothLeServiceにServiceConnectionをバインドする。
Serviceと接続したらServiceConnectionの&lt;code&gt;onServiceConnected&lt;/code&gt;が呼ばれるので、
LocalBinderの&lt;code&gt;getService&lt;/code&gt;で取得し、初期化して対象のデバイスにconnectする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/guide/components/services.html?hl=ja&#34;&gt;Service&lt;/a&gt;は、
開始したコンポーネントや、ユーザーの操作に関係なく、バックグラウンドで動く。
サーバー/クライアントでいうサーバーで、複数のクライアントが同時にバインドでき、
その場合バインドしているクライアントが存在しなくなったら破棄される。
ホストプロセスのメインスレッドで実行される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.gatt_services_characteristics);

    final Intent intent = getIntent();
    mDeviceName = intent.getStringExtra(EXTRAS_DEVICE_NAME);
    mDeviceAddress = intent.getStringExtra(EXTRAS_DEVICE_ADDRESS);

    // Sets up UI references.
    ((TextView) findViewById(R.id.device_address)).setText(mDeviceAddress);
    mGattServicesList = (ExpandableListView) findViewById(R.id.gatt_services_list);
    mGattServicesList.setOnChildClickListener(servicesListClickListner);
    mConnectionState = (TextView) findViewById(R.id.connection_state);
    mDataField = (TextView) findViewById(R.id.data_value);

    getActionBar().setTitle(mDeviceName);
    getActionBar().setDisplayHomeAsUpEnabled(true);
    Intent gattServiceIntent = new Intent(this, BluetoothLeService.class);
    bindService(gattServiceIntent, mServiceConnection, BIND_AUTO_CREATE);
}

private final ServiceConnection mServiceConnection = new ServiceConnection() {

    @Override
    public void onServiceConnected(ComponentName componentName, IBinder service) {
        mBluetoothLeService = ((BluetoothLeService.LocalBinder) service).getService();
        if (!mBluetoothLeService.initialize()) {
            Log.e(TAG, &amp;quot;Unable to initialize Bluetooth&amp;quot;);
            finish();
        }
        // Automatically connects to the device upon successful start-up initialization.
        mBluetoothLeService.connect(mDeviceAddress);
    }

    @Override
    public void onServiceDisconnected(ComponentName componentName) {
        mBluetoothLeService = null;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BroadcastReceiverを登録して、対象デバイスに繋ぎに行く。
GATTのService(AndroidのServiceとは違うもの)やCharacteristicが見つかったら表示する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.bluetooth.com/specifications/gatt&#34;&gt;GATT(Generic Attribute Profile)&lt;/a&gt;
というのは、BLEで通信するときに使う階層化されたデータ構造の定義。
ProfileにはいくつかのServiceが含まれ、ServiceにはいくつかのCharacteristic、または他のServiceが含まれる。
Characteristicというのが値。ServiceやCharacteristicはUUIDで識別することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onResume() {
    super.onResume();
    registerReceiver(mGattUpdateReceiver, makeGattUpdateIntentFilter());
    if (mBluetoothLeService != null) {
        final boolean result = mBluetoothLeService.connect(mDeviceAddress);
        Log.d(TAG, &amp;quot;Connect request result=&amp;quot; + result);
    }
}

private final BroadcastReceiver mGattUpdateReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        final String action = intent.getAction();
        if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) {
            mConnected = true;
            updateConnectionState(R.string.connected);
            invalidateOptionsMenu();
        } else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) {
            mConnected = false;
            updateConnectionState(R.string.disconnected);
            invalidateOptionsMenu();
            clearUI();
        } else if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
            // Show all the supported services and characteristics on the user interface.
            displayGattServices(mBluetoothLeService.getSupportedGattServices());
        } else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) {
            displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA));
        }
    }
};

private static IntentFilter makeGattUpdateIntentFilter() {
    final IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(BluetoothLeService.ACTION_GATT_CONNECTED);
    intentFilter.addAction(BluetoothLeService.ACTION_GATT_DISCONNECTED);
    intentFilter.addAction(BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED);
    intentFilter.addAction(BluetoothLeService.ACTION_DATA_AVAILABLE);
    return intentFilter;
}

private void displayGattServices(List&amp;lt;BluetoothGattService&amp;gt; gattServices) {
    if (gattServices == null) return;
    String uuid = null;
    String unknownServiceString = getResources().getString(R.string.unknown_service);
    String unknownCharaString = getResources().getString(R.string.unknown_characteristic);
    ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt; gattServiceData = new ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;();
    ArrayList&amp;lt;ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;&amp;gt; gattCharacteristicData
            = new ArrayList&amp;lt;ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;&amp;gt;();
    mGattCharacteristics = new ArrayList&amp;lt;ArrayList&amp;lt;BluetoothGattCharacteristic&amp;gt;&amp;gt;();

    // Loops through available GATT Services.
    for (BluetoothGattService gattService : gattServices) {
        HashMap&amp;lt;String, String&amp;gt; currentServiceData = new HashMap&amp;lt;String, String&amp;gt;();
        uuid = gattService.getUuid().toString();
        currentServiceData.put(
                LIST_NAME, SampleGattAttributes.lookup(uuid, unknownServiceString));
        currentServiceData.put(LIST_UUID, uuid);
        gattServiceData.add(currentServiceData);

        ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt; gattCharacteristicGroupData =
                new ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;();
        List&amp;lt;BluetoothGattCharacteristic&amp;gt; gattCharacteristics =
                gattService.getCharacteristics();
        ArrayList&amp;lt;BluetoothGattCharacteristic&amp;gt; charas =
                new ArrayList&amp;lt;BluetoothGattCharacteristic&amp;gt;();

        // Loops through available Characteristics.
        for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {
            charas.add(gattCharacteristic);
            HashMap&amp;lt;String, String&amp;gt; currentCharaData = new HashMap&amp;lt;String, String&amp;gt;();
            uuid = gattCharacteristic.getUuid().toString();
            currentCharaData.put(
                    LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString));
            currentCharaData.put(LIST_UUID, uuid);
            gattCharacteristicGroupData.add(currentCharaData);
        }
        mGattCharacteristics.add(charas);
        gattCharacteristicData.add(gattCharacteristicGroupData);
    }

    SimpleExpandableListAdapter gattServiceAdapter = new SimpleExpandableListAdapter(
            this,
            gattServiceData,
            android.R.layout.simple_expandable_list_item_2,
            new String[] {LIST_NAME, LIST_UUID},
            new int[] { android.R.id.text1, android.R.id.text2 },
            gattCharacteristicData,
            android.R.layout.simple_expandable_list_item_2,
            new String[] {LIST_NAME, LIST_UUID},
            new int[] { android.R.id.text1, android.R.id.text2 }
    );
    mGattServicesList.setAdapter(gattServiceAdapter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;BluetoothGattCharacteristic.PROPERTY_READ&lt;/code&gt;と
&lt;code&gt;BluetoothGattCharacteristic.PROPERTY_NOTIFY&lt;/code&gt;は
それぞれCharacteristicが読めることと、値が変化したときにPeripheralから通知が受けられることを表している。&lt;/p&gt;

&lt;p&gt;PeripheralというのはiBeaconのように、Advertising(見つかるようにする)し、接続される方。
それに対して接続する方をCentralという。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final ExpandableListView.OnChildClickListener servicesListClickListner =
  new ExpandableListView.OnChildClickListener() {
      @Override
      public boolean onChildClick(ExpandableListView parent, View v, int groupPosition,
                                  int childPosition, long id) {
          if (mGattCharacteristics != null) {
              final BluetoothGattCharacteristic characteristic =
                      mGattCharacteristics.get(groupPosition).get(childPosition);
              final int charaProp = characteristic.getProperties();
              if ((charaProp | BluetoothGattCharacteristic.PROPERTY_READ) &amp;gt; 0) {
                  // If there is an active notification on a characteristic, clear
                  // it first so it doesn&#39;t update the data field on the user interface.
                  if (mNotifyCharacteristic != null) {
                      mBluetoothLeService.setCharacteristicNotification(
                              mNotifyCharacteristic, false);
                      mNotifyCharacteristic = null;
                  }
                  mBluetoothLeService.readCharacteristic(characteristic);
              }
              if ((charaProp | BluetoothGattCharacteristic.PROPERTY_NOTIFY) &amp;gt; 0) {
                  mNotifyCharacteristic = characteristic;
                  mBluetoothLeService.setCharacteristicNotification(
                          characteristic, true);
              }
              return true;
          }
          return false;
      }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BroadcastReceiverを外すのと、サービスのバインドをやめる処理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onPause() {
    super.onPause();
    unregisterReceiver(mGattUpdateReceiver);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    unbindService(mServiceConnection);
    mBluetoothLeService = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bluetoothleservice&#34;&gt;BluetoothLeService&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/android/os/Binder.html&#34;&gt;Binder&lt;/a&gt;というのは
プロセス間通信(IPC; Inter-Process Communication)するためのもの。&lt;/p&gt;

&lt;p&gt;全てのクライアントのバインドが外れると&lt;code&gt;onUnbind&lt;/code&gt;が呼ばれるので、close処理をする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LocalBinder extends Binder {
    BluetoothLeService getService() {
        return BluetoothLeService.this;
    }
}

@Override
public IBinder onBind(Intent intent) {
    return mBinder;
}

@Override
public boolean onUnbind(Intent intent) {
    // After using a given device, you should make sure that BluetoothGatt.close() is called
    // such that resources are cleaned up properly.  In this particular example, close() is
    // invoked when the UI is disconnected from the Service.
    close();
    return super.onUnbind(intent);
}

private final IBinder mBinder = new LocalBinder();

public void close() {
    if (mBluetoothGatt == null) {
        return;
    }
    mBluetoothGatt.close();
    mBluetoothGatt = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初期化処理。BluetoothAdapterを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean initialize() {
    // For API level 18 and above, get a reference to BluetoothAdapter through
    // BluetoothManager.
    if (mBluetoothManager == null) {
        mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
        if (mBluetoothManager == null) {
            Log.e(TAG, &amp;quot;Unable to initialize BluetoothManager.&amp;quot;);
            return false;
        }
    }

    mBluetoothAdapter = mBluetoothManager.getAdapter();
    if (mBluetoothAdapter == null) {
        Log.e(TAG, &amp;quot;Unable to obtain a BluetoothAdapter.&amp;quot;);
        return false;
    }

    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既に接続したことがあれば、そのBluetoothGattで再接続し、そうでなければ&lt;code&gt;connectGatt&lt;/code&gt;する。
callbackでは必要に応じてIntentをブロードキャストする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean connect(final String address) {
    if (mBluetoothAdapter == null || address == null) {
        Log.w(TAG, &amp;quot;BluetoothAdapter not initialized or unspecified address.&amp;quot;);
        return false;
    }

    // Previously connected device.  Try to reconnect.
    if (mBluetoothDeviceAddress != null &amp;amp;&amp;amp; address.equals(mBluetoothDeviceAddress)
            &amp;amp;&amp;amp; mBluetoothGatt != null) {
        Log.d(TAG, &amp;quot;Trying to use an existing mBluetoothGatt for connection.&amp;quot;);
        if (mBluetoothGatt.connect()) {
            mConnectionState = STATE_CONNECTING;
            return true;
        } else {
            return false;
        }
    }

    final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
    if (device == null) {
        Log.w(TAG, &amp;quot;Device not found.  Unable to connect.&amp;quot;);
        return false;
    }
    // We want to directly connect to the device, so we are setting the autoConnect
    // parameter to false.
    mBluetoothGatt = device.connectGatt(this, false, mGattCallback);
    Log.d(TAG, &amp;quot;Trying to create a new connection.&amp;quot;);
    mBluetoothDeviceAddress = address;
    mConnectionState = STATE_CONNECTING;
    return true;
}

private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
    @Override
    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
        String intentAction;
        if (newState == BluetoothProfile.STATE_CONNECTED) {
            intentAction = ACTION_GATT_CONNECTED;
            mConnectionState = STATE_CONNECTED;
            broadcastUpdate(intentAction);
            Log.i(TAG, &amp;quot;Connected to GATT server.&amp;quot;);
            // Attempts to discover services after successful connection.
            Log.i(TAG, &amp;quot;Attempting to start service discovery:&amp;quot; +
                    mBluetoothGatt.discoverServices());

        } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
            intentAction = ACTION_GATT_DISCONNECTED;
            mConnectionState = STATE_DISCONNECTED;
            Log.i(TAG, &amp;quot;Disconnected from GATT server.&amp;quot;);
            broadcastUpdate(intentAction);
        }
    }

    @Override
    public void onServicesDiscovered(BluetoothGatt gatt, int status) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);
        } else {
            Log.w(TAG, &amp;quot;onServicesDiscovered received: &amp;quot; + status);
        }
    }

    @Override
    public void onCharacteristicRead(BluetoothGatt gatt,
                                     BluetoothGattCharacteristic characteristic,
                                     int status) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
        }
    }

    @Override
    public void onCharacteristicChanged(BluetoothGatt gatt,
                                        BluetoothGattCharacteristic characteristic) {
        broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;private void broadcastUpdate(final String action) {
    final Intent intent = new Intent(action);
    sendBroadcast(intent);
}

private void broadcastUpdate(final String action,
                             final BluetoothGattCharacteristic characteristic) {
    final Intent intent = new Intent(action);

    // This is special handling for the Heart Rate Measurement profile.  Data parsing is
    // carried out as per profile specifications:
    // http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.heart_rate_measurement.xml
    if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) {
        int flag = characteristic.getProperties();
        int format = -1;
        if ((flag &amp;amp; 0x01) != 0) {
            format = BluetoothGattCharacteristic.FORMAT_UINT16;
            Log.d(TAG, &amp;quot;Heart rate format UINT16.&amp;quot;);
        } else {
            format = BluetoothGattCharacteristic.FORMAT_UINT8;
            Log.d(TAG, &amp;quot;Heart rate format UINT8.&amp;quot;);
        }
        final int heartRate = characteristic.getIntValue(format, 1);
        Log.d(TAG, String.format(&amp;quot;Received heart rate: %d&amp;quot;, heartRate));
        intent.putExtra(EXTRA_DATA, String.valueOf(heartRate));
    } else {
        // For all other profiles, writes the data formatted in HEX.
        final byte[] data = characteristic.getValue();
        if (data != null &amp;amp;&amp;amp; data.length &amp;gt; 0) {
            final StringBuilder stringBuilder = new StringBuilder(data.length);
            for(byte byteChar : data)
                stringBuilder.append(String.format(&amp;quot;%02X &amp;quot;, byteChar));
            intent.putExtra(EXTRA_DATA, new String(data) + &amp;quot;\n&amp;quot; + stringBuilder.toString());
        }
    }
    sendBroadcast(intent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切断する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void disconnect() {
    if (mBluetoothAdapter == null || mBluetoothGatt == null) {
        Log.w(TAG, &amp;quot;BluetoothAdapter not initialized&amp;quot;);
        return;
    }
    mBluetoothGatt.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Characteristicを読む。結果は&lt;code&gt;BluetoothGattCallback#onCharacteristicRead&lt;/code&gt;で受け取る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void readCharacteristic(BluetoothGattCharacteristic characteristic) {
    if (mBluetoothAdapter == null || mBluetoothGatt == null) {
        Log.w(TAG, &amp;quot;BluetoothAdapter not initialized&amp;quot;);
        return;
    }
    mBluetoothGatt.readCharacteristic(characteristic);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Characteristicの通知を設定。
Descriptorというのは、Characteristicの値を説明するもので、通知を受け取れるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic,
                                          boolean enabled) {
    if (mBluetoothAdapter == null || mBluetoothGatt == null) {
        Log.w(TAG, &amp;quot;BluetoothAdapter not initialized&amp;quot;);
        return;
    }
    mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);

    // This is specific to Heart Rate Measurement.
    if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) {
        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(
                UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));
        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
        mBluetoothGatt.writeDescriptor(descriptor);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GATTのサービスのリストを返す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;BluetoothGattService&amp;gt; getSupportedGattServices() {
    if (mBluetoothGatt == null) return null;

    return mBluetoothGatt.getServices();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;android-6-0以降の端末で動かす&#34;&gt;Android 6.0以降の端末で動かす&lt;/h2&gt;

&lt;p&gt;Android6.0以降ではscanに位置情報のパーミッションが必要になったため、手を入れる必要がある。
&lt;a href=&#34;https://github.com/googlesamples/android-BluetoothLeGatt/pull/20&#34;&gt;プルリク&lt;/a&gt;は出てるのでそのうち入るかも。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_COARSE_LOCATION&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SDK Versionが23以上だったら、さらにリクエストする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
        != PackageManager.PERMISSION_GRANTED) {
    Log.w(&amp;quot;BleActivity&amp;quot;, &amp;quot;Location access not granted!&amp;quot;);
    ActivityCompat.requestPermissions(this,
            new String[]{Manifest.permission.ACCESS_COARSE_LOCATION},
            MY_PERMISSION_RESPONSE);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>PackerでAMIを作る</title>
          <link>http://sambaiz.net/article/24/</link>
          <pubDate>Tue, 18 Oct 2016 22:37:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/24/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://www.packer.io/&#34;&gt;https://www.packer.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;いろんなプラットフォームのイメージを作ることができるツール。
これでfluentdのログサーバーのAMIを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install packer # mac
$ packer -v
0.10.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定ファイルはこんな感じ。&lt;code&gt;variables&lt;/code&gt;の値は&lt;code&gt;{{user ... }}&lt;/code&gt;のところで使われる。
&lt;code&gt;builders&lt;/code&gt;に作るイメージの情報を書いて、&lt;code&gt;provisioners&lt;/code&gt;で環境を作る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;provisioners&lt;/code&gt;にはchefやansibleなども指定できるが、
継ぎ足し継ぎ足しで秘伝のタレ化したAMIも最初は、&lt;/p&gt;

&lt;p&gt;「コマンドいくつか実行するだけなのでとりあえず手作業で作った、後でなんとかする」&lt;/p&gt;

&lt;p&gt;なんてものもあったりして、
そういうものは無理にchefなどで始めず、手軽にshellでpacker buildするといいと思う。
手作業よりも楽だし、ソースが別にあるので使われていないAMIを消すのも簡単だ。&lt;/p&gt;

&lt;p&gt;fileではpermissionがないところに置くことができないので、一旦置いてshellで移動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;variables&amp;quot;: {
    &amp;quot;aws_access_key&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;aws_secret_key&amp;quot;: &amp;quot;&amp;quot;
  },
  &amp;quot;builders&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;amazon-ebs&amp;quot;,
    &amp;quot;access_key&amp;quot;: &amp;quot;{{user `aws_access_key`}}&amp;quot;,
    &amp;quot;secret_key&amp;quot;: &amp;quot;{{user `aws_secret_key`}}&amp;quot;,
    &amp;quot;region&amp;quot;: &amp;quot;ap-northeast-1&amp;quot;,
    &amp;quot;source_ami&amp;quot;: &amp;quot;ami-1a15c77b&amp;quot;,
    &amp;quot;instance_type&amp;quot;: &amp;quot;t2.small&amp;quot;,
    &amp;quot;ssh_username&amp;quot;: &amp;quot;ec2-user&amp;quot;,
    &amp;quot;ami_name&amp;quot;: &amp;quot;fluentd-logserver {{timestamp}}&amp;quot;
  }],
  &amp;quot;provisioners&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;file&amp;quot;,
    &amp;quot;source&amp;quot;: &amp;quot;td-agent.conf&amp;quot;,
    &amp;quot;destination&amp;quot;: &amp;quot;/home/ec2-user/td-agent.conf&amp;quot;
  },
  {
    &amp;quot;type&amp;quot;: &amp;quot;shell&amp;quot;,
    &amp;quot;inline&amp;quot;: [
      &amp;quot;curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent2.sh | sh&amp;quot;,
      &amp;quot;sudo mv /home/ec2-user/td-agent.conf /etc/td-agent/td-agent.conf&amp;quot;,
      &amp;quot;sudo /etc/init.d/td-agent restart&amp;quot;
    ]
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ packer validate fluentd-logserver.json
Template validated successfully.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buildのとき&lt;code&gt;-var&lt;/code&gt;でvariablesを渡すことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ packer build \
    -var &#39;aws_access_key=YOUR ACCESS KEY&#39; \
    -var &#39;aws_secret_key=YOUR SECRET KEY&#39; \
    fluentd-logserver.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると実際にインスタンスを立ち上げ、AMIを作成し始める。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>android-bluetoothChatを読む</title>
          <link>http://sambaiz.net/article/23/</link>
          <pubDate>Sat, 15 Oct 2016 14:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/23/</guid>
          <description>

&lt;p&gt;Classic Bluetoothのサンプルコード。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/googlesamples/android-BluetoothChat&#34;&gt;https://github.com/googlesamples/android-BluetoothChat&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mainactivity&#34;&gt;MainActivity&lt;/h2&gt;

&lt;p&gt;まず、MainActivity。&lt;/p&gt;

&lt;p&gt;Fragmentのcommitや、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    if (savedInstanceState == null) {
        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        BluetoothChatFragment fragment = new BluetoothChatFragment();
        transaction.replace(R.id.sample_content_fragment, fragment);
        transaction.commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;オプションメニューの設定をしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 最初だけ呼ばれる
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}

// 表示される度に呼ばれる
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    MenuItem logToggle = menu.findItem(R.id.menu_toggle_log);
    logToggle.setVisible(findViewById(R.id.sample_output) instanceof ViewAnimator);
    logToggle.setTitle(mLogShown ? R.string.sample_hide_log : R.string.sample_show_log);

    return super.onPrepareOptionsMenu(menu);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch(item.getItemId()) {
        case R.id.menu_toggle_log:
            mLogShown = !mLogShown;
            ViewAnimator output = (ViewAnimator) findViewById(R.id.sample_output);
            if (mLogShown) {
                output.setDisplayedChild(1);
            } else {
                output.setDisplayedChild(0);
            }　
            // メニューを再作成する(onCreateOptionsMenu, onPrepareOptionsMenuが呼ばれる)
            supportInvalidateOptionsMenu();
            return true;
    }
    return super.onOptionsItemSelected(item);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bluetoothchatfragment&#34;&gt;BluetoothChatFragment&lt;/h2&gt;

&lt;p&gt;onCreateではBluetoothAdapterを取得して、Bluetoothが使えるかどうかを確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);
    // Get local Bluetooth adapter
    mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

    // If the adapter is null, then Bluetooth is not supported
    if (mBluetoothAdapter == null) {
        FragmentActivity activity = getActivity();
        Toast.makeText(activity, &amp;quot;Bluetooth is not available&amp;quot;, Toast.LENGTH_LONG).show();
        activity.finish();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onStartではもしBluetoothが有効でなければ有効にするよう要求し、有効になったらsetupする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onStart() {
    super.onStart();
    // If BT is not on, request that it be enabled.
    // setupChat() will then be called during onActivityResult
    if (!mBluetoothAdapter.isEnabled()) {
        Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(enableIntent, REQUEST_ENABLE_BT);
        // Otherwise, setup the chat session
    } else if (mChatService == null) {
        setupChat();
    }
}

public void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
        case REQUEST_CONNECT_DEVICE_SECURE:
            // When DeviceListActivity returns with a device to connect
            if (resultCode == Activity.RESULT_OK) {
                connectDevice(data, true);
            }
            break;
        case REQUEST_CONNECT_DEVICE_INSECURE:
            // When DeviceListActivity returns with a device to connect
            if (resultCode == Activity.RESULT_OK) {
                connectDevice(data, false);
            }
            break;
        case REQUEST_ENABLE_BT:
            // When the request to enable Bluetooth returns
            if (resultCode == Activity.RESULT_OK) {
                // Bluetooth is now enabled, so set up a chat session
                setupChat();
            } else {
                // User did not enable Bluetooth or an error occurred
                Log.d(TAG, &amp;quot;BT not enabled&amp;quot;);
                Toast.makeText(getActivity(), R.string.bt_not_enabled_leaving,
                        Toast.LENGTH_SHORT).show();
                getActivity().finish();
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onActivityResultではDeviceListActivityで、接続する端末を選択した結果もハンドリングしていて、connectDeviceを呼ぶ。
アドレスからmBluetoothAdapter.getRemoteDevice(address)でdeviceを取得して、これをサービスに渡して接続する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void connectDevice(Intent data, boolean secure) {
    // Get the device MAC address
    String address = data.getExtras()
            .getString(DeviceListActivity.EXTRA_DEVICE_ADDRESS);
    // Get the BluetoothDevice object
    BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
    // Attempt to connect to the device
    mChatService.connect(device, secure);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Serviceのstartとstop。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onDestroy() {
    super.onDestroy();
    if (mChatService != null) {
        mChatService.stop();
    }
}

@Override
public void onResume() {
    super.onResume();

    // Performing this check in onResume() covers the case in which BT was
    // not enabled during onStart(), so we were paused to enable it...
    // onResume() will be called when ACTION_REQUEST_ENABLE activity returns.
    if (mChatService != null) {
        // Only if the state is STATE_NONE, do we know that we haven&#39;t started already
        if (mChatService.getState() == BluetoothChatService.STATE_NONE) {
            // Start the Bluetooth chat services
            mChatService.start();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;viewまわり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
                         @Nullable Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_bluetooth_chat, container, false);
}

@Override
public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
    mConversationView = (ListView) view.findViewById(R.id.in);
    mOutEditText = (EditText) view.findViewById(R.id.edit_text_out);
    mSendButton = (Button) view.findViewById(R.id.button_send);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setupChatでは会話用リストにAdapterをセットしたり、入力欄やボタンにリスナーを登録するほかに、ChatServiceを初期化する。
初期化する際に第二引数として渡すmHandlerでは、Serviceからのメッセージにより処理を行う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void setupChat() {
    Log.d(TAG, &amp;quot;setupChat()&amp;quot;);

    // Initialize the array adapter for the conversation thread
    mConversationArrayAdapter = new ArrayAdapter&amp;lt;String&amp;gt;(getActivity(), R.layout.message);

    mConversationView.setAdapter(mConversationArrayAdapter);

    // Initialize the compose field with a listener for the return key
    mOutEditText.setOnEditorActionListener(mWriteListener);

    // Initialize the send button with a listener that for click events
    mSendButton.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
            // Send a message using content of the edit text widget
            View view = getView();
            if (null != view) {
                TextView textView = (TextView) view.findViewById(R.id.edit_text_out);
                String message = textView.getText().toString();
                sendMessage(message);
            }
        }
    });

    // Initialize the BluetoothChatService to perform bluetooth connections
    mChatService = new BluetoothChatService(getActivity(), mHandler);

    // Initialize the buffer for outgoing messages
    mOutStringBuffer = new StringBuffer(&amp;quot;&amp;quot;);
}

private TextView.OnEditorActionListener mWriteListener = new TextView.OnEditorActionListener() {
  public boolean onEditorAction(TextView view, int actionId, KeyEvent event) {
      // If the action is a key-up event on the return key, send the message
      if (actionId == EditorInfo.IME_NULL &amp;amp;&amp;amp; event.getAction() == KeyEvent.ACTION_UP) {
          String message = view.getText().toString();
          sendMessage(message);
      }
      return true;
  }
};

private final Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        FragmentActivity activity = getActivity();
        switch (msg.what) {
            case Constants.MESSAGE_STATE_CHANGE:
                switch (msg.arg1) {
                    case BluetoothChatService.STATE_CONNECTED:
                        setStatus(getString(R.string.title_connected_to, mConnectedDeviceName));
                        mConversationArrayAdapter.clear();
                        break;
                    case BluetoothChatService.STATE_CONNECTING:
                        setStatus(R.string.title_connecting);
                        break;
                    case BluetoothChatService.STATE_LISTEN:
                    case BluetoothChatService.STATE_NONE:
                        setStatus(R.string.title_not_connected);
                        break;
                }
                break;
            case Constants.MESSAGE_WRITE:
                byte[] writeBuf = (byte[]) msg.obj;
                // construct a string from the buffer
                String writeMessage = new String(writeBuf);
                mConversationArrayAdapter.add(&amp;quot;Me:  &amp;quot; + writeMessage);
                break;
            case Constants.MESSAGE_READ:
                byte[] readBuf = (byte[]) msg.obj;
                // construct a string from the valid bytes in the buffer
                String readMessage = new String(readBuf, 0, msg.arg1);
                mConversationArrayAdapter.add(mConnectedDeviceName + &amp;quot;:  &amp;quot; + readMessage);
                break;
            case Constants.MESSAGE_DEVICE_NAME:
                // save the connected device&#39;s name
                mConnectedDeviceName = msg.getData().getString(Constants.DEVICE_NAME);
                if (null != activity) {
                    Toast.makeText(activity, &amp;quot;Connected to &amp;quot;
                            + mConnectedDeviceName, Toast.LENGTH_SHORT).show();
                }
                break;
            case Constants.MESSAGE_TOAST:
                if (null != activity) {
                    Toast.makeText(activity, msg.getData().getString(Constants.TOAST),
                            Toast.LENGTH_SHORT).show();
                }
                break;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;デバイスを検出可能にするのと、DeviceListActivityを始めるメニュー。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.bluetooth_chat, menu);
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.secure_connect_scan: {
            // Launch the DeviceListActivity to see devices and do scan
            Intent serverIntent = new Intent(getActivity(), DeviceListActivity.class);
            startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE_SECURE);
            return true;
        }
        case R.id.insecure_connect_scan: {
            // Launch the DeviceListActivity to see devices and do scan
            Intent serverIntent = new Intent(getActivity(), DeviceListActivity.class);
            startActivityForResult(serverIntent, REQUEST_CONNECT_DEVICE_INSECURE);
            return true;
        }
        case R.id.discoverable: {
            // Ensure this device is discoverable by others
            ensureDiscoverable();
            return true;
        }
    }
    return false;
}

private void ensureDiscoverable() {
    if (mBluetoothAdapter.getScanMode() !=
            BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
        Intent discoverableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
        discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
        startActivity(discoverableIntent);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bluetoothchatservice&#34;&gt;BluetoothChatService&lt;/h2&gt;

&lt;p&gt;初期stateはSTATE_NONE。
setStateしたときにobtainMessageでstateが変わったときの処理をhandlerに行わせる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public BluetoothChatService(Context context, Handler handler) {
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    mState = STATE_NONE;
    mHandler = handler;
}

private synchronized void setState(int state) {
    Log.d(TAG, &amp;quot;setState() &amp;quot; + mState + &amp;quot; -&amp;gt; &amp;quot; + state);
    mState = state;

    // Give the new state to the Handler so the UI Activity can update
    mHandler.obtainMessage(Constants.MESSAGE_STATE_CHANGE, state, -1).sendToTarget();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接続しようとしている、した、される処理はそれぞれ別スレッドで行われる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public synchronized void start() {
    Log.d(TAG, &amp;quot;start&amp;quot;);

    // Cancel any thread attempting to make a connection
    if (mConnectThread != null) {
        mConnectThread.cancel();
        mConnectThread = null;
    }

    // Cancel any thread currently running a connection
    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }

    setState(STATE_LISTEN);

    // Start the thread to listen on a BluetoothServerSocket
    if (mSecureAcceptThread == null) {
        mSecureAcceptThread = new AcceptThread(true);
        mSecureAcceptThread.start();
    }
    if (mInsecureAcceptThread == null) {
        mInsecureAcceptThread = new AcceptThread(false);
        mInsecureAcceptThread.start();
    }
}

public synchronized void stop() {
    Log.d(TAG, &amp;quot;stop&amp;quot;);

    if (mConnectThread != null) {
        mConnectThread.cancel();
        mConnectThread = null;
    }

    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }

    if (mSecureAcceptThread != null) {
        mSecureAcceptThread.cancel();
        mSecureAcceptThread = null;
    }

    if (mInsecureAcceptThread != null) {
        mInsecureAcceptThread.cancel();
        mInsecureAcceptThread = null;
    }
    setState(STATE_NONE);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、接続するためのConnectThread。コンストラクタでつなげるdeviceからsocketを作成し、
runで接続する。接続できたらconnectedを呼び、ConnectedThreadを始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private class ConnectThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final BluetoothDevice mmDevice;
    private String mSocketType;

    public ConnectThread(BluetoothDevice device, boolean secure) {
        mmDevice = device;
        BluetoothSocket tmp = null;
        mSocketType = secure ? &amp;quot;Secure&amp;quot; : &amp;quot;Insecure&amp;quot;;

        // Get a BluetoothSocket for a connection with the
        // given BluetoothDevice
        try {
            if (secure) {
                tmp = device.createRfcommSocketToServiceRecord(
                        MY_UUID_SECURE);
            } else {
                tmp = device.createInsecureRfcommSocketToServiceRecord(
                        MY_UUID_INSECURE);
            }
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;Socket Type: &amp;quot; + mSocketType + &amp;quot;create() failed&amp;quot;, e);
        }
        mmSocket = tmp;
    }

    public void run() {
        Log.i(TAG, &amp;quot;BEGIN mConnectThread SocketType:&amp;quot; + mSocketType);
        setName(&amp;quot;ConnectThread&amp;quot; + mSocketType);

        // Always cancel discovery because it will slow down a connection
        mAdapter.cancelDiscovery();

        // Make a connection to the BluetoothSocket
        try {
            // This is a blocking call and will only return on a
            // successful connection or an exception
            mmSocket.connect();
        } catch (IOException e) {
            // Close the socket
            try {
                mmSocket.close();
            } catch (IOException e2) {
                Log.e(TAG, &amp;quot;unable to close() &amp;quot; + mSocketType +
                        &amp;quot; socket during connection failure&amp;quot;, e2);
            }
            connectionFailed();
            return;
        }

        // Reset the ConnectThread because we&#39;re done
        synchronized (BluetoothChatService.this) {
            mConnectThread = null;
        }

        // Start the connected thread
        connected(mmSocket, mmDevice, mSocketType);
    }

    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;close() of connect &amp;quot; + mSocketType + &amp;quot; socket failed&amp;quot;, e);
        }
    }
}

public synchronized void connected(BluetoothSocket socket, BluetoothDevice
        device, final String socketType) {
    Log.d(TAG, &amp;quot;connected, Socket Type:&amp;quot; + socketType);

    // Cancel the thread that completed the connection
    if (mConnectThread != null) {
        mConnectThread.cancel();
        mConnectThread = null;
    }

    // Cancel any thread currently running a connection
    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }

    // Cancel the accept thread because we only want to connect to one device
    if (mSecureAcceptThread != null) {
        mSecureAcceptThread.cancel();
        mSecureAcceptThread = null;
    }
    if (mInsecureAcceptThread != null) {
        mInsecureAcceptThread.cancel();
        mInsecureAcceptThread = null;
    }

    // Start the thread to manage the connection and perform transmissions
    mConnectedThread = new ConnectedThread(socket, socketType);
    mConnectedThread.start();

    // Send the name of the connected device back to the UI Activity
    Message msg = mHandler.obtainMessage(Constants.MESSAGE_DEVICE_NAME);
    Bundle bundle = new Bundle();
    bundle.putString(Constants.DEVICE_NAME, device.getName());
    msg.setData(bundle);
    mHandler.sendMessage(msg);

    setState(STATE_CONNECTED);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ConnectedThreadではsocketからinputStreamとoutputStreamを取得し、
runでは読んでメッセージで渡し、writeで書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private class ConnectedThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final InputStream mmInStream;
    private final OutputStream mmOutStream;

    public ConnectedThread(BluetoothSocket socket, String socketType) {
        Log.d(TAG, &amp;quot;create ConnectedThread: &amp;quot; + socketType);
        mmSocket = socket;
        InputStream tmpIn = null;
        OutputStream tmpOut = null;

        // Get the BluetoothSocket input and output streams
        try {
            tmpIn = socket.getInputStream();
            tmpOut = socket.getOutputStream();
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;temp sockets not created&amp;quot;, e);
        }

        mmInStream = tmpIn;
        mmOutStream = tmpOut;
    }

    public void run() {
        Log.i(TAG, &amp;quot;BEGIN mConnectedThread&amp;quot;);
        byte[] buffer = new byte[1024];
        int bytes;

        // Keep listening to the InputStream while connected
        while (mState == STATE_CONNECTED) {
            try {
                // Read from the InputStream
                bytes = mmInStream.read(buffer);

                // Send the obtained bytes to the UI Activity
                mHandler.obtainMessage(Constants.MESSAGE_READ, bytes, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                Log.e(TAG, &amp;quot;disconnected&amp;quot;, e);
                connectionLost();
                // Start the service over to restart listening mode
                BluetoothChatService.this.start();
                break;
            }
        }
    }

    /**
     * Write to the connected OutStream.
     *
     * @param buffer The bytes to write
     */
    public void write(byte[] buffer) {
        try {
            mmOutStream.write(buffer);

            // Share the sent message back to the UI Activity
            mHandler.obtainMessage(Constants.MESSAGE_WRITE, -1, -1, buffer)
                    .sendToTarget();
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;Exception during write&amp;quot;, e);
        }
    }

    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;close() of connect socket failed&amp;quot;, e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AcceptThreadでは常に受け入れられる形にしておく。もしつながったらConnectThreadと同様にconnectedする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private class AcceptThread extends Thread {
    // The local server socket
    private final BluetoothServerSocket mmServerSocket;
    private String mSocketType;

    public AcceptThread(boolean secure) {
        BluetoothServerSocket tmp = null;
        mSocketType = secure ? &amp;quot;Secure&amp;quot; : &amp;quot;Insecure&amp;quot;;

        // Create a new listening server socket
        try {
            if (secure) {
                tmp = mAdapter.listenUsingRfcommWithServiceRecord(NAME_SECURE,
                        MY_UUID_SECURE);
            } else {
                tmp = mAdapter.listenUsingInsecureRfcommWithServiceRecord(
                        NAME_INSECURE, MY_UUID_INSECURE);
            }
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;Socket Type: &amp;quot; + mSocketType + &amp;quot;listen() failed&amp;quot;, e);
        }
        mmServerSocket = tmp;
    }

    public void run() {
        Log.d(TAG, &amp;quot;Socket Type: &amp;quot; + mSocketType +
                &amp;quot;BEGIN mAcceptThread&amp;quot; + this);
        setName(&amp;quot;AcceptThread&amp;quot; + mSocketType);

        BluetoothSocket socket = null;

        // Listen to the server socket if we&#39;re not connected
        while (mState != STATE_CONNECTED) {
            try {
                // This is a blocking call and will only return on a
                // successful connection or an exception
                socket = mmServerSocket.accept();
            } catch (IOException e) {
                Log.e(TAG, &amp;quot;Socket Type: &amp;quot; + mSocketType + &amp;quot;accept() failed&amp;quot;, e);
                break;
            }

            // If a connection was accepted
            if (socket != null) {
                synchronized (BluetoothChatService.this) {
                    switch (mState) {
                        case STATE_LISTEN:
                        case STATE_CONNECTING:
                            // Situation normal. Start the connected thread.
                            connected(socket, socket.getRemoteDevice(),
                                    mSocketType);
                            break;
                        case STATE_NONE:
                        case STATE_CONNECTED:
                            // Either not ready or already connected. Terminate new socket.
                            try {
                                socket.close();
                            } catch (IOException e) {
                                Log.e(TAG, &amp;quot;Could not close unwanted socket&amp;quot;, e);
                            }
                            break;
                    }
                }
            }
        }
        Log.i(TAG, &amp;quot;END mAcceptThread, socket Type: &amp;quot; + mSocketType);

    }

    public void cancel() {
        Log.d(TAG, &amp;quot;Socket Type&amp;quot; + mSocketType + &amp;quot;cancel &amp;quot; + this);
        try {
            mmServerSocket.close();
        } catch (IOException e) {
            Log.e(TAG, &amp;quot;Socket Type&amp;quot; + mSocketType + &amp;quot;close() of server failed&amp;quot;, e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;connectでは、接続しようとしているならそれをキャンセル、接続したものがあるならsocketを閉じて
新しい接続を始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public synchronized void connect(BluetoothDevice device, boolean secure) {
    Log.d(TAG, &amp;quot;connect to: &amp;quot; + device);

    // Cancel any thread attempting to make a connection
    if (mState == STATE_CONNECTING) {
        if (mConnectThread != null) {
            mConnectThread.cancel();
            mConnectThread = null;
        }
    }

    // Cancel any thread currently running a connection
    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }

    // Start the thread to connect with the given device
    mConnectThread = new ConnectThread(device, secure);
    mConnectThread.start();
    setState(STATE_CONNECTING);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;writeでは接続済みであることを確認後、connectedThreadの(参照を)コピーして、writeしている。
この間にmConnectedThreadにnullが代入されたりすることをsynchronizedで防ぐ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void write(byte[] out) {
    // Create temporary object
    ConnectedThread r;
    // Synchronize a copy of the ConnectedThread
    synchronized (this) {
        if (mState != STATE_CONNECTED) return;
        r = mConnectedThread;
    }
    // Perform the write unsynchronized
    r.write(out);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;devicelistactivity&#34;&gt;DeviceListActivity&lt;/h2&gt;

&lt;p&gt;検出可能にしている他端末を探し、選択する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS)&lt;/code&gt;して、
&lt;code&gt;setProgressBarIndeterminateVisibility(true)&lt;/code&gt;すると右上にプログレスバーが表示できる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;new IntentFilter(BluetoothDevice.ACTION_FOUND)&lt;/code&gt;と
&lt;code&gt;new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)&lt;/code&gt;で
&lt;code&gt;registerReceiver(mReceiver, filter)&lt;/code&gt;して、
デバイスを見つけたときと探し終わったときにブロードキャストされてくるインテントを受信するレシーバーを登録する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Setup the window
    requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
    setContentView(R.layout.activity_device_list);

    // Set result CANCELED in case the user backs out
    setResult(Activity.RESULT_CANCELED);

    // Initialize the button to perform device discovery
    Button scanButton = (Button) findViewById(R.id.button_scan);
    scanButton.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
            doDiscovery();
            v.setVisibility(View.GONE);
        }
    });

    // Initialize array adapters. One for already paired devices and
    // one for newly discovered devices
    ArrayAdapter&amp;lt;String&amp;gt; pairedDevicesArrayAdapter =
            new ArrayAdapter&amp;lt;String&amp;gt;(this, R.layout.device_name);
    mNewDevicesArrayAdapter = new ArrayAdapter&amp;lt;String&amp;gt;(this, R.layout.device_name);

    // Find and set up the ListView for paired devices
    ListView pairedListView = (ListView) findViewById(R.id.paired_devices);
    pairedListView.setAdapter(pairedDevicesArrayAdapter);
    pairedListView.setOnItemClickListener(mDeviceClickListener);

    // Find and set up the ListView for newly discovered devices
    ListView newDevicesListView = (ListView) findViewById(R.id.new_devices);
    newDevicesListView.setAdapter(mNewDevicesArrayAdapter);
    newDevicesListView.setOnItemClickListener(mDeviceClickListener);

    // Register for broadcasts when a device is discovered
    IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
    this.registerReceiver(mReceiver, filter);

    // Register for broadcasts when discovery has finished
    filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    this.registerReceiver(mReceiver, filter);

    // Get the local Bluetooth adapter
    mBtAdapter = BluetoothAdapter.getDefaultAdapter();

    // Get a set of currently paired devices
    Set&amp;lt;BluetoothDevice&amp;gt; pairedDevices = mBtAdapter.getBondedDevices();

    // If there are paired devices, add each one to the ArrayAdapter
    if (pairedDevices.size() &amp;gt; 0) {
        findViewById(R.id.title_paired_devices).setVisibility(View.VISIBLE);
        for (BluetoothDevice device : pairedDevices) {
            pairedDevicesArrayAdapter.add(device.getName() + &amp;quot;\n&amp;quot; + device.getAddress());
        }
    } else {
        String noDevices = getResources().getText(R.string.none_paired).toString();
        pairedDevicesArrayAdapter.add(noDevices);
    }
}

private void doDiscovery() {
    Log.d(TAG, &amp;quot;doDiscovery()&amp;quot;);

    // Indicate scanning in the title
    setProgressBarIndeterminateVisibility(true);
    setTitle(R.string.scanning);

    // Turn on sub-title for new devices
    findViewById(R.id.title_new_devices).setVisibility(View.VISIBLE);

    // If we&#39;re already discovering, stop it
    if (mBtAdapter.isDiscovering()) {
        mBtAdapter.cancelDiscovery();
    }

    // Request discover from BluetoothAdapter
    mBtAdapter.startDiscovery();
}

private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();

        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // Get the BluetoothDevice object from the Intent
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            // If it&#39;s already paired, skip it, because it&#39;s been listed already
            if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                mNewDevicesArrayAdapter.add(device.getName() + &amp;quot;\n&amp;quot; + device.getAddress());
            }
            // When discovery is finished, change the Activity title
        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
            setProgressBarIndeterminateVisibility(false);
            setTitle(R.string.select_device);
            if (mNewDevicesArrayAdapter.getCount() == 0) {
                String noDevices = getResources().getText(R.string.none_found).toString();
                mNewDevicesArrayAdapter.add(noDevices);
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onDestroyで、探索をやめ、登録したレシーバーを外す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onDestroy() {
    super.onDestroy();

    // Make sure we&#39;re not doing discovery anymore
    if (mBtAdapter != null) {
        mBtAdapter.cancelDiscovery();
    }

    // Unregister broadcast listeners
    this.unregisterReceiver(mReceiver);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接続先リストから選択されたら、アドレスを付けて結果を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private AdapterView.OnItemClickListener mDeviceClickListener
        = new AdapterView.OnItemClickListener() {
    public void onItemClick(AdapterView&amp;lt;?&amp;gt; av, View v, int arg2, long arg3) {
        // Cancel discovery because it&#39;s costly and we&#39;re about to connect
        mBtAdapter.cancelDiscovery();

        // Get the device MAC address, which is the last 17 chars in the View
        String info = ((TextView) v).getText().toString();
        String address = info.substring(info.length() - 17);

        // Create the result Intent and include the MAC address
        Intent intent = new Intent();
        intent.putExtra(EXTRA_DEVICE_ADDRESS, address);

        // Set result and finish this Activity
        setResult(Activity.RESULT_OK, intent);
        finish();
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>静的ウェブサイトエンジンHugoに乗り換えた</title>
          <link>http://sambaiz.net/article/22/</link>
          <pubDate>Tue, 04 Oct 2016 22:21:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/22/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今までこのサイトはフロントのReactからLambda &amp;amp; API Gatewayで作った記事APIを呼ぶ構成になっていた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/1&#34;&gt;ホームページ作った&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当初はページの描画をフロントに任せることで、
サーバーレス
(記事の情報をjsonで渡すAPI Gatewayと、S3の組み合わせ)
で作れると思っていたが、結果そんなに甘くはなく、サーバーサイドレンダリングするはめになる。
最初からレンダリングしたものを置いておけばいいと思った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/5&#34;&gt;webpack環境でredux&amp;amp;react-routerのページをサーバーサイドレンダリングする&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そんなこんなでHugoに乗り換えることにした。
記事はmarkdownで管理していたので、これにメタ情報を加えるだけで移行できた。
タグで絞り込むこともできるようになったので良いと思う。
また、静的なページになったのでgithub pagesに置けるようにもなった。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>DeepDreaming with TensorFlowをやる(2)</title>
          <link>http://sambaiz.net/article/21/</link>
          <pubDate>Sat, 10 Sep 2016 14:46:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/21/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/20&#34;&gt;前回&lt;/a&gt;の続き。&lt;/p&gt;

&lt;h2 id=&#34;multiscale-image-generation&#34;&gt;Multiscale image generation&lt;/h2&gt;

&lt;p&gt;様々なスケールで勾配上昇させる。小さなスケールで上昇させたものをより大きなスケールでさらに上昇させていく。
ただ、壁紙のようなサイズを生成するような場合にそれを行うと、GPUのメモリを食いつぶしてしまう。
これを避けるために、画像を小さなタイルに分割し、それぞれ独立に勾配を計算する。
また、毎回画像をランダムにシフトしていくことで、タイルに見えることを避け、画像全体の品質を向上させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def tffunc(*argtypes):
    &#39;&#39;&#39;Helper that transforms TF-graph generating function into a regular one.
    See &amp;quot;resize&amp;quot; function below.
    &#39;&#39;&#39;
    placeholders = list(map(tf.placeholder, argtypes))
    def wrap(f):
        out = f(*placeholders)
        def wrapper(*args, **kw):
            return out.eval(dict(zip(placeholders, args)), session=kw.get(&#39;session&#39;))
        return wrapper
    return wrap

# Helper function that uses TF to resize an image
def resize(img, size):
    img = tf.expand_dims(img, 0)
    return tf.image.resize_bilinear(img, size)[0,:,:,:]
resize = tffunc(np.float32, np.int32)(resize)


def calc_grad_tiled(img, t_grad, tile_size=512):
    &#39;&#39;&#39;Compute the value of tensor t_grad over the image in a tiled way.
    Random shifts are applied to the image to blur tile boundaries over
    multiple iterations.&#39;&#39;&#39;
    sz = tile_size
    h, w = img.shape[:2]
    sx, sy = np.random.randint(sz, size=2)
    img_shift = np.roll(np.roll(img, sx, 1), sy, 0)
    grad = np.zeros_like(img)
    for y in range(0, max(h-sz//2, sz),sz):
        for x in range(0, max(w-sz//2, sz),sz):
            sub = img_shift[y:y+sz,x:x+sz]
            g = sess.run(t_grad, {t_input:sub})
            grad[y:y+sz,x:x+sz] = g
    return np.roll(np.roll(grad, -sx, 1), -sy, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tf.image.resize_bilinear&lt;/code&gt;は&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/image.html#resize_bilinear&#34;&gt;双線形補間によってリサイズする。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;numpy.roll&lt;/code&gt;は&lt;a href=&#34;http://docs.scipy.org/doc/numpy/reference/generated/numpy.roll.html&#34;&gt;配列を第三引数axisによってローリングする&lt;/a&gt;。
axisを指定しない場合、フラットなものとして扱われる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hoge = [[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]]

print(np.roll(hoge, 1))
# [[8 0 1]
#  [2 3 4]
#  [5 6 7]]

print(np.roll(hoge, 1, axis=0))
# [[6 7 8]
#  [0 1 2]
#  [3 4 5]]

print(np.roll(hoge, 1, axis=1))
# [[2 0 1]
#  [5 3 4]
#  [8 6 7]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つまり、&lt;code&gt;calc_grad_tiled&lt;/code&gt;では、ランダムにローリングして、タイルに分割して勾配を求め、ローリングした分を戻して返している。
これと、画像サイズを&lt;code&gt;octave_scale&lt;/code&gt;倍にしていく以外は前回やったのと基本的に同じだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def render_multiscale(t_obj, img0=img_noise, iter_n=10, step=1.0, octave_n=3, octave_scale=1.4):
    t_score = tf.reduce_mean(t_obj) # defining the optimization objective
    t_grad = tf.gradients(t_score, t_input)[0] # behold the power of automatic differentiation!

    img = img0.copy()
    for octave in range(octave_n):
        if octave&amp;gt;0:
            hw = np.float32(img.shape[:2])*octave_scale
            img = resize(img, np.int32(hw))
        for i in range(iter_n):
            g = calc_grad_tiled(img, t_grad)
            # normalizing the gradient, so the same step size should work
            g /= g.std()+1e-8         # for different layers and networks
            img += g*step
            print(&#39;.&#39;, end = &#39; &#39;)
        clear_output()
        showarray(visstd(img))

render_multiscale(T(layer)[:,:,:,channel])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;laplacian-pyramid-gradient-normalization&#34;&gt;Laplacian Pyramid Gradient Normalization&lt;/h2&gt;

&lt;p&gt;結果の画像は、高い周波数(ピクセルの変化の度合が高い)が多く含まれている。
これを改善するための一つの方法として、毎回画像をぼかし、高周波数を抑え、画像を滑らかにするものがある。
ただ、この方法は良い画像にするためにより多くの繰り返しが必要になってしまう。
逆に、低周波数を上げるのは、ラプラシアンピラミッドを使う方法があって、これで勾配を正規化する。&lt;/p&gt;

&lt;p&gt;ラプラシアンピラミッドというのは、ガウシアンピラミッドにおける、ある解像度の画像と、
その一つレベルの高い(解像度1/2 * &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;)画像をアップサンプルしたものの差分だ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://labs.eecs.tottori-u.ac.jp/sd/Member/oyamada/OpenCV/html/py_tutorials/py_imgproc/py_pyramids/py_pyramids.html&#34;&gt;画像ピラミッド — OpenCV-Python Tutorials 1 documentation&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;k = np.float32([1,4,6,4,1])
k = np.outer(k, k)
# [[  1.   4.   6.   4.   1.]
#  [  4.  16.  24.  16.   4.]
#  [  6.  24.  36.  24.   6.]
#  [  4.  16.  24.  16.   4.]
#  [  1.   4.   6.   4.   1.]]

k5x5 = k[:,:,None,None]/k.sum()*np.eye(3, dtype=np.float32)

print(len(k5x5))
# 5

print(k5x5[0])
# [[[ 0.00390625  0.          0.        ]
#  [ 0.          0.00390625  0.        ]
#  [ 0.          0.          0.00390625]]

# [[ 0.015625    0.          0.        ]
#  [ 0.          0.015625    0.        ]
#  [ 0.          0.          0.015625  ]]

# [[ 0.0234375   0.          0.        ]
#  [ 0.          0.0234375   0.        ]
#  [ 0.          0.          0.0234375 ]]

# [[ 0.015625    0.          0.        ]
#  [ 0.          0.015625    0.        ]
#  [ 0.          0.          0.015625  ]]

# [[ 0.00390625  0.          0.        ]
#  [ 0.          0.00390625  0.        ]
#  [ 0.          0.          0.00390625]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;numpy.outer&lt;/code&gt;は&lt;a href=&#34;http://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html&#34;&gt;外積を求める&lt;/a&gt;もので、
&lt;code&gt;numpy.eye&lt;/code&gt;は&lt;a href=&#34;http://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html&#34;&gt;対角線が1で、それ以外は0の2次元行列を返す&lt;/a&gt;。
&lt;code&gt;k&lt;/code&gt;を指定すると、対角線の位置を変更できるが、指定していない場合はNxNの単位行列が返ることになる。
このフィルターで畳み込むことで、ラプラシアンピラミッドの1レベル高い画像に変換できる。
&lt;code&gt;tf.nn.conv2d_transpose&lt;/code&gt;は
&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/nn.html#conv2d_transpose&#34;&gt;畳み込みの逆処理&lt;/a&gt;のようなもので、
これでアップサンプルした画像と元画像の差分を取って、ラプラシアンピラミッドを生成している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def lap_split(img):
    &#39;&#39;&#39;Split the image into lo and hi frequency components&#39;&#39;&#39;
    with tf.name_scope(&#39;split&#39;):
        lo = tf.nn.conv2d(img, k5x5, [1,2,2,1], &#39;SAME&#39;)
        lo2 = tf.nn.conv2d_transpose(lo, k5x5*4, tf.shape(img), [1,2,2,1])
        hi = img-lo2
    return lo, hi

def lap_split_n(img, n):
    &#39;&#39;&#39;Build Laplacian pyramid with n splits&#39;&#39;&#39;
    levels = []
    for i in range(n):
        img, hi = lap_split(img)
        levels.append(hi)
    levels.append(img)
    return levels[::-1]

def lap_merge(levels):
    &#39;&#39;&#39;Merge Laplacian pyramid&#39;&#39;&#39;
    img = levels[0]
    for hi in levels[1:]:
        with tf.name_scope(&#39;merge&#39;):
            img = tf.nn.conv2d_transpose(img, k5x5*4, tf.shape(hi), [1,2,2,1]) + hi
    return img

def normalize_std(img, eps=1e-10):
    &#39;&#39;&#39;Normalize image by making its standard deviation = 1.0&#39;&#39;&#39;
    with tf.name_scope(&#39;normalize&#39;):
        std = tf.sqrt(tf.reduce_mean(tf.square(img)))
        return img/tf.maximum(std, eps)

def lap_normalize(img, scale_n=4):
    &#39;&#39;&#39;Perform the Laplacian pyramid normalization.&#39;&#39;&#39;
    img = tf.expand_dims(img,0)
    tlevels = lap_split_n(img, scale_n)
    tlevels = list(map(normalize_std, tlevels))
    out = lap_merge(tlevels)
    return out[0,:,:,:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lap_normalize&lt;/code&gt;で画像からラプラシアンピラミッドを生成し、それぞれで正規化してからマージして元の画像に戻す処理をしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def render_lapnorm(t_obj, img0=img_noise, visfunc=visstd,
                   iter_n=10, step=1.0, octave_n=3, octave_scale=1.4, lap_n=4):
    t_score = tf.reduce_mean(t_obj) # defining the optimization objective
    t_grad = tf.gradients(t_score, t_input)[0] # behold the power of automatic differentiation!
    # build the laplacian normalization graph
    lap_norm_func = tffunc(np.float32)(partial(lap_normalize, scale_n=lap_n))

    img = img0.copy()
    for octave in range(octave_n):
        if octave&amp;gt;0:
            hw = np.float32(img.shape[:2])*octave_scale
            img = resize(img, np.int32(hw))
        for i in range(iter_n):
            g = calc_grad_tiled(img, t_grad)
            g = lap_norm_func(g)
            img += g*step
            print(&#39;.&#39;, end = &#39; &#39;)
        clear_output()
        showarray(visfunc(img))

render_lapnorm(T(layer)[:,:,:,channel])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deepdream&#34;&gt;DeepDream&lt;/h2&gt;

&lt;p&gt;で、これがDeepDreamのアルゴリズム。
ラプラシアンピラミッドを生成して、リサイズの際に次のレベルのを足していっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def render_deepdream(t_obj, img0=img_noise,
                     iter_n=10, step=1.5, octave_n=4, octave_scale=1.4):
    t_score = tf.reduce_mean(t_obj) # defining the optimization objective
    t_grad = tf.gradients(t_score, t_input)[0] # behold the power of automatic differentiation!

    # split the image into a number of octaves
    img = img0
    octaves = []
    for i in range(octave_n-1):
        hw = img.shape[:2]
        lo = resize(img, np.int32(np.float32(hw)/octave_scale))
        hi = img-resize(lo, hw)
        img = lo
        octaves.append(hi)

    # generate details octave by octave
    for octave in range(octave_n):
        if octave&amp;gt;0:
            hi = octaves[-octave]
            img = resize(img, hi.shape[:2])+hi
        for i in range(iter_n):
            g = calc_grad_tiled(img, t_grad)
            img += g*(step / (np.abs(g).mean()+1e-7))
            print(&#39;.&#39;,end = &#39; &#39;)
        clear_output()
        showarray(img/255.0)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>DeepDreaming with Tensorflowをやる(1)</title>
          <link>http://sambaiz.net/article/20/</link>
          <pubDate>Wed, 07 Sep 2016 01:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/20/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/tensorflow/tensorflow/blob/r0.10/tensorflow/examples/tutorials/deepdream/deepdream.ipynb&#34;&gt;https://github.com/tensorflow/tensorflow/blob/r0.10/tensorflow/examples/tutorials/deepdream/deepdream.ipynb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例の通りまとめながら進めていく。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;このノートブックは、畳み込みニューラルネットワークによる画像生成の手法を説明するものだ。
ネットワークは入力画像へ変換させる配列のレイヤーの集合から成り立っている。
変換のパラメータは勾配降下法で変形しながら学習していく。
内部的な画像の表現は意味不明なように見えるが、可視化し、解釈することができる。&lt;/p&gt;

&lt;h3 id=&#34;loading-and-displaying-the-model-graph&#34;&gt;Loading and displaying the model graph&lt;/h3&gt;

&lt;p&gt;学習済みネットワークのprotobufファイルが用意されていて、これをダウンロードして使う。
ただ&lt;code&gt;gcr.io/tensorflow/tensorflow&lt;/code&gt;にwgetもunzipも入っていなかったので、中に入ってapt-getした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;model_fn = &#39;tensorflow_inception_graph.pb&#39;

# creating TensorFlow session and loading the model
graph = tf.Graph()
sess = tf.InteractiveSession(graph=graph)
with tf.gfile.FastGFile(model_fn, &#39;rb&#39;) as f:
    graph_def = tf.GraphDef()
    graph_def.ParseFromString(f.read())
t_input = tf.placeholder(np.float32, name=&#39;input&#39;) # define the input tensor
imagenet_mean = 117.0
t_preprocessed = tf.expand_dims(t_input-imagenet_mean, 0)
tf.import_graph_def(graph_def, {&#39;input&#39;:t_preprocessed})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tf.gfile.FastGFile&lt;/code&gt;のドキュメントが見つからないので
&lt;a href=&#34;https://github.com/tensorflow/tensorflow/blob/568092d4507996d8aff0c46d6c57488a26596dd5/tensorflow/python/platform/gfile.py#L218&#34;&gt;ソース&lt;/a&gt;
を探したところFile I/Oのラッパーのようだ。これでprotobufファイルを読み、ParseFromStringでGraphDefにする。&lt;/p&gt;

&lt;p&gt;さらにこれと入力データを&lt;code&gt;tf.import_graph_def&lt;/code&gt;に
渡すことで&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/framework.html#import_graph_def&#34;&gt;Graphに取り込む&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tf.expand_dims&lt;/code&gt;は&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/array_ops.html#expand_dims&#34;&gt;値が1の次元を指定の場所に挿入する&lt;/a&gt;
もの。なんでそんなことをしたり、&lt;code&gt;imagenet_mean&lt;/code&gt;を引いているのかは説明がなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;layers = [op.name for op in graph.get_operations() if op.type==&#39;Conv2D&#39; and &#39;import/&#39; in op.name]
feature_nums = [int(graph.get_tensor_by_name(name+&#39;:0&#39;).get_shape()[-1]) for name in layers]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このlayersに入っているのはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import/conv2d0_pre_relu/conv
import/conv2d1_pre_relu/conv
import/conv2d2_pre_relu/conv
import/mixed3a_1x1_pre_relu/conv
import/mixed3a_3x3_bottleneck_pre_relu/conv
import/mixed3a_3x3_pre_relu/conv
import/mixed3a_5x5_bottleneck_pre_relu/conv
import/mixed3a_5x5_pre_relu/conv
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらのレイヤーのうち、&lt;code&gt;mixed4d_3x3_bottleneck_pre_relu&lt;/code&gt;を可視化してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;layer = &#39;mixed4d_3x3_bottleneck_pre_relu&#39;
channel = 139 # picking some feature channel to visualize

def T(layer):
    &#39;&#39;&#39;Helper for getting layer output tensor&#39;&#39;&#39;
    return graph.get_tensor_by_name(&amp;quot;import/%s:0&amp;quot;%layer)

render_naive(T(layer)[:,:,:,channel])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mixed4d_3x3_bottleneck_pre_relu&#39;&lt;/code&gt;は144チャンネルのフィルターで、今回はそのうち139番目のチャンネルを選んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(T(layer))
-&amp;gt; Tensor(&amp;quot;import/mixed4d_3x3_bottleneck_pre_relu:0&amp;quot;, shape=(?, ?, ?, 144), dtype=float32, device=/device:CPU:0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初期値はRGB100(グレー)にノイズを加えた画像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# start with a gray image with a little noise
img_noise = np.random.uniform(size=(224,224,3)) + 100.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スコアはそのチャンネルの値の平均で、これが高くなるように画像を変化させていく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def render_naive(t_obj, img0=img_noise, iter_n=20, step=1.0):
    t_score = tf.reduce_mean(t_obj) # defining the optimization objective
    t_grad = tf.gradients(t_score, t_input)[0] # behold the power of automatic differentiation!

    img = img0.copy()
    for i in range(iter_n):
        g, score = sess.run([t_grad, t_score], {t_input:img})
        # normalizing the gradient, so the same step size should work
        g /= g.std()+1e-8         # for different layers and networks
        img += g*step
        print(score, end = &#39; &#39;)
    clear_output()
    showarray(visstd(img))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tf.gradients(ys,xs)&lt;/code&gt;で
&lt;a href=&#34;https://www.tensorflow.org/versions/r0.10/api_docs/python/train.html#gradients&#34;&gt;xそれぞれで偏微分したyの和&lt;/a&gt;が得られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = tf.Variable(tf.constant([
            [1., 2.],
            [3., 4.]]))
b = tf.Variable(tf.constant([
            [2., 3.],
            [4., 5.]]))
c = tf.matmul(a, b)
​
grad = tf.gradients(c, a)[0]
init = tf.initialize_all_variables()
with tf.Session() as sess:
    sess.run(init)

    print(sess.run(c))
    # [[ 10.  13.]
    # [ 22.  29.]]

    print(sess.run(grad))
    # [[ 5.  9.]
    # [ 5.  9.]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力画像にこれをを加算していくと、その状態からスコアが上がるパラメータが増え、下がるパラメータが減るため、勾配を上っていくことになる。
スコアが上昇するに従って、そのフィルターによる模様が浮かんできた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/21&#34;&gt;続く&lt;/a&gt;。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Grafana/InfluxDB/Fluentdでログを可視化する</title>
          <link>http://sambaiz.net/article/19/</link>
          <pubDate>Wed, 31 Aug 2016 20:54:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/19/</guid>
          <description>

&lt;p&gt;コードは&lt;a href=&#34;https://github.com/sambaiz/grafana-influxdb-fluentd&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;influxdb-https-github-com-influxdata-influxdb&#34;&gt;&lt;a href=&#34;https://github.com/influxdata/influxdb&#34;&gt;InfluxDB&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Golangで書かれた時系列データベース。今回使うのは&lt;code&gt;v0.13&lt;/code&gt;。前のバージョンと結構違うので注意。&lt;/p&gt;

&lt;p&gt;デフォルトでは無効になっている認証を&lt;a href=&#34;https://docs.influxdata.com/influxdb/v0.13/administration/authentication_and_authorization/#set-up-authentication&#34;&gt;有効にする&lt;/a&gt;ために設定ファイルを編集して設置する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install influxdb # OSX
$ influxd config &amp;gt; influxdb.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[http]
  ...
  auth-enabled = true
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;FROM influxdb:0.13

VOLUME /var/lib/influxdb
ADD influxdb.conf /
ENV INFLUXDB_CONFIG_PATH /influxdb.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -p 8083:8083 -p 8086:8086 myinfluxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;influxd&lt;/code&gt;コマンドや
&lt;code&gt;:8083&lt;/code&gt;のWebインタフェースの他に
&lt;code&gt;:8086&lt;/code&gt;に&lt;a href=&#34;https://docs.influxdata.com/influxdb/v0.13/concepts/api/&#34;&gt;HTTP API&lt;/a&gt;が用意されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -i -XPOST http://localhost:8086/query --data-urlencode &amp;quot;q=CREATE USER root WITH PASSWORD &#39;root&#39; WITH ALL PRIVILEGES&amp;quot;

$ curl -i -XPOST http://localhost:8086/query -u root:root --data-urlencode &amp;quot;q=CREATE DATABASE mydb&amp;quot;
{&amp;quot;results&amp;quot;:[{}]}

# Line Protocol(https://docs.influxdata.com/influxdb/v0.13/write_protocols/line/)
$ curl -i -XPOST &#39;http://localhost:8086/write?db=mydb&#39; -u root:root --data-binary &#39;cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000&#39;
(204 No Content)

$ curl -GET &#39;http://localhost:8086/query?db=mydb&#39; -u root:root --data-urlencode &#39;q=SELECT * FROM &amp;quot;cpu_load_short&amp;quot;&#39; | jq
{
  &amp;quot;results&amp;quot;: [
    {
      &amp;quot;series&amp;quot;: [
        {
          &amp;quot;name&amp;quot;: &amp;quot;cpu_load_short&amp;quot;,
          &amp;quot;columns&amp;quot;: [
            &amp;quot;time&amp;quot;,
            &amp;quot;host&amp;quot;,
            &amp;quot;region&amp;quot;,
            &amp;quot;value&amp;quot;
          ],
          &amp;quot;values&amp;quot;: [
            [
              &amp;quot;2015-06-11T20:46:02Z&amp;quot;,
              &amp;quot;server01&amp;quot;,
              &amp;quot;us-west&amp;quot;,
              0.64
            ]
          ]
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fluent-plugin-influxdb-https-github-com-fangli-fluent-plugin-influxdb&#34;&gt;&lt;a href=&#34;https://github.com/fangli/fluent-plugin-influxdb&#34;&gt;fluent-plugin-influxdb&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;設定はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
  type tail
  path      /usr/src/app/test.log
  pos_file  /etc/td-agent/test.log.pos
  tag       something.log
  format    json
&amp;lt;/source&amp;gt;

&amp;lt;match *.log&amp;gt;
  @type     influxdb
  host      influxdb
  port      8086
  dbname    mydb
  user      root
  password  root
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5秒ごとにランダムな値valueのログを出力し続ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from twisted.internet import task, reactor
import logging
import json
import random

INTERVAL = 5 # sec
logging.basicConfig(filename=&#39;test.log&#39;, format=&#39;%(message)s&#39;, level=logging.INFO)

def somethingHappend():
  data = {
    &amp;quot;value&amp;quot;: random.randint(0, 100),
    &amp;quot;event&amp;quot;: &amp;quot;something&amp;quot;
  }
  logging.info(json.dumps(data))  

if __name__ == &#39;__main__&#39;:
    instance = task.LoopingCall(somethingHappend)
    instance.start(INTERVAL)
    reactor.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grafana-http-grafana-org&#34;&gt;&lt;a href=&#34;http://grafana.org/&#34;&gt;Grafana&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;可視化ツール。データソースとしてInfluxDB、Garaphite、Elasticsearchなどが使える。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://play.grafana.org/&#34;&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kibana(+Elasticsearch)だと
認証するのに&lt;a href=&#34;https://www.elastic.co/subscriptions&#34;&gt;有償&lt;/a&gt;のShieldプラグインが必要だが、
こちらは最初からできて手軽。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;これらのDockerイメージを作って、minikubeで立ち上げてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get pods
NAME                        READY     STATUS    RESTARTS   AGE
grafana-1386260931-lq8wh    1/1       Running   0          2m
influxdb-2543054961-yj1bd   1/1       Running   0          2m
testapp-532457622-269qo     1/1       Running   0          2m

$ curl -i -XPOST http://192.168.99.100:30005/query?db=mydb -u root:root --data-urlencode &#39;q=SELECT * FROM &amp;quot;something.log&amp;quot; LIMIT 1&#39;
{&amp;quot;results&amp;quot;:[{&amp;quot;series&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;something.log&amp;quot;,&amp;quot;columns&amp;quot;:[&amp;quot;time&amp;quot;,&amp;quot;event&amp;quot;,&amp;quot;value&amp;quot;],&amp;quot;values&amp;quot;:[[&amp;quot;2016-08-31T08:38:37Z&amp;quot;,&amp;quot;something&amp;quot;,23]]}]}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://192.168.99.100:30003&#34;&gt;http://192.168.99.100:30003&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;admin/adminでログインしてDataSourceに&lt;code&gt;http://192.168.99.100:30005&lt;/code&gt;のInfluxDBを設定すると、
Dashboardにグラフやテーブルなどを置いて表示させることができるようになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/19_grafana.png&#34; alt=&#34;grafanaのDashboard&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1秒以内に複数のログが発生する場合-2016-11-07&#34;&gt;1秒以内に複数のログが発生する場合 (2016-11-07)&lt;/h2&gt;

&lt;p&gt;時系列DBであるinfluxdbは同じタイムスタンプで複数のデータを持つことができない。
fluentdはv0.14からナノ秒でタイムスタンプを持つようになったので、これを利用することで1秒以内に発生するログも
正常に処理できるようになる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/32&#34;&gt;td-agentをビルドしてfluentdのバージョンを上げる&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fluent-plugin-influxdbのtime_precisionはデフォルトでs(秒)になっているが、
これをns(ナノ秒)にしただけでは、(現時点では)秒のままのタイムスタンプが送られるのでうまくいかない。
そのため、以下のようにナノ秒を取れる場合はそれを使い、そうでない場合は無視するように修正した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nstime = time * (10 ** 9) + (defined?(Fluent::EventTime) ? time.nsec : 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fangli/fluent-plugin-influxdb/pull/62&#34;&gt;プルリク&lt;/a&gt;は出した。
自分のプラグインはこんな感じで使うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;td-agent-gem install specific_install &amp;amp;&amp;amp; \
td-agent-gem specific_install https://github.com/sambaiz/fluent-plugin-influxdb.git
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>GKEで複数コンテナのアプリケーションを動かす</title>
          <link>http://sambaiz.net/article/18/</link>
          <pubDate>Fri, 26 Aug 2016 21:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/18/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/17&#34;&gt;前回&lt;/a&gt;は単一コンテナのアプリケーションを動かしたが、今回はコンテナ間でやり取りが発生するものを動かす。
流れとしては、クライアントからのリクエストを&lt;code&gt;GATEWAY&lt;/code&gt;サーバーで受け取り、&lt;code&gt;SERVICE&lt;/code&gt;サーバーにリクエストし、その結果を返すまで。&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り、環境変数&lt;code&gt;TYPE&lt;/code&gt;の値によって挙動を変えていて、同じイメージを使い回す。コードは&lt;a href=&#34;https://github.com/sambaiz/gke-multi-container-app&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var http = require(&#39;http&#39;);
var handleRequest = function(request, response) {
  if(process.env.TYPE == &amp;quot;GATEWAY&amp;quot;){
    console.log(&#39;Passed.&#39;);
    var options = {
      host: &#39;service&#39;,
      port: 8080,
      method: &#39;GET&#39;
    };
    var req = http.request(options, function(res) {
      data = &amp;quot;&amp;quot;
      res.on(&#39;data&#39;, function (chunk) {
        data+=chunk;
      });

      res.on(&#39;end&#39;, () =&amp;gt; {
        response.writeHead(200);
        response.end(data);
      });
    });
    req.on(&#39;error&#39;, function(e) {
      response.writeHead(500)
      response.end(e.message);
    });
    req.end();
  }else{
    console.log(&#39;Received.&#39;);
    response.writeHead(200);
    response.end(&#39;ok&#39;);
  }
};
var www = http.createServer(handleRequest);
www.listen(8080);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをContainer RegistryにPushする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export PROJECT_ID=&amp;quot;gcp-test-141011&amp;quot;
$ docker build -t gcr.io/$PROJECT_ID/multitest:v1 .
$ gcloud docker push gcr.io/$PROJECT_ID/multitest:v1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルで試すためにminikubeを起動。コンテキストがminikubeに設定される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ minikube start
$ kubectl config current-context
minikube
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;minikubeでContainer Registryから取得できるようにsecretを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create secret docker-registry myregistrykey --docker-server=https://gcr.io --docker-username=oauth2accesstoken --docker-password=&amp;quot;$(gcloud auth print-access-token)&amp;quot; --docker-email=***
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず、以下の&lt;code&gt;service_deployment.yaml&lt;/code&gt;でDeploymentを作成する。
envのところで環境変数&lt;code&gt;TYPE&lt;/code&gt;を&lt;code&gt;SERVICE&lt;/code&gt;に設定した。
また、先ほど作成したsecretを&lt;code&gt;imagePullSecrets&lt;/code&gt;で指定し、
ローカルのminikube環境でContainer Registryから取得できるようにしている。
同様に&lt;code&gt;gateway_deployment.yaml&lt;/code&gt;でも作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: service
  labels:
    app: service
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: service
    spec:
      containers:
      - name: service
        image: gcr.io/gcp-test-141011/multitest:v1
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
        - name: TYPE
          value: SERVICE
        ports:
        - containerPort: 8080
      imagePullSecrets:
      - name: myregistrykey    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f service_deployment.yaml
$ kubectl create -f gateway_deployment.yaml
$ kubectl get deployment
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
gateway   1         1         1            1           8m
service   1         1         1            1           28m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、これを内部から呼べるようにするためのServiceを作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: service
  labels:
    app: service
spec:
  ports:
  - port: 8080
  selector:
    app: service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GATEWAY&lt;/code&gt;の方は外に開くので、EXTERNAL IPが割り当てられるようにする。
ただ、minikubeでは&lt;code&gt;type: LoadBalancer&lt;/code&gt;に対応していないので代わりに&lt;code&gt;type: NodePort&lt;/code&gt;を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: gateway
  labels:
    app: gateway
spec:
  # type: LoadBalancer
  type: NodePort
  ports:
  - port: 8080
    nodePort: 30002
  selector:
    app: gateway
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f service_service.yaml
$ kubectl create -f gateway_service.yaml
$ kubectl get services
NAME            CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
gateway         10.0.0.176   &amp;lt;nodes&amp;gt;       8080/TCP   1h
service         10.0.0.111   &amp;lt;none&amp;gt;        8080/TCP   2d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GATEWAY&lt;/code&gt;サーバーを越えて&lt;code&gt;SERVICE&lt;/code&gt;サーバーまで到達したことが確認できた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl 192.168.99.100:30002
ok

$ kubectl get pods
NAME                       READY     STATUS    RESTARTS   AGE
gateway-3043515563-a0tb5   1/1       Running   0          38m
service-2727435432-9glvb   1/1       Running   0          38m

$ kubectl logs service-2727435432-9glvb
Received.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一通り動いたのでこんなシェルスクリプトを書いた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

context=`kubectl config current-context`
echo &amp;quot;${context}で実行します。よろしいですか[Y/N]&amp;quot;
read ANSWER
case $ANSWER in
    &amp;quot;Y&amp;quot; ) :;;
    * ) exit;;
esac
if [ $context = &amp;quot;minikube&amp;quot; ] ; then
  kubectl create -f yaml/gateway_service_minikube.yaml
  kubectl create -f yaml/service_deployment_minikube.yaml
  kubectl create -f yaml/gateway_deployment_minikube.yaml
else
  kubectl create -f yaml/gateway_service.yaml
  kubectl create -f yaml/service_deployment.yaml
  kubectl create -f yaml/gateway_deployment.yaml
fi
kubectl create -f yaml/service_service.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcloud container clusters create multi-container-app
$ kubectl config current-context
gke_gcp-test-141011_asia-east1-b_multi-container-app

$ sh create.sh
gke_gcp-test-141011_asia-east1-b_multi-container-appで実行します。よろしいですか[Y/N]
Y
service &amp;quot;gateway&amp;quot; created
deployment &amp;quot;service&amp;quot; created
deployment &amp;quot;gateway&amp;quot; created
service &amp;quot;service&amp;quot; created

$ kubectl get service
NAME         CLUSTER-IP      EXTERNAL-IP       PORT(S)    AGE
gateway      10.83.254.5     104.199.206.147   8080/TCP   4m
service      10.83.255.118   &amp;lt;none&amp;gt;            8080/TCP   4m

$ curl 104.199.206.147:8080
ok
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Google Container Engine(GKE)で単一コンテナのアプリケーションを動かす</title>
          <link>http://sambaiz.net/article/17/</link>
          <pubDate>Sun, 21 Aug 2016 23:37:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/17/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://kubernetes.io/docs/hellonode/&#34;&gt;Kubernetes - Hello World Walkthrough&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cloudsdkとkubectlのインストール&#34;&gt;CloudSDKとkubectlのインストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/sdk/#Quick_Start&#34;&gt;Cloud SDKをインストール&lt;/a&gt;して&lt;code&gt;gloud&lt;/code&gt;コマンドを使えるようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcloud --version
Google Cloud SDK 122.0.0
$ gcloud components install kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;google-container-registryにpush&#34;&gt;Google Container RegistryにPush&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ export PROJECT_ID=&amp;quot;******&amp;quot;
$ docker build -t gcr.io/$PROJECT_ID/test:v1 .
$ gcloud docker push gcr.io/$PROJECT_ID/test:v1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクトの課金を有効にしていないとこんなエラーメッセージが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;denied: Unable to create the repository, please check that you have access to do so.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clusterの作成&#34;&gt;Clusterの作成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ gcloud config set core/project $PROJECT_ID
$ gcloud config set compute/zone asia-east1-b
$ gcloud container clusters create test-cluster
$ gcloud config set container/cluster test-cluster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Container Engine APIが有効になっていない場合はこうなる。
一度コンソールからContainer Engineを選ぶと、サービスの準備が始まって有効になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: (gcloud.container.clusters.create) ResponseError: code=503, message=Project **** is not fully initialized with the default service accounts. Please try again later.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pod-とそのdeployment-の作成&#34;&gt;Pod(とそのDeployment)の作成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run test-node --image=gcr.io/$PROJECT_ID/test:v1 --port=8080
$ kubectl get deployments
NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
test-node   1         1         1            0           12s

$ kubectl get pods
NAME                         READY     STATUS              RESTARTS   AGE
test-node-1016577872-h7yiz   0/1       ContainerCreating   0          18s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serviceを作成してクラスタの外からアクセスできるようにする&#34;&gt;Serviceを作成してクラスタの外からアクセスできるようにする&lt;/h2&gt;

&lt;p&gt;デフォルトではクラスタ内からしかアクセスできない。
&lt;code&gt;--type=&amp;quot;LoadBalancer&amp;quot;&lt;/code&gt;のServiceを作成するとEXTERNAL_IPが割り当てられ、外からアクセスできるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl expose deployment test-node --type=&amp;quot;LoadBalancer&amp;quot;
$ kubectl get services test-node
NAME        CLUSTER-IP     EXTERNAL-IP       PORT(S)    AGE
test-node   10.43.247.66   104.199.158.131   8080/TCP   1m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;スケーリング&#34;&gt;スケーリング&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl scale deployment test-node --replicas=4
$ kubectl get deployment
NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
test-node   4         4         4            2           11m

$ kubectl get pods
NAME                         READY     STATUS              RESTARTS   AGE
test-node-1016577872-fso09   0/1       ContainerCreating   0          12s
test-node-1016577872-h7yiz   1/1       Running             0          11m
test-node-1016577872-sbdvl   1/1       Running             0          12s
test-node-1016577872-z9ji3   0/1       ContainerCreating   0          12s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t gcr.io/$PROJECT_ID/test:v2 .
$ gcloud docker push gcr.io/$PROJECT_ID/test:v2
$ kubectl set image deployment/test-node test-node=gcr.io/$PROJECT_ID/test:v2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;削除&#34;&gt;削除&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete service,deployment test-node
$ gcloud container clusters delete test-cluster
$ gcloud config unset container/cluster
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>JenkinsのMultiple SCMs PluginからPipeline Pluginへの移行</title>
          <link>http://sambaiz.net/article/16/</link>
          <pubDate>Sat, 20 Aug 2016 16:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/16/</guid>
          <description>&lt;p&gt;Jenkins環境を作り直すことになり、
長らく使ってきた&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Multiple+SCMs+Plugin&#34;&gt;Multiple SCMs Plugin&lt;/a&gt;がDeprecatedなので、
&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Plugin&#34;&gt;Pipeline Plugin&lt;/a&gt;に移行することにした。&lt;/p&gt;

&lt;p&gt;プラグインをインストールすると、ジョブ作成時にPipelineを選択できるようになる。
Pipeline scriptの複数リポジトリを指定するところはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node {
   stage &#39;Checkout rep1&#39;
   git([url: &#39;git@rep1.git&#39;, branch: REP1_BRANCH])

   stage &#39;Checkout rep2&#39;
   dir(&#39;rep2&#39;) {
      git([url: &#39;git@rep2.git&#39;, branch: REP2_BRANCH])
   }

   stage &#39;Checkout rep3&#39;
   dir(&#39;subdir3/rep3&#39;) {
      git([url: &#39;git@rep3.git&#39;, branch: REP3_BRANCH])
   }

   stage &#39;Build&#39;
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まとめて入った&lt;a href=&#34;https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Stage+View+Plugin&#34;&gt;Pipeline Stage View Plugin&lt;/a&gt;によって、
経過や変更などいろいろ見やすくなった。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>GolangでAPIとテストを書く(echo/dbr/glide/goose/mock)</title>
          <link>http://sambaiz.net/article/15/</link>
          <pubDate>Mon, 15 Aug 2016 04:07:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/15/</guid>
          <description>

&lt;p&gt;久々にGolangを書くことになったので、以下の記事を参考にして簡単なAPIとそのテストを書いてみた。
コードは&lt;a href=&#34;https://github.com/sambaiz/go-api-with-test&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ameblo.jp/principia-ca/entry-12130127314.html&#34;&gt;Go言語でTestableなWebアプリケーションを目指して｜サイバーエージェント 公式エンジニアブログ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使った主なライブラリ-ツール&#34;&gt;使った主なライブラリ・ツール&lt;/h2&gt;

&lt;h3 id=&#34;echo-https-github-com-labstack-echo&#34;&gt;&lt;a href=&#34;https://github.com/labstack/echo&#34;&gt;echo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;webフレームワーク。速いらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/labstack/echo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    conn, err := dbr.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:@tcp(localhost:3306)/mboard&amp;quot;, nil)
    if err != nil {
        panic(err)
    }
    conn.SetMaxIdleConns(200)
    conn.SetMaxOpenConns(200)

    e := echo.New()

    // middlewares
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{&amp;quot;*&amp;quot;},
        AllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},
    }))

    // endpoints
    e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error {
		    return c.String(http.StatusOK, &amp;quot;Hello, World!&amp;quot;)
  	})
  	e.GET(&amp;quot;/messages&amp;quot;, func(c echo.Context) error {
  		  return handler.NewMessageWithSession(conn.NewSession(nil)).GetMessages(c)
  	})
  	e.POST(&amp;quot;/messages&amp;quot;, func(c echo.Context) error {
  		  return handler.NewMessageWithSession(conn.NewSession(nil)).CreateMessage(c)
  	})
    std := standard.New(&amp;quot;:1323&amp;quot;)
    std.SetHandler(e)
    gracehttp.Serve(std.Server)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dbr-https-github-com-gocraft-dbr&#34;&gt;&lt;a href=&#34;https://github.com/gocraft/dbr&#34;&gt;dbr&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;database/sql&lt;/code&gt;を強化したもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/gocraft/dbr
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;res, err := t.sess.InsertInto(&amp;quot;message&amp;quot;).Columns(&amp;quot;content&amp;quot;).Record(model.Message{Content: content}).Exec()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;glide-https-github-com-masterminds-glide&#34;&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34;&gt;glide&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;パッケージ管理ツール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install glide
$ glide create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;glide.yaml&lt;/code&gt;が作られる。&lt;code&gt;glide get&lt;/code&gt;で&lt;code&gt;glide.yaml&lt;/code&gt;に追加していったり、
&lt;code&gt;glide install&lt;/code&gt;でvendor下にインストールしたりする。&lt;/p&gt;

&lt;h3 id=&#34;goose-https-bitbucket-org-liamstask-goose&#34;&gt;&lt;a href=&#34;https://bitbucket.org/liamstask/goose&#34;&gt;goose&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DBマイグレーションツール。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;db/dbconf.yml&lt;/code&gt;に以下のようなyamlファイルを置いて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
  driver: mymysql
  open: tcp:localhost:3306*bbs_go/root/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goose create&lt;/code&gt;でマイグレーションファイルを作成する。これはgoかsqlで書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get bitbucket.org/liamstask/goose/cmd/goose
$ goose create CreateMessages sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
-- +goose Up
-- SQL in section &#39;Up&#39; is executed when this migration is applied
CREATE TABLE message (
  id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  content TEXT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- +goose Down
-- SQL section &#39;Down&#39; is executed when this migration is rolled back
DROP TABLE message;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ goose up
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;テストの書き方&#34;&gt;テストの書き方&lt;/h2&gt;

&lt;p&gt;参考にした記事と同じく、handler, service, daoで構成し、
それぞれのコンストラクタの引数に直下のレイヤーのインタフェースを取ることでDIする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewMessage(tx dao.Tx, messageDao dao.Message) *MessageImpl {
	return &amp;amp;MessageImpl{tx: tx, messageDao: messageDao}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
テスト時には&lt;a href=&#34;https://github.com/golang/mock&#34;&gt;mock&lt;/a&gt;を渡す。
&lt;code&gt;mockgen&lt;/code&gt;でmockを生成し、以下のようにして入力と出力を指定することができる。
これによってテストでdbを参照するのがdaoだけになり、各パッケージを並行してテストできるようになる、ということが
記事に書いてあった。mockを簡単に用意できるのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/golang/mock/gomock
$ go get github.com/golang/mock/mockgen
$ mockgen -package dao -source message.go -destination message_mock.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ctl := gomock.NewController(t)
defer ctl.Finish()

message := model.Message{ID: 1, Content: &amp;quot;メッセージ&amp;quot;}
messageDaoMoc := dao.NewMockMessage(ctl)
messageDaoMoc.EXPECT().Create(message.Content).Return(int64(1), nil)
messageDaoMoc.EXPECT().FindById(message.ID).Return(&amp;amp;message, nil)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>O&#39;Reillyの「マイクロサービスアーキテクチャ」を読んだ</title>
          <link>http://sambaiz.net/article/14/</link>
          <pubDate>Sat, 06 Aug 2016 18:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/14/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873117607/&#34;&gt;O&amp;rsquo;Reilly Japan - マイクロサービスアーキテクチャ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;設計、開発、テストや監視など一通りまとまっているマイクロサービスアーキテクチャの本。&lt;/p&gt;

&lt;p&gt;マイクロサービスアーキテクチャというのは、協調して動作する小規模で自律的なサービスでシステムを構成するもので、
一般的なモノリシック(一枚岩)システムのモジュールのように独立したサービスを作っていく。
自律的というのは、他には何も変更せずに、単独でサービスの変更やデプロイを行えるということ。&lt;/p&gt;

&lt;p&gt;メリットとしては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サービスごとに異なる技術を使うことができる&lt;/li&gt;
&lt;li&gt;一部のサービスで障害が発生しても、機能低下させて稼働し続けるシステムを構築できる&lt;/li&gt;
&lt;li&gt;性能を高める必要があるサービスだけをスケールでき、効率的にリソースを使うことができる&lt;/li&gt;
&lt;li&gt;デプロイのリスクを最小限に抑えることができるため、迅速に行うことができる&lt;/li&gt;
&lt;li&gt;レガシーなコードを捨て去る障壁が低い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などが挙げられていた。&lt;/p&gt;

&lt;p&gt;正しくサービスを切り分けるにはドメインの理解が必要で、「境界づけられたコンテキスト」が1つのサービスとなるようにする。
そのため、最初はモノシリックに進めることも推奨されていた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特に初めてのドメインでは、システムをマイクロサービスに分解するのが時期尚早だとコストがかかってしまう場合があります。いろいろな意味で、マイクロサービスに分解したい既存のコードベースがある方が、最初からマイクロサービスに取り組むよりもはるかに簡単です (3.3.3)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;実現する上で、DBの扱いが難しいと思った。
サービス間のDBの共有はスキーマの変更に弱く、技術の縛りが発生してしまうので避けなければならない。
一方で、DBを分割すると1つのトランザクションで完結しなくなり、どのように整合性を保っていくか。
そんな話が5章に書いてあって、いくつか方法は挙げられているが、いずれにせよ何かしらの制御をしなくてはいけないし、
データの取得の上でも一つのデータベースにあったほうが便利だったりする。
サービスの単位がデータに引きずられてしまうと、マイクロサービスとはいえないものが出来上がりそうだ。
きれいに分けられればいいけど実際どうなんだろう。&lt;/p&gt;

&lt;p&gt;すぐにマイクロサービスを採用するかは別としても、考え方として活かせそうなことが多かった。
実際にやってみて、また読み返して自分のものにしていこうと思う。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Tensorflowの学習データを使ったAPIを作る</title>
          <link>http://sambaiz.net/article/13/</link>
          <pubDate>Fri, 05 Aug 2016 22:08:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/13/</guid>
          <description>

&lt;p&gt;チュートリアルのMNISTの学習データを使って、手書き数字画像のデータを受け取り、数字を返すAPIを作る。
コードは&lt;a href=&#34;https://github.com/sambaiz/tensorflow-use-api-sample&#34;&gt;ここ&lt;/a&gt;にある。&lt;/p&gt;

&lt;h2 id=&#34;学習して結果を保存する&#34;&gt;学習して結果を保存する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/6&#34;&gt;前回&lt;/a&gt;の学習結果のチェックポイントファイルを出力する。
&lt;code&gt;tf.train.Saver().save&lt;/code&gt;でnameで対応するVariableの値が保存できる。&lt;/p&gt;

&lt;p&gt;今回は、学習側、アプリケーション側共にPythonを使うので、以下のようなクラスを作った。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import tensorflow as tf
from tensorflow.examples.tutorials.mnist import input_data

class Mnist:

    def __init__(self):

        g = tf.Graph()

        with g.as_default():

            W_conv1 = self._weight_variable([5, 5, 1, 32],  &amp;quot;W_conv1&amp;quot;)
            b_conv1 = self._bias_variable([32],  &amp;quot;b_conv1&amp;quot;)

            self._x = tf.placeholder(tf.float32, [None, 784])
            x_image = tf.reshape(self._x, [-1,28,28,1])

            h_conv1 = tf.nn.relu(self._conv2d(x_image, W_conv1) + b_conv1)
            h_pool1 = self._max_pool_2x2(h_conv1)

            W_conv2 = self._weight_variable([5, 5, 32, 64],  &amp;quot;W_conv2&amp;quot;)
            b_conv2 = self._bias_variable([64],  &amp;quot;b_conv2&amp;quot;)

            h_conv2 = tf.nn.relu(self._conv2d(h_pool1, W_conv2) + b_conv2)
            h_pool2 = self._max_pool_2x2(h_conv2)

            W_fc1 = self._weight_variable([7 * 7 * 64, 1024],  &amp;quot;W_fc1&amp;quot;)
            b_fc1 = self._bias_variable([1024],  &amp;quot;b_fc1&amp;quot;)

            h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])
            h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)

            self._keep_prob = tf.placeholder(tf.float32)
            h_fc1_drop = tf.nn.dropout(h_fc1, self._keep_prob)

            W_fc2 = self._weight_variable([1024, 10],  &amp;quot;W_fc2&amp;quot;)
            b_fc2 = self._bias_variable([10],  &amp;quot;b_fc2&amp;quot;)

            y_conv = tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)
            self._what_number = tf.argmax(y_conv, 1)

            self._y_ = tf.placeholder(tf.float32, [None, 10])
            cross_entropy = tf.reduce_mean(-tf.reduce_sum(self._y_ * tf.log(y_conv), reduction_indices=[1]))
            self._train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)
            correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(self._y_,1))
            self._accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

            self.sess = tf.Session()
            init = tf.initialize_all_variables()
            self.sess.run(init)
            self._saver = tf.train.Saver()

    def save(self, ckpt_file_name):
        self._saver.save(self.sess, ckpt_file_name)

    def restore(self, ckpt_file_name):
        self._saver.restore(self.sess, ckpt_file_name)

    def what_number(self, image_array):
        return self.sess.run(self._what_number, feed_dict={self._x: image_array, self._keep_prob: 1.0})

    def train(self, num):
        if not hasattr(self, &amp;quot;_mnist&amp;quot;):
            self._mnist = input_data.read_data_sets(&amp;quot;MNIST_data/&amp;quot;, one_hot=True)

        for i in range(num):
            batch = self._mnist.train.next_batch(50)
            if i%100 == 0:
              train_accuracy = self._accuracy.eval(session=self.sess, feed_dict={
                      self._x:batch[0], self._y_: batch[1], self._keep_prob: 1.0
                  })
              print(&amp;quot;step %d, training accuracy %g&amp;quot;%(i, train_accuracy))
            self.sess.run(self._train_step, feed_dict={self._x: batch[0], self._y_: batch[1], self._keep_prob: 0.5})

        print(&amp;quot;test accuracy %g&amp;quot;%self._accuracy.eval(session=self.sess, feed_dict={
                self._x: self._mnist.test.images, self._y_: self._mnist.test.labels, self._keep_prob: 1.0
            }))

    def close(self):
        self.sess.close()

    def _weight_variable(self, shape, name):
      initial = tf.truncated_normal(shape, stddev=0.1)
      return tf.Variable(initial, name=name)

    def _bias_variable(self, shape, name):
      initial = tf.constant(0.1, shape=shape)
      return tf.Variable(initial, name=name)

    def _conv2d(self, x, W):
      return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&#39;SAME&#39;)

    def _max_pool_2x2(self, x):
      return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],
                            strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;train&lt;/code&gt;で学習し、&lt;code&gt;save&lt;/code&gt;でチェックポイントファイルを保存できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from mnist import Mnist

mnist = Mnist()
mnist.train(20000)
mnist.save(&amp;quot;model.ckpt&amp;quot;)
mnist.close()
print(&amp;quot;done&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なので、例えばこんなDockerfileを書いて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM gcr.io/tensorflow/tensorflow

ADD training.py /
ADD mnist.py /

CMD python /training.py &amp;amp;&amp;amp; /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しばらく待つ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t training .
$ docker run -itd training
$ docker logs -f &amp;lt;CONTAINER_ID&amp;gt;
$ docker cp &amp;lt;CONTAINER_ID&amp;gt;:/notebooks/model.ckpt .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;学習データを使う&#34;&gt;学習データを使う&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tf.train.Saver().restore&lt;/code&gt;でチェックポイントファイルを読み、Variableの値を復元できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from flask import Flask, request, jsonify
import tensorflow as tf
from mnist import Mnist

app = Flask(__name__)

mnist = Mnist()
mnist.restore(&amp;quot;/model.ckpt&amp;quot;)

@app.route(&amp;quot;/&amp;quot;, methods=[&#39;POST&#39;])
def what_number():

    json = request.json
    if(json is None or &amp;quot;image&amp;quot; not in json or len(json[&amp;quot;image&amp;quot;]) != 784):
        return jsonify(error=&amp;quot;Need json includes image property which is 784(28 * 28) length, float([0, 1.0]) array&amp;quot;)
    else:
        result = list(mnist.what_number([json[&amp;quot;image&amp;quot;]]))
        return jsonify(result=result[0])

if __name__ == &amp;quot;__main__&amp;quot;:
    app.run(port=3000, host=&#39;0.0.0.0&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これもDockerで動かすならこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM gcr.io/tensorflow/tensorflow

ADD requirements.txt /tmp
ADD model.ckpt /
ADD training/mnist.py /
ADD app.py /

RUN pip install -q -r /tmp/requirements.txt

EXPOSE 3000

CMD [&amp;quot;python&amp;quot;, &amp;quot;/app.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t tensor_api .
$ docker run -itd -p 3000:3000 tensor_app
$ docker logs -f &amp;lt;CONTAINER_ID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに以下のようにして28*28の画像のデータを渡すと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;image&amp;quot;: [ ..., 0.32941177, 0.72549021, 0.62352943, ...]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それが何の数字なのかが返ってくる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;result&amp;quot;: 7
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Googleが作ったRPCフレームワークgRPCを使ってみた</title>
          <link>http://sambaiz.net/article/12/</link>
          <pubDate>Fri, 29 Jul 2016 22:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/12/</guid>
          <description>

&lt;blockquote&gt;
&lt;p&gt;A high performance, open source, general RPC framework that puts mobile and HTTP/2 first.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;what-is-grpc-http-www-grpc-io-docs-what-is-grpc&#34;&gt;&lt;a href=&#34;http://www.grpc.io/docs/#what-is-grpc&#34;&gt;What is gRPC?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;gRPCを使うと、クライアントアプリケーションは直接、ローカルのオブジェクトのように、他のマシンのサーバーアプリケーションのメソッドを呼ぶことができ、
分散したアプリケーションやサービスを簡単に作ることができる。
多くのRPCシステムと同様に、gRPCはサービスを定義し、リモートから呼べるメソッドと、そのパラメーターおよび返り値の型を記述するようになっている。
サーバーサイドではインタフェースを実装し、クライアントからの呼び出しをハンドリングするgRPCサーバーを実行する。
クライアントサイドでは、サーバーと同じメソッドを提供するスタブを持っている。&lt;/p&gt;

&lt;p&gt;gRPCクライアントとサーバーは様々な環境同士でやり取りすることができ、いくつもの言語でサポートされている。
そのため、例えば、gRPCサーバーをJavaで、クライアントをGoやPython、Rubyで作るのも簡単だ。
加えて、最新のGoodle APIにはgRPCのインタフェースが存在するので、これらをアプリケーションに組み込むのも容易にできる。&lt;/p&gt;

&lt;h2 id=&#34;protobuf&#34;&gt;Protobuf&lt;/h2&gt;

&lt;p&gt;デフォルトではgRPCはprotobuf(protocol buffers)を使う。
&lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;というのは、
Googleによるオープンソースの、構造化されたデータをシリアライズするメカニズムだ。&lt;/p&gt;

&lt;p&gt;今回作るのは、同じ文字列を返すだけのEchoサーバーで、コードは&lt;a href=&#34;https://github.com/sambaiz/try-gRPC&#34;&gt;ここ&lt;/a&gt;にある。
以下のprotoファイルでは、&lt;code&gt;Echo&lt;/code&gt;というサービスは&lt;code&gt;RetEcho&lt;/code&gt;というメソッドを含み、
これは文字列&lt;code&gt;say&lt;/code&gt;を含む&lt;code&gt;EchoRequest&lt;/code&gt;に対して、文字列&lt;code&gt;ret&lt;/code&gt;を含む&lt;code&gt;EchoReply&lt;/code&gt;を返すということを表している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;

option java_package = &amp;quot;net.sambaiz.trygrpc.protos&amp;quot;;

package protos;

service Echo {
  rpc RetEcho (EchoRequest) returns (EchoReply) {}
}

message EchoRequest {
  string say = 1;
}

message EchoReply {
  string ret = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;code&gt;protoc&lt;/code&gt;でコンパイルすると&lt;code&gt;echo.pb.go&lt;/code&gt;のようなコードが生成される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install --devel protobuf # install Install Protocol Compiler v3.0.0-beta-2
$ go get -u github.com/golang/protobuf/protoc-gen-go # Install Go Protobuf Runtime Installation
$ protoc --go_out=plugins=grpc:protos/. protos/*.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;サーバー&#34;&gt;サーバー&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ go get google.golang.org/grpc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protoファイルに書いた、RetEchoを実装し、サーバーを立ち上げる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;golang.org/x/net/context&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;log&amp;quot;
	pb &amp;quot;github.com/sambaiz/try-gRPC/protos&amp;quot;
)

const (
	port = &amp;quot;:50051&amp;quot;
)

type server struct{}

func (s *server) RetEcho(ctx context.Context, in *pb.EchoRequest) (*pb.EchoReply, error) {
	return &amp;amp;pb.EchoReply{Ret: in.Say}, nil
}

func main() {
	lis, err := net.Listen(&amp;quot;tcp&amp;quot;, port)
	if err != nil {
		log.Fatalf(&amp;quot;failed to listen: %v&amp;quot;, err)
	}
	s := grpc.NewServer()
	pb.RegisterEchoServer(s, &amp;amp;server{})
	log.Printf(&amp;quot;server start localhost%s&amp;quot;, port)
	s.Serve(lis)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;クライアント&#34;&gt;クライアント&lt;/h2&gt;

&lt;p&gt;サーバーに接続すると、他のメソッドと同じようにサーバー側の&lt;code&gt;RetEcho&lt;/code&gt;メソッドを呼び出すことができるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;log&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
	&amp;quot;golang.org/x/net/context&amp;quot;
	pb &amp;quot;github.com/sambaiz/try-gRPC/protos&amp;quot;

)

const (
	address = &amp;quot;localhost:50051&amp;quot;
)

func main() {
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		log.Fatalf(&amp;quot;did not connect: %v&amp;quot;, err)
	}
	defer conn.Close()
	c := pb.NewEchoClient(conn)

	r, err := c.RetEcho(context.Background(), &amp;amp;pb.EchoRequest{Say: &amp;quot;hello&amp;quot;})
	if err != nil {
		log.Fatalf(&amp;quot;Error: %v&amp;quot;, err)
	}
	log.Printf(&amp;quot;Return: %s&amp;quot;, r.Ret)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新のprotoファイルを共有すれば、どんな言語で書いても自分で型を定義したり、呼び出すロジックを書く必要がないし、
インタフェースが変わったときにコードレベルでエラーに気づけるのは通常のAPIリクエストと比較しても良い点だと思う。
また、同じ理由でロジックが複数のサーバーに渡る場合の負担を最小限にできるため、サービスを小さく作る、
マイクロサービスアーキテクチャで使われる。もちろん性能や管理のしやすさなどの面でもメリット/デメリットはあるだろうし、
&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873117607/&#34;&gt;オライリー本&lt;/a&gt;を読んで勉強しようと思う。(&lt;a href=&#34;http://sambaiz.net/article/14&#34;&gt;読んだ&lt;/a&gt;)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>MySQLで大文字小文字を区別しないのを直す</title>
          <link>http://sambaiz.net/article/11/</link>
          <pubDate>Sun, 24 Jul 2016 22:12:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/11/</guid>
          <description>&lt;p&gt;Collationの話。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MySQL 5.6
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sample (
  id SERIAL,
  name VARCHAR(30)
) ENGINE=InnoDB CHARACTER SET utf8mb4;

INSERT INTO sample (name) VALUES (&#39;tom&#39;),(&#39;Tom&#39;),(&#39;TOM&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このテーブルを&amp;rdquo;tom&amp;rdquo;で絞り込むとこうなる。大文字小文字を区別していない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM sample2 WHERE name = &#39;tom&#39;;
+----+------+
| id | name |
+----+------+
|  1 | tom  |
|  2 | Tom  |
|  3 | TOM  |
+----+------+
3 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/ja/case-sensitivity.html&#34;&gt;MySQL :: MySQL 5.6 リファレンスマニュアル :: B.5.5.1 文字列検索での大文字/小文字の区別&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;単純な比較操作 (&amp;gt;=、&amp;gt;、=、&amp;lt;、&amp;lt;=、ソート、およびグループ化) は、各文字の「ソート値」に基づきます。
同じソート値を持つ文字は同じ文字として扱われます。たとえば、「e」 と 「é」 が対象の照合順序で同じソート値を持つ場合は、等しいと判断されます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.6/ja/charset-mysql.html&#34;&gt;MySQL :: MySQL 5.6 リファレンスマニュアル :: 10.1.2 MySQL での文字セットと照合順序&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;照合順序名には、関連する文字セットの名前で始まる、通常は言語名を含む、
_ci (大文字と小文字を区別しない)、_cs (大文字と小文字を区別する)、_bin (バイナリ)
のいずれかで終わる、という規則が適用されます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ciはcase-insensitive、csというのはcase-sensitiveの略だ。
照合順序(Collation)を&lt;code&gt;SHOW FULL COLUMNS FROM sample&lt;/code&gt;で確認したところ、確かに区別しない&lt;code&gt;utf8mb4_general_ci&lt;/code&gt;となっていた。
これは、文字コード&lt;code&gt;utf8mb4&lt;/code&gt;のデフォルトの照合順序だ。(&lt;code&gt;SHOW CHARACTER SET&lt;/code&gt;で確認できる)&lt;/p&gt;

&lt;p&gt;それなら&lt;code&gt;utf8mb4_general_cs&lt;/code&gt;というのがあるんだなと、&lt;code&gt;SHOW COLLATION LIKE &#39;utf8mb4%&#39;&lt;/code&gt;で確認してみたが、
そんなものはなかった。どうやら区別させるためには&lt;code&gt;utf8mb4_bin&lt;/code&gt;を使うのが正解みたいで、これをCOLLATEで指定してやるか、
カラム単位でBINARYとすると、照合順序が&lt;code&gt;utf8mb4_bin&lt;/code&gt;となり、期待通りの結果が得られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE sample2 (
  id SERIAL,
  name VARCHAR(30)
) ENGINE=InnoDB CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;

CREATE TABLE sample3 (
  id SERIAL,
  name VARCHAR(30) BINARY
) ENGINE=InnoDB CHARACTER SET utf8mb4;

ALTER TABLE sample MODIFY name VARCHAR(30) BINARY;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM sample2 WHERE name = &#39;tom&#39;;
+----+------+
| id | name |
+----+------+
|  1 | tom  |
+----+------+
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>グラフデータベースNeo4jを触ってみた</title>
          <link>http://sambaiz.net/article/10/</link>
          <pubDate>Thu, 21 Jul 2016 09:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/10/</guid>
          <description>

&lt;p&gt;社内勉強会で&lt;a href=&#34;https://github.com/neo4j/neo4j&#34;&gt;オープンソース&lt;/a&gt;の
グラフデータベース&lt;a href=&#34;https://neo4j.com/&#34;&gt;Neo4j&lt;/a&gt;が紹介されていたので触ってみた。&lt;/p&gt;

&lt;h2 id=&#34;what-is-a-graph-database-https-neo4j-com-developer-graph-database&#34;&gt;&lt;a href=&#34;https://neo4j.com/developer/graph-database/&#34;&gt;What is a Graph Database?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;つながりも含めたグラフとしてデータを扱うデータベース。
データセットのサイズによらず、複雑なつながりや、クエリをうまく扱える。
無数のデータの中から、関係ないデータを見ることなく多数のノードとつながりからなる必要なデータだけを取れる。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://neo4j.com/download/&#34;&gt;ここ&lt;/a&gt;からCommunity Editionを選んで
OSごとに用意されている実行ファイルをダウンロードしてくる。
ファイルを実行し、Startを押すとブラウザで開けるようになる。&lt;/p&gt;

&lt;h2 id=&#34;グラフ&#34;&gt;グラフ&lt;/h2&gt;

&lt;p&gt;グラフは以下の要素から構成される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node: データそのもので、まとめるためのラベルを複数付けられる&lt;/li&gt;
&lt;li&gt;Relationships: typeを持つ、Nodeのつながり&lt;/li&gt;
&lt;li&gt;Properties: NodeやRelationshipsが持てるkey-valueの値&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cypher&#34;&gt;Cypher&lt;/h2&gt;

&lt;p&gt;Neo4jで使うクエリ言語。&lt;/p&gt;

&lt;p&gt;まずはCREATE文でNodeを作る。Personはラベルだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE (ee:Person { name: &amp;quot;Emil&amp;quot;, from: &amp;quot;Sweden&amp;quot;, klout: 99 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CREATE文では使われていなかった謎のeeだが、MATCH文を見るとデータが格納される変数だということがわかる。
このeeは次のCREATE文でも参照できて、&lt;code&gt;(ee)-[:KNOWS {since: 2001}]-&amp;gt;(js)&lt;/code&gt;で
作ったNodeとのRelationshipsを張るのに使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (ee:Person) WHERE ee.name = &amp;quot;Emil&amp;quot; RETURN ee;

CREATE (js:Person { name: &amp;quot;Johan&amp;quot;, from: &amp;quot;Sweden&amp;quot;, learn: &amp;quot;surfing&amp;quot; }),
(ir:Person { name: &amp;quot;Ian&amp;quot;, from: &amp;quot;England&amp;quot;, title: &amp;quot;author&amp;quot; }),
(rvb:Person { name: &amp;quot;Rik&amp;quot;, from: &amp;quot;Belgium&amp;quot;, pet: &amp;quot;Orval&amp;quot; }),
(ally:Person { name: &amp;quot;Allison&amp;quot;, from: &amp;quot;California&amp;quot;, hobby: &amp;quot;surfing&amp;quot; }),
(ee)-[:KNOWS {since: 2001}]-&amp;gt;(js),(ee)-[:KNOWS {rating: 5}]-&amp;gt;(ir),
(js)-[:KNOWS]-&amp;gt;(ir),(js)-[:KNOWS]-&amp;gt;(rvb),
(ir)-[:KNOWS]-&amp;gt;(js),(ir)-[:KNOWS]-&amp;gt;(ally),
(rvb)-[:KNOWS]-&amp;gt;(ally)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようにパターンマッチもできる。この例だとEmilの友達が取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (ee:Person)-[:KNOWS]-(friends)
WHERE ee.name = &amp;quot;Emil&amp;quot; RETURN ee, friends
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ずしも変数に入れなくても良く、&lt;code&gt;()&lt;/code&gt;のように無視することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)
WHERE js.name = &amp;quot;Johan&amp;quot; AND surfer.hobby = &amp;quot;surfing&amp;quot;
RETURN DISTINCT surfer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最短経路を取得するのも簡単だ。&lt;code&gt;[*1..4]&lt;/code&gt;にして、ホップ数に制限をかけたり、範囲を指定したりすることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH p=shortestPath(
  (bacon:Person {name:&amp;quot;Kevin Bacon&amp;quot;})-[*]-(meg:Person {name:&amp;quot;Meg Ryan&amp;quot;})
)
RETURN p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろんSQLの&lt;code&gt;LIMIT&lt;/code&gt;や&lt;code&gt;ORDER BY&lt;/code&gt;、&lt;code&gt;GROUP BY&lt;/code&gt;相当のこともできる。
文法が直感的に分かりやすいものになっていて良いと思った。&lt;/p&gt;

&lt;h2 id=&#34;欠点&#34;&gt;欠点&lt;/h2&gt;

&lt;p&gt;とにかくSQLのJOIN地獄から脱出できそうなのが大きくて、それだけで採用したい気になってしまうが、
データの総量とは関係なく一つのNodeに大量にRelationshipsが付くと非常に遅くなるという問題があるらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cyberagent.co.jp/technology/ca_tech/report/8980456.html&#34;&gt;【CyberAgent】技術情報／TechReport - テックレポート／MongoDB de GraphDB | 株式会社サイバーエージェント&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なぜかというと隣接Node/RelationshipsのポインタをLinkedListで持っているからみたいだ。これは苦しい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://the.igreque.info/posts/2014-06-08-neo4j.html&#34;&gt;igreque : Info -&amp;gt; Neo4jについてちょちょいと調べたまとめ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;電車の路線のように一つのNodeに対して高々いくつかのRelationshipsしかつながらないことが分かっている場合には問題ないので、
そういうモデルを作るか、あるいはデータの数を絞るか、使うにあたって工夫が必要そうだ。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Kubernatesのチュートリアルをたどる</title>
          <link>http://sambaiz.net/article/9/</link>
          <pubDate>Mon, 18 Jul 2016 22:22:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/9/</guid>
          <description>

&lt;h2 id=&#34;kubernatesとは-http-kubernetes-io-docs-whatisk8s&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/whatisk8s/&#34;&gt;Kubernatesとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Kubernates(クバネテスと周りでは呼んでる。正しい発音は&lt;a href=&#34;https://cloudplatform.googleblog.com/2014/06/an-update-on-container-support-on-google-cloud-platform.html&#34;&gt;koo-ber-nay&amp;rsquo;-tace&lt;/a&gt;。
ギリシャ語で操舵手。)はアプリケーションコンテナにおける、自動デプロイ、スケーリング、操作を
自動化するオープンソースプラットフォームだ。K8sと略される。Googleによって開発が始められた。&lt;/p&gt;

&lt;h2 id=&#34;minikube-https-github-com-kubernetes-minikube&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;Minikube&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;K8sをローカルで試すためのに、MinikubeというVMの中で単一ノードのK8sクラスターを動かすツールを入れる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube/releases/tag/v0.6.0&#34;&gt;v0.6.0&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.6.0/minikube-darwin-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ minikube start
Starting local Kubernetes cluster...

...

$ kubectl version
Client Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;2&amp;quot;, GitVersion:&amp;quot;v1.2.4&amp;quot;, GitCommit:&amp;quot;3eed1e3be6848b877ff80a93da3785d9034d0a4f&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
Server Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;3&amp;quot;, GitVersion:&amp;quot;v1.3.0&amp;quot;, GitCommit:&amp;quot;283137936a498aed572ee22af6774b6fb6e9fd94&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pods-http-kubernetes-io-docs-user-guide-walkthrough-pods&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/#pods&#34;&gt;Pods&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;K8sではコンテナのグループをpodと呼ぶ。pod中のコンテナは共にデプロイされ、起動し、停止する。
また、グループとして複製される。&lt;/p&gt;

&lt;p&gt;Podの定義は以下のようにyamlで書かれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podの定義に望ましい状態を記述すると、Kubernatesはそれを見て現在の状態が一致しているかどうか確認する。
例えば、Podが作られたときに、コンテナがその中で動いている状態が望ましい状態だとすると、
コンテナが動かなくなったときに、Kubernatesは新しいものを再作成することで望ましい状態にする。&lt;/p&gt;

&lt;p&gt;podの作成とリストの取得のコマンドは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx.yaml
$ kubectl get pods
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          4s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kubectl exec&lt;/code&gt;で&lt;a href=&#34;http://kubernetes.io/docs/user-guide/getting-into-containers/&#34;&gt;コマンドを実行&lt;/a&gt;し、
podが動いていることを確認しようとしたが、使えそうなコマンドが見つからなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl exec -it nginx ps
rpc error: code = 2 desc = &amp;quot;oci runtime error: exec failed: exec: \&amp;quot;ps\&amp;quot;: executable file not found in $PATH&amp;quot;error: error executing remote command: error executing command in container: Error executing in Docker Container: 126
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、リクエストを投げるために&lt;code&gt;kubectl run&lt;/code&gt;で&lt;a href=&#34;http://kubernetes.io/docs/user-guide/kubectl/kubectl_run/&#34;&gt;イメージを動かす単一コンテナのpodを管理するためのDeploymentを作成する。&lt;/a&gt;
Deploymentについては後で説明がある。
&lt;code&gt;--restart=Never&lt;/code&gt;でpodが存在しなくなったときに再起動しないようにし、&lt;code&gt;--env&lt;/code&gt;で環境変数としてnginxのpodのIPを渡している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run busybox --image=busybox --restart=Never --tty -i --env &amp;quot;POD_IP=$(kubectl get pod nginx -o go-template={{.status.podIP}})&amp;quot;
busybox$ wget -qO- http://$POD_IP
busybox$ exit # Exit the busybox container

$ kubectl get deployments

$ kubectl get pods
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          54m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--restart=Never&lt;/code&gt;なしで実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run busybox --image=busybox --tty -i --env &amp;quot;POD_IP=$(kubectl get pod nginx -o go-template={{.status.podIP}})&amp;quot;
busybox$ exit
Session ended, resume using &#39;kubectl attach busybox-985443498-9elny -c busybox -i -t&#39; command when the pod is running

$ kubectl get deployments
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
busybox   1         1         1            1           3m

$ kubectl get pods
NAME                      READY     STATUS    RESTARTS   AGE
busybox-985443498-9elny   1/1       Running   1          3m
nginx                     1/1       Running   0          59m

$ kubectl delete pods busybox-985443498-9elny
pod &amp;quot;busybox-985443498-9elny&amp;quot; deleted

$ kubectl get pods # Podsだけ削除しても新しいものが立ち上がってくる
NAME                      READY     STATUS              RESTARTS   AGE
busybox-985443498-4iyvx   0/1       ContainerCreating   0          1s
busybox-985443498-9elny   1/1       Terminating         1          13m
nginx                     1/1       Running             0          1h

$ kubectl delete deployment busybox

$ kubectl get pods # Deploymentを削除するとPodsも消える
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          1h
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;volumes-http-kubernetes-io-docs-user-guide-walkthrough-volumes&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/#volumes&#34;&gt;Volumes&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;コンテナのファイルシステムはコンテナが生存しているときに限り有効なので、
永続化したいデータはコンテナの外に保存する必要がある。&lt;/p&gt;

&lt;p&gt;以下の例のように&lt;code&gt;volumes&lt;/code&gt;でvolumeを定義し、&lt;code&gt;volumeMounts&lt;/code&gt;でどこにマウントするか指定することができる。
&lt;code&gt;volumes&lt;/code&gt;には、そのPodがノードで実行されている間存在するディレクトリを作成して使う&lt;code&gt;EmptyDir&lt;/code&gt;か、
ノードのファイルシステムに既に存在するディレクトリを使う&lt;code&gt;HostPath&lt;/code&gt;を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis
    volumeMounts:
    - name: redis-persistent-storage
      mountPath: /data/redis
  volumes:
  - name: redis-persistent-storage
    emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;labels-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-labels&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#labels&#34;&gt;Labels&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;metadataとしてkey-valueのラベルを付けることができる。たくさんのPodをまとめたりするのに便利だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;metadata:
  name: nginx
  labels:
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;kubectl get pods -l app=nginx
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deployments-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-deployments&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#deployments&#34;&gt;Deployments&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;実行しているPodの維持と更新を管理するのが、上でも出てきたDeploymentだ。
Deploymentの定義には、Podを作るためのテンプレートと、維持するPod数を記述する。
pod名はDeployment名から生成されるので、templateには含めない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f deployment.yaml
$ kubectl get deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2         2         2            2           3m

$ kubectl get pods -l app=nginx
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1159050644-ar3i7   1/1       Running   0          3m
nginx-deployment-1159050644-kdjly   1/1       Running   0          3m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kubectl apply&lt;/code&gt;でDeploymentは変更を実行中のPodに安全にロールアウトする。
以下の例ではnginxのバージョンを上げている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.8
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f deployment-update.yaml
$ kubectl get pods
NAME                                READY     STATUS              RESTARTS   AGE
nginx-deployment-1159050644-kdjly   1/1       Running             0          30m
nginx-deployment-1771418926-pi3vy   0/1       ContainerCreating   0          7s
nginx-deployment-1771418926-ygoxl   0/1       ContainerCreating   0          7s

$ kubectl get pods
NAME                                READY     STATUS              RESTARTS   AGE
nginx-deployment-1771418926-pi3vy   0/1       ContainerCreating   0          12s
nginx-deployment-1771418926-ygoxl   1/1       Running             0          12s

$ kubectl get pods
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1771418926-pi3vy   1/1       Running   0          15s
nginx-deployment-1771418926-ygoxl   1/1       Running   0          15s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;services-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-services&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#services&#34;&gt;Services&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;アプリケーションのレイヤー間(例えばフロントエンドとバックエンド)の接続で使われるのがServiceだ。
以下のServiceは、8080番ポートで待ち、&lt;code&gt;app: nginx&lt;/code&gt;のラベルが付いているPodの80番ポートに向けるロードバランサーとして働く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  ports:
  - port: 8000
    targetPort: 80
    protocol: TCP
  selector:
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f service.yaml
$ kubectl get services
NAME            CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
kubernetes      10.0.0.1     &amp;lt;none&amp;gt;        443/TCP    19h
nginx-service   10.0.0.90    &amp;lt;none&amp;gt;        8000/TCP   36s

$ export SERVICE_IP=$(kubectl get service nginx-service -o go-template=&#39;{{.spec.clusterIP}}&#39;)
$ export SERVICE_PORT=$(kubectl get service nginx-service -o go-template=&#39;{{(index .spec.ports 0).port}}&#39;)
$ echo &amp;quot;$SERVICE_IP:$SERVICE_PORT&amp;quot;
10.0.0.90:8000
$ kubectl run busybox --image=busybox --restart=Never --tty -i --env &amp;quot;SERVICE_IP=$SERVICE_IP,SERVICE_PORT=$SERVICE_PORT&amp;quot;
busybox$ wget -qO- http://$SERVICE_IP:$SERVICE_PORT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;health-checking-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-health-checking&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#health-checking&#34;&gt;Health Checking&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;livenessProbe&lt;/code&gt;でヘルスチェックの設定を含めることができる。
以下の例では、初期化のために30秒待った後、&lt;code&gt;/_status/healthz&lt;/code&gt;へのHTTP GETリクエストに対して
200~399以外のステータスコードが返るか、1秒以上かかった場合、コンテナを再起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: pod-with-healthcheck
spec:
  containers:
  - name: nginx
    image: nginx
    livenessProbe:
      httpGet:
        path: /_status/healthz
        port: 80
      initialDelaySeconds: 30
      timeoutSeconds: 1
    ports:
    - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのバージョン管理</title>
          <link>http://sambaiz.net/article/8/</link>
          <pubDate>Fri, 15 Jul 2016 19:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/8/</guid>
          <description>

&lt;h2 id=&#34;nvm-https-github-com-creationix-nvm&#34;&gt;&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;大体これを使っておけばよさそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash
$ nvm install node
$ node -v
v7.7.2

$ nvm install 6
$ node -v
v6.10.0

$ nvm ls
        v6.10.0
-&amp;gt;       v7.7.2
default -&amp;gt; node (-&amp;gt; v7.7.2)
node -&amp;gt; stable (-&amp;gt; v7.7.2) (default)
stable -&amp;gt; 7.7 (-&amp;gt; v7.7.2) (default)
iojs -&amp;gt; N/A (default)
lts/* -&amp;gt; lts/boron (-&amp;gt; v6.10.0)
lts/argon -&amp;gt; v4.8.0 (-&amp;gt; N/A)
lts/boron -&amp;gt; v6.10.0

$ nvm use node
Now using node v7.7.2 (npm v4.1.2)

$ nvm use 6
Now using node v6.10.0 (npm v3.10.10)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-https-github-com-tj-n&#34;&gt;&lt;a href=&#34;https://github.com/tj/n&#34;&gt;n&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;すでにnodeが入っているならこっちを使うこともできる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n latest&lt;/code&gt;, &lt;code&gt;n stable&lt;/code&gt;, &lt;code&gt;n lts&lt;/code&gt;でバージョンが切り替わる。
バージョンを指定する場合、&lt;code&gt;n &amp;lt;version&amp;gt;&lt;/code&gt;でインストールし、&lt;code&gt;n&lt;/code&gt;でインストールされているバージョンの一覧から選択できる。
バージョンの削除は&lt;code&gt;n - &amp;lt;version&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g n
$ n stable
$ node -v
v6.2.2
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Docker公式ドキュメント&#34;network コマンドを使う&#34;を読む</title>
          <link>http://sambaiz.net/article/7/</link>
          <pubDate>Fri, 15 Jul 2016 00:38:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/7/</guid>
          <description>&lt;pre&gt;&lt;code&gt;Docker version 1.12.0-rc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公式ドキュメント&lt;a href=&#34;http://docs.docker.jp/engine/userguide/networking/work-with-networks.html&#34;&gt;network コマンドを使う&lt;/a&gt;
の内容をまとめてみた。&lt;/p&gt;

&lt;p&gt;dockerには3つのデフォルトネットワークが存在する。&lt;code&gt;docker run&lt;/code&gt;時に&lt;code&gt;--net&lt;/code&gt;オプションでネットワークを指定しない限り、
docker0として表示されるbridgeネットワークにコンテナを接続する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
a3b712537566        bridge              bridge              local               
f6d86cb54edd        host                host                local               
33cb30b024d9        none                null                local            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、後方互換性を維持するため、デフォルトのbridgeネットワークでは自動的に名前解決が行われない。&lt;/p&gt;

&lt;p&gt;これらのネットワークとは別にユーザー定義のネットワークを作成することもできる。
単一ホストの&lt;code&gt;bridge&lt;/code&gt;ネットワークと、複数ホストにまたがる&lt;code&gt;overlay&lt;/code&gt;ネットワークから選択でき、
何も指定しなかったら&lt;code&gt;bridge&lt;/code&gt;になる。&lt;code&gt;subnet&lt;/code&gt;を指定しなければ、
dockerデーモンがネットワークに対してサブネットを自動的に割り当てるが、
dockerが管理していないサブネットと重複するのを避けるために指定することが推奨されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker network create -d bridge --subnet 172.25.0.0/16 isolated_nw
$ docker network inspect isolated_nw
$ docker network rm isolated_nw  # 削除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;docker network inspect&lt;/code&gt;で以下のようなネットワークの情報が得られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {
        &amp;quot;Name&amp;quot;: &amp;quot;isolated_nw&amp;quot;,
        &amp;quot;Id&amp;quot;: &amp;quot;c81547cf7ed897054ea645192c6c47dcf7a248e77bc8067609becab5330e417d&amp;quot;,
        &amp;quot;Scope&amp;quot;: &amp;quot;local&amp;quot;,
        &amp;quot;Driver&amp;quot;: &amp;quot;bridge&amp;quot;,
        &amp;quot;EnableIPv6&amp;quot;: false,
        &amp;quot;IPAM&amp;quot;: {
            &amp;quot;Driver&amp;quot;: &amp;quot;default&amp;quot;,
            &amp;quot;Options&amp;quot;: {},
            &amp;quot;Config&amp;quot;: [
                {
                    &amp;quot;Subnet&amp;quot;: &amp;quot;172.25.0.0/16&amp;quot;
                }
            ]
        },
        &amp;quot;Internal&amp;quot;: false,
        &amp;quot;Containers&amp;quot;: {},
        &amp;quot;Options&amp;quot;: {},
        &amp;quot;Labels&amp;quot;: {}
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動時に&lt;code&gt;--net&lt;/code&gt;オプションでネットワークに接続したり、
既に存在するコンテナを&lt;code&gt;docker network connect&lt;/code&gt;で接続することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=isolated_nw -itd --name=container1 --link container2:c2 busybox
$ docker network connect isolated_nw container1
$ docker network disconnect isolated_nw container1 # 切断
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の&lt;code&gt;run&lt;/code&gt;によって同一ネットワークからこのコンテナへ、&lt;code&gt;ping container1&lt;/code&gt;が届くようになり、
このコンテナから同一ネットワークのconteiner2にc2というエイリアスが付くため、&lt;code&gt;ping c2&lt;/code&gt;が届くようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker attach container1
# ping c2
PING c2 (172.25.0.2): 56 data bytes
64 bytes from 172.25.0.2: seq=0 ttl=64 time=0.094 ms
...
CTRL-p CTRL-q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定時点でcontainer2が存在しなかったとしてもエラーにならない。
また、この&lt;code&gt;--link&lt;/code&gt;によるエイリアスは所属するネットワーク全体に適用される。&lt;/p&gt;

&lt;p&gt;他にrunで指定している&lt;a href=&#34;http://docs.docker.jp/engine/reference/commandline/run.html&#34;&gt;オプション&lt;/a&gt;は以下の通り。
どれも良く使うもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-i コンテナの STDIN にアタッチ
-t 疑似ターミナル (pseudo-TTY) を割り当てる
-d コンテナをバックグラウンドで実行し、コンテナIDを表示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--link&lt;/code&gt;は、コンテナ内におけるプライベートな名前解決のために、他のコンテナの&lt;code&gt;name&lt;/code&gt;に対してエイリアスを付けるものだったが、
これとは別に同一ネットワークの他のコンテナからの名前解決のために使われる、ネットワーク範囲のエイリアスを&lt;code&gt;--net-alias&lt;/code&gt;で付けることができる。
このエイリアスは同一ネットワークの複数のコンテナで同じものに設定でき、有効ないずれかのコンテナに名前解決される。
つまり、コンテナが停止するかネットワークから切断されると、同じネットワーク範囲のエイリアスを持った別のコンテナに名前解決されることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=isolated_nw -itd --name=container3 --net-alias app busybox
$ docker run --net=isolated_nw -itd --name=container4 --net-alias app busybox
$ docker network connect --alias app isolated_nw container5 # connectで指定するとき
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>TensorFlow チュートリアル2(Deep MNIST for Experts)</title>
          <link>http://sambaiz.net/article/6/</link>
          <pubDate>Tue, 12 Jul 2016 21:16:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/6/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/3&#34;&gt;前回&lt;/a&gt;に引き続き、まとめながら進めていく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/tutorials/mnist/pros/index.html&#34;&gt;Deep MNIST for Experts&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;start-tensorflow-interactivesession&#34;&gt;Start TensorFlow InteractiveSession&lt;/h3&gt;

&lt;p&gt;今回は、前回のようにグラフを作成してからSessionを開始する代わりに
&lt;code&gt;InteractiveSession&lt;/code&gt;を使う。
グラフを作成し実行するのをインタラクティブに行うことができ、IPythonのような環境で便利だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import tensorflow as tf
sess = tf.InteractiveSession()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;build-a-multilayer-convolutional-network&#34;&gt;Build a Multilayer Convolutional Network&lt;/h3&gt;

&lt;p&gt;前回のシンプルなモデルでは、あまり良い結果が出なかった。
そこで、今回はもう少し洗練されたモデル、小さな畳み込みニューラルネットワークを作成する。&lt;/p&gt;

&lt;h3 id=&#34;weight-initialization&#34;&gt;Weight Initialization&lt;/h3&gt;

&lt;p&gt;このモデルを作成するためには、たくさんの重みとバイアスを作成する必要がある。&lt;/p&gt;

&lt;p&gt;重みは、対称性を破り、勾配0を避けるために、少しのノイズで初期化すべきだ。&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%B4%BB%E6%80%A7%E5%8C%96%E9%96%A2%E6%95%B0#ReLU.EF.BC.88.E3.83.A9.E3.83.B3.E3.83.97.E9.96.A2.E6.95.B0.EF.BC.89&#34;&gt;ReLU(Rectified Linear Unit, 正規化線形関数)&lt;/a&gt;ニューロンを使うので、&amp;rdquo;死んだニューロン&amp;rdquo;を避けるためにわずかな正の値のバイアスで初期化すると良い。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tf.truncated_normal&lt;/code&gt;は&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/api_docs/python/constant_op.html#truncated_normal&#34;&gt;正規分布で、μ±2σ範囲内のランダムな値を返す。&lt;/a&gt;
以下の例だと、&lt;code&gt;mean&lt;/code&gt;のデフォルトが0.0なので、正規分布 &lt;code&gt;N(0, 0.01)&lt;/code&gt;の、&lt;code&gt;-0.2&amp;lt;=x&amp;lt;=0.2&lt;/code&gt;な値がランダムに返ることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def weight_variable(shape):
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)

def bias_variable(shape):
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;convolution-and-pooling&#34;&gt;Convolution and Pooling&lt;/h3&gt;

&lt;p&gt;TensorFlowは柔軟な畳み込みとプーリングの手続きを提供している。&lt;/p&gt;

&lt;p&gt;畳み込みというのは、画像に対してフィルターを少しずつ動かしながら掛けていく処理のことだ。&lt;a href=&#34;http://www.clg.niigata-u.ac.jp/~medimg/practice_medical_imaging/imgproc_scion/4filter/index.htm&#34;&gt;このページ&lt;/a&gt;が分かりやすい。
例えば、&lt;a href=&#34;https://en.wikipedia.org/wiki/Sobel_operator&#34;&gt;ソーベルフィルタ&lt;/a&gt;で輪郭になっているところを抽出するように、
フィルターの値によって、その区域における、ある特徴を際立たせたりすることができる。
今回はこのフィルターが重みとなり、際立たせたいのはその数字を識別するための特徴ということになる。
前回は画像を一次元の配列として扱い重みを学習していたので、縦の情報が失われていたが、この方法ではそれがない。&lt;/p&gt;

&lt;p&gt;プーリングというのは画像から区域ごとにサンプリングする処理だ。最大プーリングや、平均プーリングなどの手法がある。
畳み込みのように順番に区域を見ていって、最大プーリングならそのうちの最大のものを採用し、他のものは無視する。
サイズが小さくなるだけではなく、ちょっとした位置のずれを吸収することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def conv2d(x, W):
  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&#39;SAME&#39;)

def max_pool_2x2(x):
  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],
                        strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;は&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/api_docs/python/nn.html#conv2d&#34;&gt;畳み込みを行う。&lt;/a&gt;
主な入力は&lt;code&gt;[画像の数, 縦サイズ, 横サイズ, チャンネル数(色とか)]&lt;/code&gt;の画像と、
&lt;code&gt;[縦サイズ, 横サイズ, 入力チャンネル数, 出力チャンネル数]&lt;/code&gt;のフィルターだ。
&lt;code&gt;strides&lt;/code&gt;は一度にどれくらいフィルターを動かしていくかで、&lt;code&gt;strides[1]&lt;/code&gt;が縦、&lt;code&gt;strides[2]&lt;/code&gt;が横に動かす量だ。
&lt;code&gt;strides[0]&lt;/code&gt;と&lt;code&gt;strides[3]&lt;/code&gt;は1でなくてはならない。
&lt;code&gt;padding&lt;/code&gt;は&amp;rdquo;SAME&amp;rdquo;か&amp;rdquo;VALID&amp;rdquo;から選択できるパディングについての設定だ。詳細は
&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/api_docs/python/nn.html#convolution&#34;&gt;ここ&lt;/a&gt;
に書いてある。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tf.nn.max_pool&lt;/code&gt;は&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/api_docs/python/nn.html#max_pool&#34;&gt;最大プーリングを行う。&lt;/a&gt;
&lt;code&gt;ksize&lt;/code&gt;は入力のそれぞれの次元に対応した見ていく区域のサイズだ。&lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;ならそれぞれの画像を&lt;code&gt;2*2&lt;/code&gt;ずつ見ていくことになる。&lt;/p&gt;

&lt;h3 id=&#34;first-convolutional-layer&#34;&gt;First Convolutional Layer&lt;/h3&gt;

&lt;p&gt;最初のレイヤーは、畳み込みと最大プーリングで構成される。
畳み込みはそれぞれ&lt;code&gt;5*5&lt;/code&gt;の32チャンネル出力のフィルターでされる。
つまり、重みであるフィルターは&lt;code&gt;[5, 5, 1, 32]&lt;/code&gt;のtensorということになる。
そして、それぞれのチャンネルに対してバイアスが存在する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W_conv1 = weight_variable([5, 5, 1, 32])
b_conv1 = bias_variable([32])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画像に対して、畳み込みを適用するするために&lt;code&gt;tf.reshape&lt;/code&gt;で
&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/api_docs/python/array_ops.html#reshape&#34;&gt;変形する&lt;/a&gt;
必要がある。-1というのは特別な値で、他の次元との積が合計が元のものと変わらないように決定される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = tf.placeholder(tf.float32, [None, 784])
x_image = tf.reshape(x, [-1,28,28,1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで畳み込めるようになったので、画像と重みを畳み込み、バイアスを足したものにReLUを適用した後、最大プーリングする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)
h_pool1 = max_pool_2x2(h_conv1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;second-convolutional-layer&#34;&gt;Second Convolutional Layer&lt;/h3&gt;

&lt;p&gt;deepネットワークにするために最初のレイヤーのようなものをいくつか重ねる。
2番目のレイヤーでは64チャンネル出力のフィルターで畳み込みを行い、プーリングする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W_conv2 = weight_variable([5, 5, 32, 64])
b_conv2 = bias_variable([64])

h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)
h_pool2 = max_pool_2x2(h_conv2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;densely-connected-layer&#34;&gt;Densely Connected Layer&lt;/h3&gt;

&lt;p&gt;2つのレイヤーを経て元々&lt;code&gt;28*28&lt;/code&gt;だった画像は&lt;code&gt;7*7&lt;/code&gt;にまで削減された。
2つめのレイヤーの出力は64チャンネルだったので、&lt;code&gt;7*7*64&lt;/code&gt;次元のデータになっている。
このレイヤーでは、これらにそれぞれ1024のニューロンを結びつける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W_fc1 = weight_variable([7 * 7 * 64, 1024])
b_fc1 = bias_variable([1024])

h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])
h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dropout&#34;&gt;Dropout&lt;/h3&gt;

&lt;p&gt;過学習を防ぐために
&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%83%A9%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0#.E3.83.89.E3.83.AD.E3.83.83.E3.83.97.E3.82.A2.E3.82.A6.E3.83.88&#34;&gt;ドロップアウト&lt;/a&gt;
を行う。
ドロップアウトというのは訓練データごとにニューロンを何割か無視することだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keep_prob = tf.placeholder(tf.float32)
h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;readout-layer&#34;&gt;Readout Layer&lt;/h3&gt;

&lt;p&gt;最後にsoftmaxでそれぞれの数字である確率を求める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;W_fc2 = weight_variable([1024, 10])
b_fc2 = bias_variable([10])

y_conv=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;train-and-evaluate-the-model&#34;&gt;Train and Evaluate the Model&lt;/h3&gt;

&lt;p&gt;今回は前回使った&lt;code&gt;GradientDescentOptimizer&lt;/code&gt;よりも洗練されている&lt;code&gt;AdamOptimizer&lt;/code&gt;というのが使われている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y_ = tf.placeholder(tf.float32, [None, 10])
cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y_conv), reduction_indices=[1]))
train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)
correct_prediction = tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
sess.run(tf.initialize_all_variables())
for i in range(20000):
  batch = mnist.train.next_batch(50)
  if i%100 == 0:
    train_accuracy = accuracy.eval(feed_dict={
        x:batch[0], y_: batch[1], keep_prob: 1.0})
    print(&amp;quot;step %d, training accuracy %g&amp;quot;%(i, train_accuracy))
  train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})

print(&amp;quot;test accuracy %g&amp;quot;%accuracy.eval(feed_dict={
    x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行するとこんな出力が得られた。
かなり時間がかかったのでここで打ち切ったが、およそ99.2%の正解率になるらしい。
前回が92%だったのに比べてもすごく良い値に見える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step 0, training accuracy 0.12
step 100, training accuracy 0.8
step 200, training accuracy 0.9
step 300, training accuracy 0.9
step 400, training accuracy 0.98
step 500, training accuracy 0.88
step 600, training accuracy 0.98
step 700, training accuracy 0.98
step 800, training accuracy 0.9
step 900, training accuracy 1
step 1000, training accuracy 0.98
step 1100, training accuracy 0.98
step 1200, training accuracy 1
step 1300, training accuracy 0.98
step 1400, training accuracy 0.94
step 1500, training accuracy 0.98
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>webpack環境でredux&amp;react-routerのページをサーバーサイドレンダリングする</title>
          <link>http://sambaiz.net/article/5/</link>
          <pubDate>Sun, 10 Jul 2016 03:08:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/5/</guid>
          <description>&lt;p&gt;このページをGoogleのSearch Consoleからクローラーがちゃんと見ているか確認してみたら、
なぜか真っ白のページが表示されていた・・・。とりあえずサーバーサイドレンダリングしてみることにした。
コードは&lt;a href=&#34;https://github.com/sambaiz/sambaiz.net/tree/v0.23&#34;&gt;github&lt;/a&gt;に上げてある。&lt;/p&gt;

&lt;p&gt;サーバーサイドとはいえ、css-loaderでcss moduleを使っているのでwebpackを使う必要があった。
まず、そのままのwebpackの設定で作ったものをserver.jsから呼ぶとエラーが出た。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;***/sambaiz-net/web/public/bundle.js:20933
	module.exports = self.fetch.bind(self);
ReferenceError: self is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、targetをnodeにしたサーバーサイド用にwebpackの設定を作成し、実行してみたところ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = {
	entry: &#39;./js/server.js&#39;,
	target: &#39;node&#39;,
	output: {
		path: path.join(__dirname, &#39;dist&#39;),
		filename: &#39;server.js&#39;,
		publicPath: &#39;/&#39;
	},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今度はこんなエラーが出たので&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR in ./~/iconv-lite/encodings/tables/gb18030-ranges.json
Module parse failed: ***/sambaiz-net/web/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json Unexpected token (1:9)
You may need an appropriate loader to handle this file type.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loadersに下の設定を追加した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ test: /\.json$/, loader: &amp;quot;json-loader&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpackには成功したが、serverを起動すると今度は以下のようなエラーが出た。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
ReferenceError: window is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;style-loaderのコードだったので、
まず、フロント側のwebpackで
&lt;a href=&#34;https://github.com/webpack/extract-text-webpack-plugin&#34;&gt;extract-text-webpack-plugin&lt;/a&gt;を使ってcssを別に出力することにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);
...
{
  test: /\.css$/,
  loader:  ExtractTextPlugin.extract(&#39;style&#39;, &#39;css?modules&#39;, &#39;postcss&#39;),
  include: __dirname
},
...
plugins: [
    new ExtractTextPlugin(&amp;quot;styles.css&amp;quot;)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、サーバー側のwebpackでは&lt;a href=&#34;https://github.com/kriasoft/isomorphic-style-loader&#34;&gt;isomorphic-style-loader&lt;/a&gt;でなんとか動かして、
フロント側で出力したcssと対応するようにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loaders: [&#39;isomorphic-style&#39;, &#39;css?modules&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでようやくwebpackまわりの問題は解決できたので、react-routerの方のコードを書いていく。&lt;/p&gt;

&lt;p&gt;reduxに関しては&lt;a href=&#34;http://redux.js.org/docs/recipes/ServerRendering.html&#34;&gt;ドキュメント&lt;/a&gt;通りに
描画した後のstoreをこんな感じでフロントに渡す。
そのほかに、同じ処理をサーバーとフロントで二度行わないようにするための値を追加する必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.__INITIAL_STATE__ = ${JSON.stringify(state)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;react-routerも以下のようにmatchとRouterContextを組み合わせるだけだ。
ただし、APIリクエスト等の非同期処理が含まれているので、レンダリングが完了したかどうか判断しなくてはならない。
そのため、storeの状態をsubscribeしてレンダリングの終了判定を都度チェックしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function render(req, res, isFinishLoading, title, description, fullUrl) {

  match({ routes, location: req.url }, (error, redirectLocation, renderProps) =&amp;gt; {

    let store = createStore();

    if (error) {
      res.status(500).send(error.message)
    } else if (redirectLocation) {
      res.redirect(302, redirectLocation.pathname + redirectLocation.search)
    } else if (renderProps) {

      const _render = () =&amp;gt;
        renderToString(&amp;lt;Provider store={store}&amp;gt;
          &amp;lt;RouterContext {...renderProps} /&amp;gt;
        &amp;lt;/Provider&amp;gt;)

      let unscribe = store.subscribe(() =&amp;gt; {
        if(isFinishLoading(store.getState()) === true){
          res.status(200).send(
            page(_render(), store.getState(), title, description, fullUrl)
          )
          unscribe();
        }
      })

      _render();

    } else {
      res.status(404).send(&#39;Not found&#39;)
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>MySQLのUNIX_TIMESTAMPにある程度未来の日付を渡すと0になる</title>
          <link>http://sambaiz.net/article/4/</link>
          <pubDate>Mon, 04 Jul 2016 19:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/4/</guid>
          <description>&lt;p&gt;以下、MySQL5.6で遭遇した。&lt;/p&gt;

&lt;p&gt;MySQLの&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/ja/date-and-time-functions.html#function_unix-timestamp&#34;&gt;UNIX_TIMESTAMP&lt;/a&gt;は
DATETIME文字列などを引数にとり、UNIXタイムスタンプ(1970-01-01 00:00:00 UTCを起点とした経過秒数)を返す関数だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET SESSION time_zone = &#39;UTC&#39;;
mysql&amp;gt; select UNIX_TIMESTAMP(&#39;1970-01-01 00:00:00&#39;);
+---------------------------------------+
| UNIX_TIMESTAMP(&#39;1970-01-01 00:00:00&#39;) |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、2038年1月19日3時14分7秒(UTC)以降を渡すと0になってしまう。
これはドキュメントにも書いてある通り範囲外だから。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select UNIX_TIMESTAMP(&#39;2038-01-19-03-14-07&#39;);
+---------------------------------------+
| UNIX_TIMESTAMP(&#39;2038-01-19-03-14-07&#39;) |
+---------------------------------------+
|                            2147483647 |
+---------------------------------------+
1 row in set (0.04 sec)

mysql&amp;gt; select UNIX_TIMESTAMP(&#39;2038-01-19-03-14-08&#39;);
+---------------------------------------+
| UNIX_TIMESTAMP(&#39;2038-01-19-03-14-08&#39;) |
+---------------------------------------+
|                                     0 |
+---------------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では、この境目は何かというと、32ビットで表せる符号付数値の最大値だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 2 ** 31
=&amp;gt; 2147483648
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはMySQLに限らず、&lt;a href=&#34;https://ja.wikipedia.org/wiki/2038%E5%B9%B4%E5%95%8F%E9%A1%8C&#34;&gt;2038年問題&lt;/a&gt;と呼ばれているもので、
DATETIME型は&amp;rsquo;9999-12-31&amp;rsquo;までサポートしているのでこれ以降も表すことはできるが、&lt;code&gt;UNIX_TIMESTAMP&lt;/code&gt;しても正しい値は得られなくなる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>TensorFlow チュートリアルまで</title>
          <link>http://sambaiz.net/article/3/</link>
          <pubDate>Sun, 03 Jul 2016 23:37:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/3/</guid>
          <description>

&lt;p&gt;Googleが公開した人工知能ライブラリTensorFlowを使ってみる。
&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/get_started/os_setup.html&#34;&gt;セットアップ&lt;/a&gt;方法はいくつか提供されているが、Dockerで動かすことにした。
Jupyter Notebookが立ち上がるのですぐに試せて良い。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -it -p 8888:8888 gcr.io/tensorflow/tensorflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8888/tree&#34;&gt;http://localhost:8888/tree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公式のチュートリアルをまとめながら進めてみる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tensorflow.org/versions/r0.9/tutorials/mnist/beginners/index.html&#34;&gt;MNIST For ML Beginners&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-mnist-data&#34;&gt;The MNIST Data&lt;/h3&gt;

&lt;p&gt;MNISTというのは0~9の書き数字の画像のデータセットのことで、これらを正しく分類するのが目的。&lt;/p&gt;

&lt;p&gt;それぞれの画像は一律28*28=784ピクセルで、それぞれのピクセルは0と1の間の数値(強さ)で表されている。
今回はこれの縦横を取っ払って784次元のベクトルとして扱っている。&lt;/p&gt;

&lt;p&gt;したがって、学習用の画像データは[55000, 784]のtensor(n次元の配列)で表される。
55000というのが画像の数で、784というのがそれぞれの画像の次元を意味している。&lt;/p&gt;

&lt;p&gt;それぞれの画像に対応した数字のラベルは[55000, 10]で表される。
10というのは、0~9それぞれに対応した次元のうち、一つだけ1で、それ以外が0という風に使われる。これをone-hot vectorという。&lt;/p&gt;

&lt;h3 id=&#34;softmax-regressions&#34;&gt;Softmax Regressions&lt;/h3&gt;

&lt;p&gt;Softmaxはいくつかの異なるもの(今回でいうと数字)に確率を割り当てる。&lt;/p&gt;

&lt;p&gt;画像が特定のクラス(0~9)に属するかどうか計算するために、ピクセルの強さに重みを付けた合計を計算する。
もし、そのピクセルがそのクラスに属さない根拠になるなら負の重みがかかり、属する根拠になるなら、正の重みがかかるようにする。
また合計にさらに入力と無関係なクラスごとに異なるバイアスを足す。&lt;/p&gt;

&lt;p&gt;全てのクラスで計算した値をsoftmax関数に入れ、それぞれ確率に変換する。この確率の和は1になるようになっている。&lt;/p&gt;

&lt;h3 id=&#34;implementing-the-regression&#34;&gt;Implementing the Regression&lt;/h3&gt;

&lt;p&gt;Pythonでは行列の積のような重い処理をするとき、NumPyのようなライブラリを使ってPythonの外で行うが、
外からPythonに戻るときにオーバーヘッドが発生してしまう。
TensorFlowでも重い処理を外で行うが、オーバーヘッドを避けるために、
単体の重い処理をPythonから独立して実行する代わりに、Pythonの外側で実行される関連した処理のグラフを記述させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import tensorflow as tf
x = tf.placeholder(tf.float32, [None, 784])
W = tf.Variable(tf.zeros([784, 10]))
b = tf.Variable(tf.zeros([10]))
y = tf.nn.softmax(tf.matmul(x, W) + b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tf.placeholder&lt;/code&gt;は実行時に与えられる値で、今回が画像データ。
W(重み)とb(バイアス)は学習する変数。
&lt;code&gt;tf.matmul(x, W) + b&lt;/code&gt;の部分が重みを付けた合計にバイアスを足したものに対応している。
matmulはmatrix multiple、つまり行列の積。&lt;/p&gt;

&lt;h3 id=&#34;training&#34;&gt;Training&lt;/h3&gt;

&lt;p&gt;機械学習では一般的に、悪いモデルとは何か定義し、それを最小化しようとする。
一般的で、良い誤差関数として&amp;rdquo;cross-entropy&amp;rdquo;というものがある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y_ = tf.placeholder(tf.float32, [None, 10])
cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y_が正しい答えで、これとy(softmaxで求めた各数字の確率)の対数の積をを次元ごとにとり、それらの和を求めて-1を掛けている。
&lt;code&gt;reduction_indices=[1]&lt;/code&gt;というのは[784, 10]の10の方を指している模様。
全ての学習データにおいてこれを求め、さらにそれらの平均をとり、これをcross_entropyとしている。
この値はy_とyが離れていれば大きくなるので、なるべく小さくすることが良いモデルにするということになる。&lt;/p&gt;

&lt;p&gt;ではどうやってこの値を小さくするか、TensorFlowは関係する計算のグラフを持っているので、自動的に&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AF%E3%83%97%E3%83%AD%E3%83%91%E3%82%B2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;バックプロパゲーション&lt;/a&gt;を使って、どの変数がcross_entropyに影響しているか効率的に特定することができる。&lt;/p&gt;

&lt;p&gt;以下のようにGradientDescent(勾配降下)Optimizerで0.5のleartning rateでcross_entropyが小さくなるように、変数を少しずつ変えていく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使って学習していく。学習とテストに使うデータは&lt;a href=&#34;https://github.com/tensorflow/tensorflow/blob/r0.9/tensorflow/examples/tutorials/mnist/input_data.py&#34;&gt;これ&lt;/a&gt;
と&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets(&amp;quot;MNIST_data/&amp;quot;, one_hot=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すれば用意できるようになっている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tf.Session()&lt;/code&gt;と&lt;code&gt;tf.run()&lt;/code&gt;はSessionを取得し、モデルを実行するもの。
変数は&lt;code&gt;tf.initialize_all_variables()&lt;/code&gt;で初期化する必要がある。
batch_xsが画像のピクセルデータで、batch_ysが正しい答え。
&lt;code&gt;sess.run()&lt;/code&gt;の&lt;code&gt;feed_dict={x: batch_xs, y_: batch_ys}&lt;/code&gt;はそれぞれ対応するplaceholderのところに与えられる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init = tf.initialize_all_variables()
sess = tf.Session()
sess.run(init)
for i in range(1000):
  batch_xs, batch_ys = mnist.train.next_batch(100)
  sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このような小さいランダムなデータを使うのはstochastic(確率的) trainingと呼ばれていて、
今回はstochastic gradient descent。
理想的には全てのデータを全ての訓練のステップで使いたいが、コストがかかるので代わりに毎回異なるサブセットを使うことで
同じ効果を得ている。&lt;/p&gt;

&lt;h3 id=&#34;evaluating-our-model&#34;&gt;Evaluating Our Model&lt;/h3&gt;

&lt;p&gt;モデルがどのくらい良いかを測る。&lt;/p&gt;

&lt;p&gt;以下のcorrect_predictionでは&lt;code&gt;tf.argmax&lt;/code&gt;で最も数値の大きい、つまり確率の高いラベルを取得し、これが正解のものと一致するかというのを
画像データごとに比較している。
結果、[True, False, True, True]であるなら、これを[1, 0, 1, 1]にキャストし、平均を取ったものがaccuracy、正解率となる。
そしてこの値をテスト用のデータで出力している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;correct_prediction = tf.equal(tf.argmax(y,1), tf.argmax(y_,1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
print(sess.run(accuracy, feed_dict={x: mnist.test.images, y_: mnist.test.labels}))
&amp;gt; 0.9206
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この簡単なモデルだと正解率は92%になったが、実はこれは非常に悪いとのこと。
モデルにもう少し変更を加えるだけで97%になったりするらしい。&lt;/p&gt;

&lt;p&gt;続き: &lt;a href=&#34;http://sambaiz.net/article/6&#34;&gt;TensorFlow チュートリアル2(Deep MNIST for Experts)&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Reactで作ったページにTwitterCardsとOGPのメタデータを埋める</title>
          <link>http://sambaiz.net/article/2/</link>
          <pubDate>Sat, 02 Jul 2016 13:23:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/2/</guid>
          <description>&lt;p&gt;せっかくページを作ったので、SNSにシェアするときに見栄えをよくしようと思った。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/2_ogp.jpg&#34; alt=&#34;Facebookに表示される例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Twitter CardsやOGPのmetaタグを埋めるとTwitterやFacebookにURLを貼ったときに上のように表示されるようになる(上はFacebookの例)。そこで、&lt;a href=&#34;https://github.com/nfl/react-helmet&#34;&gt;react-helmet&lt;/a&gt;でこんな感じで動的に埋め込んだんだけど読んでくれない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Helmet title={&#39;sambaiz.net&#39;}
        meta={[
            {&amp;quot;name&amp;quot;: &amp;quot;twitter:card&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;summary&amp;quot;},
            {&amp;quot;name&amp;quot;: &amp;quot;twitter:site&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;@sambaiz&amp;quot;},
            {&amp;quot;name&amp;quot;: &amp;quot;twitter:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;},
            {&amp;quot;name&amp;quot;: &amp;quot;twitter:description&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;僕のホームページ&amp;quot;},
            {&amp;quot;property&amp;quot;: &amp;quot;og:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;},
            {&amp;quot;property&amp;quot;: &amp;quot;og:type&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;blog&amp;quot;},
            {&amp;quot;property&amp;quot;: &amp;quot;og:image&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;http://d2wgaf7ubdj1mv.cloudfront.net/my.jpg&amp;quot;},
            {&amp;quot;property&amp;quot;: &amp;quot;og:url&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;http://sambaiz.net&amp;quot;}
        ]}
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Googleのクローラーのように&lt;a href=&#34;https://webmasters.googleblog.com/2014/05/understanding-web-pages-better.html&#34;&gt;Javascriptを解釈してくれる&lt;/a&gt;
と思ってた。残念。&lt;/p&gt;

&lt;p&gt;しょうがないのでここだけサーバーサイドレンダリングすることにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;

import express from &#39;express&#39;
import path from &#39;path&#39;
import compression from &#39;compression&#39;

require(&#39;isomorphic-fetch&#39;);

var app = express()

app.use(compression())

// serve our static stuff
app.use(express.static(path.join(__dirname, &#39;..&#39;, &#39;..&#39;, &#39;public&#39;)))

app.get(&#39;/&#39;, function (req, res) {
  res.status(200).send(page(&#39;http://sambaiz.net&#39;, &#39;sambaiz.net&#39;, &#39;僕のホームページ&#39;));
})

app.get(&#39;/article/:articleId&#39;, function (req, res) {
  fetch(`https://zx9h12n6jb.execute-api.ap-northeast-1.amazonaws.com/api/articles/${req.params.articleId}`).then(function(response){
    if (response.status == 404) {
      res.status(404).send(&#39;not found&#39;)
    }else if(response.status != 200){
      res.status(response.status).send(`API error ${response.status}`)
    }else{
      return response.json();
    }
  }).then(function(json) {
    if(json){
      res.status(200).send(page(`http://sambaiz.net${req.url}`, json.title, &#39;書いた&#39;));
    }
  })
})

function page(fullUrl, title, description)  {
  return `
    &amp;lt;!doctype html&amp;gt;
    &amp;lt;html&amp;gt;
      &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;${title}&amp;lt;/title&amp;gt;
        &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;twitter:card&amp;quot; content=&amp;quot;summary&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;twitter:site&amp;quot; content=&amp;quot;@sambaiz&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;twitter:title&amp;quot; content=&amp;quot;${title}&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;twitter:description&amp;quot; content=&amp;quot;${description}&amp;quot;&amp;gt;
        &amp;lt;meta property=&amp;quot;og:title&amp;quot; content=&amp;quot;${title}&amp;quot;&amp;gt;
        &amp;lt;meta property=&amp;quot;og:type&amp;quot; content=&amp;quot;blog&amp;quot;&amp;gt;
        &amp;lt;meta property=&amp;quot;og:image&amp;quot; content=&amp;quot;http://d2wgaf7ubdj1mv.cloudfront.net/my.jpg&amp;quot;&amp;gt;
        &amp;lt;meta property=&amp;quot;og:url&amp;quot; content=&amp;quot;${fullUrl}&amp;quot;&amp;gt;
      &amp;lt;/head&amp;gt;
      &amp;lt;body&amp;gt;
        &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;script src=&amp;quot;/bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
    `
}

var PORT = process.env.PORT || 8080

app.listen(PORT, function() {
  console.log(&#39;Production Express server running at localhost:&#39; + PORT)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと読まれているかは以下のページで確認できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cards-dev.twitter.com/validator&#34;&gt;Card validator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.facebook.com/tools/debug/&#34;&gt;Sharing Debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が、&lt;a href=&#34;http://sambaiz.net/article/5&#34;&gt;結局全部サーバーサイドレンダリングすることになった。&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ブログを作った</title>
          <link>http://sambaiz.net/article/1/</link>
          <pubDate>Wed, 29 Jun 2016 23:43:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/1/</guid>
          <description>&lt;p&gt;最近表に出るものを作っていなかったので、このサイトを作ってみた。&lt;/p&gt;

&lt;p&gt;表はReact/Reduxで、裏側はAWSのLambdaでサーバーレスに作ってある。
コードは&lt;a href=&#34;https://github.com/sambaiz/sambaiz.net&#34;&gt;github&lt;/a&gt;に公開してみた。&lt;/p&gt;

&lt;p&gt;これを期になるべくアウトプットしていこうと思う。大抵三日坊主なのだけれど。&lt;/p&gt;

&lt;p&gt;&amp;ndash;&lt;/p&gt;

&lt;p&gt;追記: 今はHugoに置き換わっている&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/22&#34;&gt;静的ウェブサイトエンジンHugoに乗り換えた&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
