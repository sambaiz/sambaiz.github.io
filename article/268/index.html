<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">

  
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-NCML2RV');</script>
  

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">

  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
  <link rel="stylesheet" href="/css/destyle.css">
  <style>
    body {
        background-color: #f1f1f1;
        line-height: 1.3;
        font-family: 'Noto Sans JP', sans-serif;
    }

    .languages {
        position: absolute;
        top: 10px;
        right: 15px;
        font-size: 1.2rem;
        color: #3a9240;
    }

    header {
        margin-block-start: 1.875rem;
        margin-block-end: 1.875rem;
    }

    header>.title {
        font-size: 1.875rem;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .sns {
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .sns-item {
        display: inline-block;
        margin: 3px;
    }

    .filmarks {
        display: inline-block;
        width: 30px;
        height: 30px;
        margin-top: 3px;
        background: url(/image/filmarks.svg) no-repeat;
        background-size: 450%;
    }

    header>.tags {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        max-width: 1000px;
        margin: auto;
        padding: 0 20px;
    }

    header>.tags .others {
        font-weight: bold;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
    }

    .nl {
        display: inline-block;
    }

    .cell {
        background-color: #fff;
        border-radius: 5px;
        padding: 10px;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px rgba(0, 0, 0, 0.1) inset;
    }

    time {
        color: #333;
    }

    .tag {
        color: #3a9240;
        margin: 0 5px;
    }

    .tag:hover {
        text-decoration: underline;
    }

     
    .paging {
        display: inline-block;
        font-size: 1.25rem;
        margin: 10px 10px;
    }

    .paging.next {
        float: right;
    }


     
    .list>.title {
        font-size: 1.75rem;
        margin: 0 0 10px 10px;
    }

     
    .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(262px, 1fr));
        gap: 20px;
        margin: 0 10px;
    }

    .grid-nl {
        width: 100%;
    }

    .grid-cell {
        height: 11.25rem;
        overflow: hidden;
        box-sizing: content-box;
    }

    .grid-cell>.title {
        font-size: 1.5rem;
        word-wrap: break-word;
    }

     
    .single {
        margin: 0 10px 10px 10px;
        line-height: 1.5;
    }

    @media screen and (min-width: 768px) {
        .single .cell {
            padding: 10px 20px;
        }
    }

    .single-header {
        margin-block-start: 1.875rem;
        margin-block-end: 1.875rem;
        line-height: 1.3;
    }

    .single-header h1 {
        font-size: 2rem;
        font-weight: bold;
    }

    .single h2 {
        font-size: 1.8rem;
        border-bottom: 1px solid #ddd;
        margin-block-start: 1.875rem;
    }

    .single h3 {
        font-size: 1.5rem;
        margin-block-start: 1.5rem;
    }

    .single h4 {
        font-size: 1.2rem;
        margin-block-start: 1rem;
    }

    .single a {
        color: #3a9240;
    }

    .single a:hover {
        text-decoration: underline;
    }

    .single p {
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single p>code {
        background-color: #eee;
        color: #333;
        padding: 0 0.2rem;
        display: inline-block;
        overflow: auto;
        max-width: 100%;
        vertical-align: bottom;
    }

    .single .highlight {
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.3), 0 0 1px rgba(0, 0, 0, 0.1) inset;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single .highlight>pre {
        padding: 10px;
        overflow-x: auto;
        background-color: ;
    }

    .single img {
        max-width: 100%;
    }

    .single blockquote {
        border-left: 5px solid #ddd;
        color: #777;
        padding: 1rem 0 1rem 1rem;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .single hr {
        color: #bbb;
        margin-block-start: 1.5rem;
        margin-block-end: 1.5rem;
    }

    .single ul {
        list-style-type: disc;
        padding-left: 1.5em;
        margin-block-start: 0.83rem;
        margin-block-end: 0.83rem;
    }

    .share {
        position: relative;
        text-align: right;
        margin-top: 5px;
    }

    .share .cell {
        display: inline-block;
        text-align: center;
        margin-bottom: 5px;
    }

    .share-button {
        display: inline-block;
        margin: 0 5px;
    }

    @media screen and (min-width: 1400px) {
        .share .cell {
            position: absolute;
            bottom: 0;
            margin-left: 5px;
        }

        .share-button {
            display: inline-block;
            margin: 5px 0;
        }
    }
</style>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.sambaiz.net/index.xml">
  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">

  <meta name="theme-color" content="#41a248">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@sambaiz">
  
  <title>Goのcipher packageに実装されている暗号利用モードのベンチマーク - sambaiz-net</title>
  <meta name="twitter:title" content="Goのcipher packageに実装されている暗号利用モードのベンチマーク - sambaiz-net">
  <meta property='og:title' content="Goのcipher packageに実装されている暗号利用モードのベンチマーク - sambaiz-net">
  <meta property="og:type" content="article">
  
  <meta name="description" content="CBC, CFB, OFB, CTR">
  <meta name="twitter:description" content="CBC, CFB, OFB, CTR">
  
  

  <meta property="og:url" content="https://www.sambaiz.net/article/268/">
  <meta property="og:image" content="https://www.sambaiz.net/images/my_l.jpg">
  <meta name="twitter:image" content="https://www.sambaiz.net/images/my.jpg" />

  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id": "https://www.sambaiz.net/"
    },
    "headline": "Goのcipher packageに実装されている暗号利用モードのベンチマーク",
    "datePublished": "2020-04-12T23:29:00JST",
    "dateModified": "2020-04-12T23:29:00JST",
    "author": {
      "@type": "Person",
      "name": "sambaiz",
      "url": "https://www.sambaiz.net/",
      "image": "https://www.sambaiz.net/images/my.jpg"
    },
    "publisher": {
      "@type": "Person",
      "name": "sambaiz-net",
      "logo": {
        "@type": "ImageObject",
        "url": "https://www.sambaiz.net/images/my.jpg",
        "height": 60,
        "width": 60
      }
    },
    "image": {
      "@type": "ImageObject",
      "url": "https://www.sambaiz.net/images/my.jpg",
      "height": 138,
      "width": 138
    },
    "description": "CBC, CFB, OFB, CTR"
  }
</script>
</head>

<body>
  
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NCML2RV"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <div>
    <div class="languages">
      
    </div>

    <header>
      <div class="title">
        <img src="https://www.sambaiz.net/images/my.png" width="60px" height="60px" alt="icon" />
        <a class="nl" href='/'>
          <h1>sambaiz-net</h1>
        </a>
      </div>

      <div class="sns">
        <div class="sns-item">
          <a class="nl" href="https://twitter.com/sambaiz">
            <img src="/image/twitter.png" width="30px" height="30px" alt="twitter">
          </a>
        </div>
        <div class="sns-item">
          <a class="nl" href="https://github.com/sambaiz">
            <img src="/image/github.png" width="30px" height="30px" alt="github">
          </a>
        </div>
        <div class="sns-item">
          <a class="nl" href="https://bookmeter.com/users/1060169/books/read">
            <img src="/image/bookmeter.png" width="30px" height="30px" alt="bookmeter">
          </a>
        </div>
        <div class="sns-item">
          <a href="https://filmarks.com/users/sambaiz" class="filmarks" aria-label="filmarks"></a>
        </div>
        <div class="sns-item">
          <a class="nl" href="https://www.alltrails.com/members/taiki-sakamoto/recordings">
            <img src="/image/alltrails.png" width="30px" height="30px" alt="alltrails">
          </a>
        </div>
      </div>
      <div class="tags">
        <div>
          
          <a class="tag" href="/tags/aws/">
            aws</a>
          
          <a class="tag" href="/tags/golang/">
            golang</a>
          
          <a class="tag" href="/tags/machinelearning/">
            machinelearning</a>
          
          <a class="tag" href="/tags/python/">
            python</a>
          
          <a class="tag" href="/tags/kubernetes/">
            kubernetes</a>
          
          <a class="tag" href="/tags/log/">
            log</a>
          
          <a class="tag" href="/tags/docker/">
            docker</a>
          
          <a class="tag" href="/tags/gcp/">
            gcp</a>
          
          <a class="tag" href="/tags/fluentd/">
            fluentd</a>
          
          <a class="tag" href="/tags/infra/">
            infra</a>
          
          <a class="tag others" href="/tags/">...</a>
        </div>
      </div>
    </header>

<div class="container">
  <article class="single">
    <div class="cell">
      <div class="single-header">
        <h1>Goのcipher packageに実装されている暗号利用モードのベンチマーク</h1>
        <time>2020-04-12</time>
        <a class="tag" href='/tags/golang/'>golang</a><a class="tag" href='/tags/crypto/'>crypto</a>
      </div>
      <p>暗号利用モードはブロック長より長いメッセージに対してどのようにブロック暗号を適用するかのアルゴリズム。</p>
<h2 id="ブロック暗号">ブロック暗号</h2>
<p>ブロック暗号は固定長のブロックを暗号化/復号する共通鍵暗号で、入力と同じ長さの出力を返す暗号化/復号関数からなる。
アメリカ国立標準技術研究所（NIST) が標準暗号として採用したAES (Rijndael) が有名。
最も単純な暗号利用モードとして、メッセージをブロックに分割してそれぞれ独立に適用する Electronic Codebook (ECB) というのがあるが、
鍵とブロックが同じなら毎回同じ出力になってしまうため、メッセージのパターンが残ってしまうのとリプレイ攻撃に弱い問題があり使われない。
また、メッセージがブロック長の整数倍になるようにパディングが必要。</p>
<p><img src="https://www.sambaiz.net/images/268-ecb.png" alt="ECBによる暗号化/復号"></p>
<h2 id="goのcryptocipher-packageに実装されている暗号化利用モード">Goのcrypto/cipher packageに実装されている暗号化利用モード</h2>
<p>Goの<a href="https://golang.org/pkg/crypto/cipher/">crypto/cipher</a> packageには次の暗号化利用モードが実装されている。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">$ go version
go version go1.14 darwin/amd64
</code></pre></div><h3 id="cipher-block-chaining-cbc">Cipher Block Chaining (CBC)</h3>
<p>メッセージをブロックに分割し、前段の暗号文(最初はランダムなIV)と入力ブロックのXORを取ったものが暗号文で、
これを復号関数にかけて前段の暗号文とのXORを取って復号する。IVは平文のまま暗号文の前に付けるなどする。
IVがないと最初のブロックが復号できず、暗号文の一部が破損すると次のブロックまで復号できない。
ECBと同様パディングが必要。最も広く使われているらしい。</p>
<p>最後のブロックの暗号文をMAC(Message Authentication Code)とする<a href="https://ja.wikipedia.org/wiki/CBC-MAC">CBC-MAC</a>では最初のブロックの改変を防ぐためIVが0固定で、
任意のメッセージの最初のブロックを他のメッセージのMACとXORを取って後ろに結合することで、それまでの影響を打ち消し任意のメッセージ単体のMACと同じ値にする
Length extension attackが成立する。そのためメッセージを固定長にするかメッセージ長を先頭に入れるなどの対策が必要。</p>
<p><img src="https://www.sambaiz.net/images/268-cbc.png" alt="CBCによる暗号化/復号"></p>
<p>Goではパディングは自分でやる必要がある。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> (x *cbcEncrypter) CryptBlocks(dst, src []<span style="color:#2b91af">byte</span>) {
    <span style="color:#00f">if</span> len(src)%x.blockSize != 0 {
        panic(<span style="color:#a31515">&#34;crypto/cipher: input not full blocks&#34;</span>)
    }
    <span style="color:#00f">if</span> len(dst) &lt; len(src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: output smaller than input&#34;</span>)
    }
    <span style="color:#00f">if</span> subtle.InexactOverlap(dst[:len(src)], src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: invalid buffer overlap&#34;</span>)
    }

    iv := x.iv

    <span style="color:#00f">for</span> len(src) &gt; 0 {
        <span style="color:#008000">// Write the xor to dst, then encrypt in place.
</span><span style="color:#008000"></span>        xorBytes(dst[:x.blockSize], src[:x.blockSize], iv)
        x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize])

        <span style="color:#008000">// Move to the next block with this block as the next iv.
</span><span style="color:#008000"></span>        iv = dst[:x.blockSize]
        src = src[x.blockSize:]
        dst = dst[x.blockSize:]
    }

    <span style="color:#008000">// Save the iv for the next CryptBlocks call.
</span><span style="color:#008000"></span>    copy(x.iv, iv)
}
</code></pre></div><p>足りないバイト数の値でパディングする<a href="https://tools.ietf.org/html/rfc5652#section-6.3">PKCS#7</a>の方式はこんな感じ。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> pad(data []<span style="color:#2b91af">byte</span>, blockSize <span style="color:#2b91af">int</span>) []<span style="color:#2b91af">byte</span> {
    padSize := blockSize - len(data) % blockSize
    ret := make([]<span style="color:#2b91af">byte</span>, len(data) + padSize)
    copy(ret, data)
    copy(ret[len(data):], bytes.Repeat([]<span style="color:#2b91af">byte</span>{byte(padSize)}, padSize))
    <span style="color:#00f">return</span> ret
}

<span style="color:#00f">func</span> unpad(data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    padSize := int(data[len(data)-1])
    <span style="color:#00f">if</span> padSize &gt; len(data) {
        <span style="color:#00f">return</span> <span style="color:#00f">nil</span>
    }
    <span style="color:#00f">return</span> data[:len(data)-padSize]
}
</code></pre></div><h3 id="cipher-feedback-cfb">Cipher Feedback (CFB)</h3>
<p>ブロック暗号を使ってはいるがブロックに分割不要なストリーム暗号になった。したがってパディングする必要もない。
前段の暗号文(最初はランダムなIV)を暗号関数にかけたものをストリーム暗号のKeystreamとし、これとメッセージのXORを取ったものが暗号文で、XORを再度取って復号する。
暗号化/復号共に暗号関数を用いる。IVや暗号文が破損した場合それ以降の復号はできない。</p>
<p><img src="https://www.sambaiz.net/images/268-cfb.png" alt="CFBによる暗号化/復号"></p>
<p><code>xorBytes()</code> はサイズが小さい方に合わせてXORを取る。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> (x *cfb) XORKeyStream(dst, src []<span style="color:#2b91af">byte</span>) {
    <span style="color:#00f">if</span> len(dst) &lt; len(src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: output smaller than input&#34;</span>)
    }
    <span style="color:#00f">if</span> subtle.InexactOverlap(dst[:len(src)], src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: invalid buffer overlap&#34;</span>)
    }
    <span style="color:#00f">for</span> len(src) &gt; 0 {
        <span style="color:#00f">if</span> x.outUsed == len(x.out) {
            x.b.Encrypt(x.out, x.next)
            x.outUsed = 0
        }

        <span style="color:#00f">if</span> x.decrypt {
            <span style="color:#008000">// We can precompute a larger segment of the
</span><span style="color:#008000"></span>            <span style="color:#008000">// keystream on decryption. This will allow
</span><span style="color:#008000"></span>            <span style="color:#008000">// larger batches for xor, and we should be
</span><span style="color:#008000"></span>            <span style="color:#008000">// able to match CTR/OFB performance.
</span><span style="color:#008000"></span>            copy(x.next[x.outUsed:], src)
        }
        n := xorBytes(dst, src, x.out[x.outUsed:])
        <span style="color:#00f">if</span> !x.decrypt {
            copy(x.next[x.outUsed:], dst)
        }
        dst = dst[n:]
        src = src[n:]
        x.outUsed += n
    }
}
</code></pre></div><h3 id="output-feedback-ofb">Output Feedback (OFB)</h3>
<p>同じくストリーミング暗号。
CFBが暗号文を次にフィードバックしていたのに対し、OFBは暗号関数の出力をXORを取って暗号文にする前にフィードバックする。
したがってKeystreamはIVがn回暗号関数を通ったものとなりメッセージに依存しないため先に計算することもできる。
それらとXORを取ったものが暗号文になるため復号も全く同じ処理になる。</p>
<p><img src="https://www.sambaiz.net/images/268-ofb.png" alt="OFBによる暗号化/復号"></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> (x *ofb) refill() {
    bs := x.b.BlockSize()
    remain := len(x.out) - x.outUsed
    <span style="color:#00f">if</span> remain &gt; x.outUsed {
        <span style="color:#00f">return</span>
    }
    copy(x.out, x.out[x.outUsed:])
    x.out = x.out[:cap(x.out)]
    <span style="color:#00f">for</span> remain &lt; len(x.out)-bs {
        x.b.Encrypt(x.cipher, x.cipher)
        copy(x.out[remain:], x.cipher)
        remain += bs
    }
    x.out = x.out[:remain]
    x.outUsed = 0
}

<span style="color:#00f">func</span> (x *ofb) XORKeyStream(dst, src []<span style="color:#2b91af">byte</span>) {
    <span style="color:#00f">if</span> len(dst) &lt; len(src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: output smaller than input&#34;</span>)
    }
    <span style="color:#00f">if</span> subtle.InexactOverlap(dst[:len(src)], src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: invalid buffer overlap&#34;</span>)
    }
    <span style="color:#00f">for</span> len(src) &gt; 0 {
        <span style="color:#00f">if</span> x.outUsed &gt;= len(x.out)-x.b.BlockSize() {
            x.refill()
        }
        n := xorBytes(dst, src, x.out[x.outUsed:])
        dst = dst[n:]
        src = src[n:]
        x.outUsed += n
    }
}
</code></pre></div><h3 id="counter-ctr">Counter (CTR)</h3>
<p>同じくストリーミング暗号。IV相当のNonceと重複しないCounterを合わせて暗号関数に通したCounter blockをKeystreamとする。</p>
<p><img src="https://www.sambaiz.net/images/268-ctr.png" alt="CTRによる暗号化/復号"></p>
<p>前段に依存しないため並列に暗号化できるがGoではしていない。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> NewCTR(block Block, iv []<span style="color:#2b91af">byte</span>) Stream {
    <span style="color:#00f">if</span> ctr, ok := block.(ctrAble); ok {
        <span style="color:#00f">return</span> ctr.NewCTR(iv)
    }
    <span style="color:#00f">if</span> len(iv) != block.BlockSize() {
        panic(<span style="color:#a31515">&#34;cipher.NewCTR: IV length must equal block size&#34;</span>)
    }
    bufSize := streamBufferSize
    <span style="color:#00f">if</span> bufSize &lt; block.BlockSize() {
        bufSize = block.BlockSize()
    }
    <span style="color:#00f">return</span> &amp;ctr{
        b:       block,
        ctr:     dup(iv),
        out:     make([]<span style="color:#2b91af">byte</span>, 0, bufSize),
        outUsed: 0,
    }
}

<span style="color:#00f">func</span> (x *ctr) refill() {
    remain := len(x.out) - x.outUsed
    copy(x.out, x.out[x.outUsed:])
    x.out = x.out[:cap(x.out)]
    bs := x.b.BlockSize()
    <span style="color:#00f">for</span> remain &lt;= len(x.out)-bs {
        x.b.Encrypt(x.out[remain:], x.ctr)
        remain += bs

        <span style="color:#008000">// Increment counter
</span><span style="color:#008000"></span>        <span style="color:#00f">for</span> i := len(x.ctr) - 1; i &gt;= 0; i-- {
            x.ctr[i]++
            <span style="color:#00f">if</span> x.ctr[i] != 0 {
                <span style="color:#00f">break</span>
            }
        }
    }
    x.out = x.out[:remain]
    x.outUsed = 0
}

<span style="color:#00f">func</span> (x *ctr) XORKeyStream(dst, src []<span style="color:#2b91af">byte</span>) {
    <span style="color:#00f">if</span> len(dst) &lt; len(src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: output smaller than input&#34;</span>)
    }
    <span style="color:#00f">if</span> subtle.InexactOverlap(dst[:len(src)], src) {
        panic(<span style="color:#a31515">&#34;crypto/cipher: invalid buffer overlap&#34;</span>)
    }
    <span style="color:#00f">for</span> len(src) &gt; 0 {
        <span style="color:#00f">if</span> x.outUsed &gt;= len(x.out)-x.b.BlockSize() {
            x.refill()
        }
        n := xorBytes(dst, src, x.out[x.outUsed:])
        dst = dst[n:]
        src = src[n:]
        x.outUsed += n
    }
}
</code></pre></div><h2 id="ベンチマーク">ベンチマーク</h2>
<p>それぞれの暗号利用モードで暗号化/復号する際のベンチマークを取る。コードは<a href="https://github.com/sambaiz/go-cipher-benchmark">GitHub</a>にある。
CBCはパディング込み。OFBとCTRは暗号化/復号処理が同じなのでまとめている。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-go" data-lang="go"><span style="color:#00f">package</span> sandbox

<span style="color:#00f">import</span> (
    <span style="color:#a31515">&#34;bytes&#34;</span>
    <span style="color:#a31515">&#34;crypto/cipher&#34;</span>
)

<span style="color:#00f">func</span> pad(data []<span style="color:#2b91af">byte</span>, blockSize <span style="color:#2b91af">int</span>) []<span style="color:#2b91af">byte</span> {
    padSize := blockSize - len(data) % blockSize
    ret := make([]<span style="color:#2b91af">byte</span>, len(data) + padSize)
    copy(ret, data)
    copy(ret[len(data):], bytes.Repeat([]<span style="color:#2b91af">byte</span>{byte(padSize)}, padSize))
    <span style="color:#00f">return</span> ret
}

<span style="color:#00f">func</span> unpad(data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    padSize := int(data[len(data)-1])
    <span style="color:#00f">if</span> padSize &gt; len(data) {
        <span style="color:#00f">return</span> <span style="color:#00f">nil</span>
    }
    <span style="color:#00f">return</span> data[:len(data)-padSize]
}

<span style="color:#00f">func</span> EncryptWithCBC(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    data = pad(data, block.BlockSize())
    enc := cipher.NewCBCEncrypter(block, iv)
    encrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    enc.CryptBlocks(encrypted, data)
    <span style="color:#00f">return</span> encrypted
}

<span style="color:#00f">func</span> DecryptWithCBC(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    dec := cipher.NewCBCDecrypter(block, iv)
    decrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    dec.CryptBlocks(decrypted, data)
    <span style="color:#00f">return</span> decrypted
}

<span style="color:#00f">func</span> EncryptWithCFB(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    enc := cipher.NewCFBEncrypter(block, iv)
    encrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    enc.XORKeyStream(encrypted, data)
    <span style="color:#00f">return</span> encrypted
}

<span style="color:#00f">func</span> DecryptWithCFB(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    dec := cipher.NewCFBDecrypter(block, iv)
    decrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    dec.XORKeyStream(decrypted, data)
    <span style="color:#00f">return</span> decrypted
}

<span style="color:#00f">func</span> EncryptDecryptWithOFB(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    enc := cipher.NewOFB(block, iv)
    encrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    enc.XORKeyStream(encrypted, data)
    <span style="color:#00f">return</span> encrypted
}


<span style="color:#00f">func</span> EncryptDecryptWithCTR(block cipher.Block, iv []<span style="color:#2b91af">byte</span>, data []<span style="color:#2b91af">byte</span>) []<span style="color:#2b91af">byte</span> {
    enc := cipher.NewCTR(block, iv)
    encrypted := make([]<span style="color:#2b91af">byte</span>, len(data))
    enc.XORKeyStream(encrypted, data)
    <span style="color:#00f">return</span> encrypted
}
</code></pre></div><p>入力は128 bytesと12800 bytesのランダムなバイト列。
128 bytesではCFBが最速でCBCがそれに次ぎ、OFBとCTRのパフォーマンスが悪く、
12800 bytesではOFBが最速でCBCとCTRが同じくらい、CFBのパフォーマンスが悪いという結果になった。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-fallback" data-lang="fallback">$ go test -bench &#34;.*&#34; -benchmem main_test.go  main.go
goos: darwin
goarch: amd64
BenchmarkShortEncryptWithCBC-4                    852924              1323 ns/op             416 B/op          6 allocs/op
BenchmarkShortDecryptWithCBC-4                   1000000              1045 ns/op             240 B/op          4 allocs/op
BenchmarkShortEncryptWithCFB-4                   1213734               987 ns/op             240 B/op          4 allocs/op
BenchmarkShortDecryptWithCFB-4                   1228692              1155 ns/op             240 B/op          4 allocs/op
BenchmarkShortEncryptDecryptWithOFB-4             701252              1608 ns/op             736 B/op          4 allocs/op
BenchmarkShortEncryptDecryptWithCTR-4             709312              1747 ns/op             736 B/op          4 allocs/op
BenchmarkLongEncryptWithCBC-4                      60972             23010 ns/op           27264 B/op          6 allocs/op
BenchmarkLongDecryptWithCBC-4                      54586             22122 ns/op           13680 B/op          4 allocs/op
BenchmarkLongEncryptWithCFB-4                      34948             30435 ns/op           13680 B/op          4 allocs/op
BenchmarkLongDecryptWithCFB-4                      38904             28475 ns/op           13680 B/op          4 allocs/op
BenchmarkLongEncryptDecryptWithOFB-4               59216             20488 ns/op           14176 B/op          4 allocs/op
BenchmarkLongEncryptDecryptWithCTR-4               50810             23594 ns/op           14176 B/op          4 allocs/op
</code></pre></div><h2 id="参考">参考</h2>
<p><a href="https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%88%A9%E7%94%A8%E3%83%A2%E3%83%BC%E3%83%89">暗号利用モード - Wikipedia</a></p>
<p><a href="https://kiririmode.hatenablog.jp/entry/20181014/1539473020">golang で AES/CBC/PKCS#7Padding の暗号化・復号化 - 理系学生日記</a></p>
<p><a href="https://en.wikipedia.org/wiki/Padding_(cryptography)">Padding (cryptography) - Wikipedia</a></p>

    </div>
    <div class="share">
      <div class="cell">
        <div>share</div>
        <div>
          <a class="share-button" href='https://twitter.com/intent/tweet?url=https://www.sambaiz.net/article/268/&text=Go%e3%81%aecipher%20package%e3%81%ab%e5%ae%9f%e8%a3%85%e3%81%95%e3%82%8c%e3%81%a6%e3%81%84%e3%82%8b%e6%9a%97%e5%8f%b7%e5%88%a9%e7%94%a8%e3%83%a2%e3%83%bc%e3%83%89%e3%81%ae%e3%83%99%e3%83%b3%e3%83%81%e3%83%9e%e3%83%bc%e3%82%af%20-%20sambaiz-net'>
            <img src="/image/twitter.png" width="40px" height="40px" alt="twitter">
          </a>
          <a href="https://b.hatena.ne.jp/entry/" class="share-button hatena-bookmark-button" data-hatena-bookmark-layout="touch" data-hatena-bookmark-width="40" data-hatena-bookmark-height="40" title="このエントリーをはてなブックマークに追加">
            <img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="40" height="40" style="border: none;" />
          </a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
        </div>
      </div>
    </div>
  </article>
</div>

</div>
</body>

</html>