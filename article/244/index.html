<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.69.2" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7"
    crossorigin="anonymous">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/magula.min.css">
  <link rel="stylesheet" href="/css/slidebars.min.css">
  <link rel="stylesheet" href="/css/styles.css">
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.sambaiz.net/index.xml">
  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">

  <meta name="theme-color" content="#41a248">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@sambaiz">
  
  <title>goyaccでparserを生成しLispのcons,car,cdrの式を評価する - sambaiz-net</title>
  <meta name="twitter:title" content="goyaccでparserを生成しLispのcons,car,cdrの式を評価する - sambaiz-net">
  <meta property='og:title' content="goyaccでparserを生成しLispのcons,car,cdrの式を評価する - sambaiz-net">
  <meta property="og:type" content="article">
  
  <meta name="description" content="構文解析">
  <meta name="twitter:description" content="構文解析">
  
  

  <meta property="og:url" content="https://www.sambaiz.net/article/244/">
  <meta property="og:image" content="https://www.sambaiz.net/images/my_l.jpg">
  <meta name="twitter:image" content="https://www.sambaiz.net/images/my.jpg" />
  <meta name="google-site-verification" content="CEqNYjzc4Y7hb3FY7uUkmllGzeDc40brBwQJixeH61Q" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https:\/\/www.sambaiz.net\/"
    },
    "headline": "goyaccでparserを生成しLispのcons,car,cdrの式を評価する | sambaiz-net ",
    "datePublished": "2019-10-15T09:41:00JST",
    "dateModified": "2019-10-15T09:41:00JST",
    "author": {
      "@type": "Person",
      "name": "sambaiz",
      "image": "https:\/\/www.sambaiz.net\/images/my.jpg"
    },
    "publisher": {
      "@type": "Organization",
      "name": "sambaiz-net",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/www.sambaiz.net\/images/my.jpg",
        "height": 60,
        "width": 60
      }
    },
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/www.sambaiz.net\/images/my.jpg",
      "height": 138,
      "width": 138
    },
    "description": "構文解析"
  }
</script>
</head>

<body>
  <div off-canvas="id-1 left reveal">
  
  <ul class="tag-list">
    
  </ul>
  
  <ul class="tag-list">
    <li><a href="https://www.sambaiz.net/tags/aws">aws</a></li><li><a href="https://www.sambaiz.net/tags/golang">golang</a></li><li><a href="https://www.sambaiz.net/tags/machinelearning">machinelearning</a></li><li><a href="https://www.sambaiz.net/tags/python">python</a></li><li><a href="https://www.sambaiz.net/tags/kubernetes">kubernetes</a></li><li><a href="https://www.sambaiz.net/tags/log">log</a></li><li><a href="https://www.sambaiz.net/tags/infra">infra</a></li><li><a href="https://www.sambaiz.net/tags/tensorflow">tensorflow</a></li><li><a href="https://www.sambaiz.net/tags/ios">ios</a></li><li><a href="https://www.sambaiz.net/tags/lambda">lambda</a></li><li><a href="https://www.sambaiz.net/tags/unity">unity</a></li><li><a href="https://www.sambaiz.net/tags/docker">docker</a></li><li><a href="https://www.sambaiz.net/tags/fluentd">fluentd</a></li><li><a href="https://www.sambaiz.net/tags/gcp">gcp</a></li><li><a href="https://www.sambaiz.net/tags/node.js">node.js</a></li><li><a href="https://www.sambaiz.net/tags/web">web</a></li><li><a href="https://www.sambaiz.net/tags/swift">swift</a></li><li><a href="https://www.sambaiz.net/tags/linux">linux</a></li><li><a href="https://www.sambaiz.net/tags/mysql">mysql</a></li><li><a href="https://www.sambaiz.net/tags/elasticsearch">elasticsearch</a></li><li><a href="https://www.sambaiz.net/tags/javascript">javascript</a></li><li><a href="https://www.sambaiz.net/tags/c&#43;&#43;">c&#43;&#43;</a></li><li><a href="https://www.sambaiz.net/tags/hololens">hololens</a></li><li><a href="https://www.sambaiz.net/tags/auth">auth</a></li><li><a href="https://www.sambaiz.net/tags/product">product</a></li><li><a href="https://www.sambaiz.net/tags/android">android</a></li><li><a href="https://www.sambaiz.net/tags/circleci">circleci</a></li><li><a href="https://www.sambaiz.net/tags/react">react</a></li><li><a href="https://www.sambaiz.net/tags/statistics">statistics</a></li><li><a href="https://www.sambaiz.net/tags/typescript">typescript</a></li><li><a href="https://www.sambaiz.net/tags/algorithm">algorithm</a></li><li><a href="https://www.sambaiz.net/tags/ble">ble</a></li><li><a href="https://www.sambaiz.net/tags/event">event</a></li><li><a href="https://www.sambaiz.net/tags/pytorch">pytorch</a></li><li><a href="https://www.sambaiz.net/tags/vscode">vscode</a></li><li><a href="https://www.sambaiz.net/tags/angular">angular</a></li><li><a href="https://www.sambaiz.net/tags/cron">cron</a></li><li><a href="https://www.sambaiz.net/tags/istio">istio</a></li><li><a href="https://www.sambaiz.net/tags/objective-c">objective-c</a></li><li><a href="https://www.sambaiz.net/tags/terraform">terraform</a></li><li><a href="https://www.sambaiz.net/tags/uwp">uwp</a></li><li><a href="https://www.sambaiz.net/tags/.net">.net</a></li><li><a href="https://www.sambaiz.net/tags/crypto">crypto</a></li><li><a href="https://www.sambaiz.net/tags/css">css</a></li><li><a href="https://www.sambaiz.net/tags/datadog">datadog</a></li><li><a href="https://www.sambaiz.net/tags/firebase">firebase</a></li><li><a href="https://www.sambaiz.net/tags/github">github</a></li><li><a href="https://www.sambaiz.net/tags/grpc">grpc</a></li><li><a href="https://www.sambaiz.net/tags/hadoop">hadoop</a></li><li><a href="https://www.sambaiz.net/tags/language">language</a></li><li><a href="https://www.sambaiz.net/tags/norikra">norikra</a></li><li><a href="https://www.sambaiz.net/tags/rx">rx</a></li><li><a href="https://www.sambaiz.net/tags/server">server</a></li><li><a href="https://www.sambaiz.net/tags/vr">vr</a></li><li><a href="https://www.sambaiz.net/tags/ansible">ansible</a></li><li><a href="https://www.sambaiz.net/tags/api">api</a></li><li><a href="https://www.sambaiz.net/tags/cdn">cdn</a></li><li><a href="https://www.sambaiz.net/tags/compress">compress</a></li><li><a href="https://www.sambaiz.net/tags/csharp">csharp</a></li><li><a href="https://www.sambaiz.net/tags/d3.js">d3.js</a></li><li><a href="https://www.sambaiz.net/tags/digdag">digdag</a></li><li><a href="https://www.sambaiz.net/tags/hugo">hugo</a></li><li><a href="https://www.sambaiz.net/tags/jenkins">jenkins</a></li><li><a href="https://www.sambaiz.net/tags/jvm">jvm</a></li><li><a href="https://www.sambaiz.net/tags/kotlin">kotlin</a></li><li><a href="https://www.sambaiz.net/tags/leveldb">leveldb</a></li><li><a href="https://www.sambaiz.net/tags/lisp">lisp</a></li><li><a href="https://www.sambaiz.net/tags/llvm">llvm</a></li><li><a href="https://www.sambaiz.net/tags/math">math</a></li><li><a href="https://www.sambaiz.net/tags/neo4j">neo4j</a></li><li><a href="https://www.sambaiz.net/tags/read_paper">read_paper</a></li><li><a href="https://www.sambaiz.net/tags/scikit-learn">scikit-learn</a></li><li><a href="https://www.sambaiz.net/tags/serialize">serialize</a></li><li><a href="https://www.sambaiz.net/tags/sonnet">sonnet</a></li><li><a href="https://www.sambaiz.net/tags/spark">spark</a></li><li><a href="https://www.sambaiz.net/tags/spec">spec</a></li><li><a href="https://www.sambaiz.net/tags/video">video</a></li>
  </ul>
  
</div>

  <div canvas="container" id="container">
    <header>
      <button type="button" class="btn toggle-side">TAG</button>

      <div class="title">
        <img src="https://www.sambaiz.net/images/my.png" width="60px" height="60px" />
        <a class="nl" href="https://www.sambaiz.net/">sambaiz-net</a>
      </div>

      <div class="sns">
        <a class="nl" href="https://twitter.com/sambaiz"><i class="fa fa-2x fa-twitter"></i></a>
        <a class="nl" href="https://github.com/sambaiz"><i class="fa fa-2x fa-github"></i></a>
        <style>
          .filmarks-base {
            display: inline-block;
            width: 29px;
            height: 29px;
          }

          .filmarks {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: url(/image/filmarks.svg) no-repeat;
            background-size: 450%;
            position: relative;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
          }

          .vocabularycom-base {
            display: inline-block;
            width: 29px;
            height: 29px;
          }

          .vocabularycom {
            display: inline-block;
            height: 25px;
            width: 25px;
            background: url(/image/vocabularycom.png) no-repeat;
            background-size: contain;
            position: relative;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
          }

          .leetcode-base {
            display: inline-block;
            width: 29px;
            height: 29px;
          }

          .leetcode {
            display: inline-block;
            height: 25px;
            width: 25px;
            background: url(/image/leetcode.png) no-repeat;
            background-size: contain;
            position: relative;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
          }
        </style>
        <div class="filmarks-base">
          <a href="https://filmarks.com/users/sambaiz" class="filmarks"></a>
        </div>
        <div class="vocabularycom-base">
          <a href="https://www.vocabulary.com/profiles/B0JI0K19KKMVKH" class="vocabularycom"></a>
        </div>
        <div class="leetcode-base">
          <a href="https://leetcode.com/sambaiz/" class="leetcode"></a>
        </div>
      </div>
    </header>

<div class="container">

  <div class="row">
    <div class="col-md-12">

      <article class="single">
        <div class="single body">
          <h1>goyaccでparserを生成しLispのcons,car,cdrの式を評価する</h1>
          <p>(2019-10-15)</p>
          <p>GoでLispのcons,car,cdrの式を評価したい。
流れとしては字句解析器(lexer, tokenizer, scanner)でソースコードを分割しtoken列にして、構文解析器(parser)で構文木を作るなりして評価できるようにする。</p>
<pre><code>$ brew install clisp
$ clisp
&gt; (cons 1 ())
(1)
&gt; (cons () 1)
(NIL . 1)
&gt; (car (cons 1 (cons 2 3)))
1
&gt; (cdr (cons 1 (cons 2 3)))
(2 . 3)
</code></pre><h2 id="goの字句解析器と構文解析器">Goの字句解析器と構文解析器</h2>
<p>Goの字句解析器と構文解析器がGoが実装されているので見てみる。</p>
<h3 id="goscannerhttpsgolangorgpkggoscanner"><a href="https://golang.org/pkg/go/scanner/">go/scanner</a></h3>
<p>ソースコードを分割して<a href="https://github.com/golang/go/blob/go1.13.1/src/go/token/token.go">go/token</a>にする。</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;go/token&quot;
	&quot;go/scanner&quot;
)

func main() {
	var sc scanner.Scanner
	src := []byte(`(&quot;A&quot; + &quot;B&quot;) + &quot;C&quot;`)
	errorHandler := func(pos token.Position, msg string) { fmt.Printf(&quot;ERROR %v %v\n&quot;, pos, msg)}
	sc.Init(token.NewFileSet().AddFile(&quot;&quot;, -1, len(src)), src, errorHandler, 0)
	fmt.Printf(&quot;%6v %6v %6v\n&quot;, &quot;pos&quot;, &quot;tok&quot;, &quot;lit&quot;)
	for {
		pos, tok, lit := sc.Scan()
		if tok == token.EOF {
			break
		}
		fmt.Printf(&quot;%6v %6v %6v\n&quot;, pos, tok, lit)
	}
}
</code></pre><pre><code>pos    tok    lit
  1      (       
  2 STRING    &quot;A&quot;
  6      +       
  8 STRING    &quot;B&quot;
 11      )       
 13      +       
 15 STRING    &quot;C&quot;
 18      ;
</code></pre><p><a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go">実装</a>を見ていく。</p>
<p>まず<a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go#L703">skipWhitespace()</a>でスペースやタブなどを無視して読み進める(<a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go#L56">next()</a>)。
その後、見ている文字(s.ch)によってどう読み進めるかを判断する。</p>
<pre><code>func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) {
scanAgain:
	s.skipWhitespace()

	// current token start
	pos = s.file.Pos(s.offset)

	// determine token value
	insertSemi := false
	switch ch := s.ch; {
	case isLetter(ch):
		...
	default:
		s.next() // always make progress
		switch ch {
		case -1:
			if s.insertSemi {
				s.insertSemi = false // EOF consumed
				return pos, token.SEMICOLON, &quot;\n&quot;
			}
			tok = token.EOF
		case '&quot;':
			...
		}
	}
	if s.mode&amp;dontInsertSemis == 0 {
		s.insertSemi = insertSemi
	}

	return
}
</code></pre><p>文字列だったら(<a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go#L342">isLetter()</a>=true)、
<a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go#L350">scanIdentifier()</a>で文字列の最後まで読み進めて、
<a href="https://github.com/golang/go/blob/go1.13.1/src/go/token/token.go#L290">Lookup()</a>で
trueやbreakといったキーワードなのか、そうでないのか(token.IDENT)を判定する。</p>
<pre><code>case isLetter(ch):
    lit = s.scanIdentifier()
    if len(lit) &gt; 1 {
        // keywords are longer than one letter - avoid lookup otherwise
        tok = token.Lookup(lit)
        switch tok {
        case token.IDENT, token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.RETURN:
            insertSemi = true
        }
    } else {
        insertSemi = true
        tok = token.IDENT
    }
</code></pre><p><code>&quot;</code>は<a href="https://github.com/golang/go/blob/go1.13.1/src/go/scanner/scanner.go#L636">scanString()</a>で次の<code>&quot;</code>が来るまで
中身をstringとして読み進める。</p>
<pre><code>case '&quot;':
    insertSemi = true
    tok = token.STRING
    lit = s.scanString()
</code></pre><p><code>+</code>や<code>-</code>は<code>++</code>や<code>+=</code>かもしれないので次の文字を見て判断したり、</p>
<pre><code>case '+':
    tok = s.switch3(token.ADD, token.ADD_ASSIGN, '+', token.INC)
    if tok == token.INC {
        insertSemi = true
    }
</code></pre><p><code>.</code>は<code>...</code>かもしれないのでさらにその次の文字まで見ていたりする。</p>
<pre><code>case '.':
    // fractions starting with a '.' are handled by outer switch
    tok = token.PERIOD
    if s.ch == '.' &amp;&amp; s.peek() == '.' {
        s.next()
        s.next() // consume last '.'
        tok = token.ELLIPSIS
</code></pre><h3 id="goparserhttpsgolangorgpkggoparser"><a href="https://golang.org/pkg/go/parser/">go/parser</a></h3>
<p><a href="https://github.com/golang/go/blob/go1.13.1/src/go/ast/ast.go">go/ast</a>を生成する。</p>
<pre><code>package main
    
import (
    &quot;fmt&quot;
    &quot;go/ast&quot;
    &quot;go/parser&quot;
)

func f(a string) string {
    return &quot;X&quot;
}

func main() {
    exprs := []string{
        &quot;1 + 1&quot;,
        &quot;true || !false&quot;,
        `(1 + 1) * f(&quot;A&quot;)`,
		&quot;X ((Y))))&quot;,
    }
    for _, e := range exprs {
        expr, err := parser.ParseExpr(e)
        if err != nil {
            fmt.Printf(&quot;%s =&gt; %s&quot;, e, err)
            continue
        } 
        if be, ok := expr.(*ast.BinaryExpr); ok {
            fmt.Printf(&quot;%s =&gt; %T(%+v) %T(%+v) %T(%+v)\n&quot;, e, be.X, be.X, be.Op, be.Op, be.Y, be.Y)
        }
    }
}
</code></pre><pre><code>1 + 1 =&gt; *ast.BasicLit(&amp;{ValuePos:1 Kind:INT Value:1}) token.Token(+) *ast.BasicLit(&amp;{ValuePos:5 Kind:INT Value:1})
true || !false =&gt; *ast.Ident(true) token.Token(||) *ast.UnaryExpr(&amp;{OpPos:9 Op:! X:false})
(1 + 1) * f(&quot;A&quot;) =&gt; *ast.ParenExpr(&amp;{Lparen:1 X:0xc00006a1b0 Rparen:7}) token.Token(*) *ast.CallExpr(&amp;{Fun:f Lparen:12 Args:[0xc0000720c0] Ellipsis:0 Rparen:16})
X ((Y)))) =&gt; 1:8: expected 'EOF', found ')'
</code></pre><p><a href="https://github.com/golang/go/blob/go1.13.1/src/go/parser/parser.go">実装</a>を見てみたが再帰の連続でかなり骨が折れた。
調べてみると<a href="https://godoc.org/golang.org/x/tools/cmd">golang.org/x/tools/cmd</a>にあるgoyaccを使うと文法からparserを生成できるようなので
これを使うことにした。</p>
<h2 id="goyacc">goyacc</h2>
<p><a href="https://godoc.org/golang.org/x/tools/cmd/goyacc">goyacc</a>はparser generatorであるyacc(yet another compiler compiler)のGo版。</p>
<pre><code>$ go get golang.org/x/tools/cmd/goyacc
</code></pre><p>yacc文法ファイル<a href="https://github.com/golang/tools/blob/gopls/v0.1.7/cmd/goyacc/testdata/expr/expr.y">expr.y</a>に対して実行すると
<code>y.go</code>ができる。実行すると入力を受け付け、式を評価して表示するが、これはgoyaccの機能ではなく文法ファイルに書いてある挙動。</p>
<pre><code>$ wget https://raw.githubusercontent.com/golang/tools/gopls/v0.1.7/cmd/goyacc/testdata/expr/expr.y
$ goyacc -p &quot;expr&quot; expr.y
$ go run y.go
&gt; 2 * ((2 + 2) - 1) / 2
3
</code></pre><h2 id="yacc文法ファイル">yacc文法ファイル</h2>
<p><code>%%</code>で区切られた3つの部分からなる。</p>
<h3 id="定義部">定義部</h3>
<p><code>%{</code>と<code>%}</code>で囲まれた部分にコードを書けるのでpackage名やimportを書く。
<code>%union</code>は取り得る型の共用体で、<code>%token &lt;type&gt;</code>で規則によってreduceされる非終端記号を、<code>%type &lt;type&gt;</code>で終端記号の種類と型を定義する。
大文字と小文字は区別され、非終端記号は小文字で、終端記号は大文字にすることが多いようだ。
<code>''</code>で囲まれた一文字記号はここで定義しなくても規則で使える。</p>
<pre><code>%{

package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;math/big&quot;
	&quot;os&quot;
	&quot;unicode/utf8&quot;
)

%}

%union {
	num *big.Rat
}

%type	&lt;num&gt;	expr expr1 expr2 expr3

%token '+' '-' '*' '/' '(' ')'

%token	&lt;num&gt;	NUM
</code></pre><h3 id="規則部">規則部</h3>
<p>BNF(Backus-Naur Form)のような記法で、<code>左辺: 右辺</code>で右辺が左辺にreduceされる規則を表す。
<code>{}</code>の中にはコードが書けて、<code>$$</code>が左辺で<code>$n</code>が右辺のn番目のtokenになる。</p>
<pre><code>top:
	expr
	{
		if $1.IsInt() {
			fmt.Println($1.Num().String())
		} else {
			fmt.Println($1.String())
		}
	}

expr:
	expr1
|	'+' expr
	{
		$$ = $2
	}
|	'-' expr
	{
		$$ = $2.Neg($2)
	}

expr1:
	expr2
|	expr1 '+' expr2
	{
		$$ = $1.Add($1, $3)
	}
|	expr1 '-' expr2
	{
		$$ = $1.Sub($1, $3)
	}

expr2:
	expr3
|	expr2 '*' expr3
	{
		$$ = $1.Mul($1, $3)
	}
|	expr2 '/' expr3
	{
		$$ = $1.Quo($1, $3)
	}

expr3:
	NUM
|	'(' expr ')'
	{
		$$ = $2
	}
</code></pre><h3 id="ユーザ定義部">ユーザ定義部</h3>
<p>コードを書けてそのまま出力されるが、別のgoファイルに分けた方がエディタのシンタックスハイライトやエラーチェックが効くので書きやすいと思う。</p>
<pre><code>...
func main() {
	in := bufio.NewReader(os.Stdin)
	for {
		if _, err := os.Stdout.WriteString(&quot;&gt; &quot;); err != nil {
			log.Fatalf(&quot;WriteString: %s&quot;, err)
		}
		line, err := in.ReadBytes('\n')
		if err == io.EOF {
			return
		}
		if err != nil {
			log.Fatalf(&quot;ReadBytes: %s&quot;, err)
		}

		exprParse(&amp;exprLex{line: line})
	}
}
</code></pre><p><code>&lt;prefix&gt;Parse</code>はgoyaccによって作られる関数で、<code>Lex(*&lt;prefix&gt;SymType) int</code>と<code>Error(string)</code>を実装したLexerを引数に取る。</p>
<pre><code>// The parser uses the type &lt;prefix&gt;Lex as a lexer. It must provide
// the methods Lex(*&lt;prefix&gt;SymType) int and Error(string).
type exprSymType struct {
    yys int
    num *big.Rat
}
type exprLexer interface {
    Lex(lval *exprSymType) int
    Error(s string)
}
func exprParse(exprlex exprLexer) int {
    return exprNewParser().Parse(exprlex)
}
</code></pre><p><code>Lex()</code>は値を<code>*&lt;prefix&gt;SymType</code>に入れて、一文字記号はそのruneをintにキャストしたものを、それ以外のtoken(NUM)はgoyaccによって数値が割り当てられているのでそれを返す。
最後まで読んだら0を返す。</p>
<pre><code>const eof = 0

func (x *exprLex) Lex(yylval *exprSymType) int {
	for {
		c := x.next()
		switch c {
		case eof:
			return eof
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			return x.num(c, yylval)
		case '+', '-', '*', '/', '(', ')':
			return int(c)

		// Recognize Unicode multiplication and division
		// symbols, returning what the parser expects.
		case '×':
			return '*'
		case '÷':
			return '/'

		case ' ', '\t', '\n', '\r':
		default:
			log.Printf(&quot;unrecognized character %q&quot;, c)
		}
	}
}

const NUM = 57346

func (x *exprLex) num(c rune, yylval *exprSymType) int {
        add := func(b *bytes.Buffer, c rune) {
                if _, err := b.WriteRune(c); err != nil {
                        log.Fatalf(&quot;WriteRune: %s&quot;, err)
                }
        }
        var b bytes.Buffer
        add(&amp;b, c)
L:
        for {
                c = x.next()
                switch c {
                case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E':
                        add(&amp;b, c)
                default:
                        break L
                }
        }
        if c != eof {
                x.peek = c
        }
        yylval.num = &amp;big.Rat{}
        _, ok := yylval.num.SetString(b.String())
        if !ok {
                log.Printf(&quot;bad number %q&quot;, b.String())
                return eof
        }
        return NUM
}
</code></pre><h2 id="conscarcdr評価器を作る">cons,car,cdr評価器を作る</h2>
<p>ということでcons,car,cdr評価器を作る。全体のコードはGitHubにある。</p>
<p><a href="https://github.com/sambaiz/goyacc-carcdr-evaluator">sambaiz/goyacc-carcdr-evaluator</a></p>
<h3 id="yacc文法ファイル-1">yacc文法ファイル</h3>
<p>文法ファイルのコードは最低限にして同じpackageのgoファイルに書いているのでユーザ定義部は空。</p>
<pre><code>%{

package parser

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;strconv&quot;
)

%}

%union {
	value *Value
	num float64
}

%type &lt;value&gt; expr list nil atom 

%token CAR CDR CONS NIL

%token &lt;num&gt; NUM

%%

expr:
	list
|	atom

list:
	'(' CAR list ')'
	{
		$$ = $3.Left
	}
|	'(' CDR list ')'
	{
		$$ = $3.Right
	}
|	'(' CONS expr expr ')'
	{
		$$ = &amp;Value{Left: $3, Right: $4}
	}
|	nil

nil:
	NIL
	{
		$$ = &amp;Value{IsNil: true}
	}
|	'(' ')'
	{
		$$ = &amp;Value{IsNil: true}
	}

atom: 
	NUM
	{
		$$ = &amp;Value{Num: $1}
	}

%%
</code></pre><h3 id="lexer">Lexer</h3>
<p>サンプルコードをベースにcons,car,cdr,nilに対応した。</p>
<pre><code>package parser

import (
	&quot;bytes&quot;
	&quot;errors&quot;
	&quot;log&quot;
	&quot;strconv&quot;
	&quot;unicode&quot;
	&quot;unicode/utf8&quot;
)

type lexer struct {
	line []byte
	peek *rune
	err error
}

func newLexer(line []byte) *lexer {
	return &amp;lexer{
		line: line,
	}
}

const eof = 0

func (x *lexer) Lex(yylval *exprSymType) int {
	for {
		c := x.next()
		if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z'  {
			return x.token(c, yylval)
		}
		switch c {
		case eof:
			return eof
		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			return x.num(c, yylval)
		case '(', ')':
			return int(c)

		case ' ', '\t', '\n', '\r':
		default:
			log.Printf(&quot;unrecognized character %q&quot;, c)
		}
	}
}

func (x *lexer) next() rune {
	...
}

func (x *lexer) num(c rune, yylval *exprSymType) int {
	...
}

var tokenMap = map[string]int{
	&quot;car&quot;: CAR,
	&quot;cdr&quot;: CDR,
	&quot;cons&quot;: CONS,
	&quot;nil&quot;: NIL,
}

func (x *lexer) token(c rune, yylval *exprSymType) int {
	add := func(b *bytes.Buffer, c rune) {
		if _, err := b.WriteRune(c); err != nil {
			log.Fatalf(&quot;WriteRune: %s&quot;, err)
		}
	}
	var b bytes.Buffer
	add(&amp;b, unicode.ToLower(c))
	for {
		c = x.next()
		if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {
			add(&amp;b, unicode.ToLower(c))
		} else {
			x.peek = &amp;c
			break
		}
	}
	token, ok := tokenMap[b.String()]
	if !ok {
		log.Printf(&quot;unknown token %q&quot;, b.String())
		return eof
	}
	return token
}


func (x *lexer) Error(s string) {
	x.err = errors.New(s)
}
</code></pre><p>テストを書く。</p>
<pre><code>package parser

import (
	&quot;fmt&quot;
	&quot;github.com/stretchr/testify/assert&quot;
	&quot;testing&quot;
)

func TestLexerLex(t *testing.T) {
	tests := []struct {
		expr []byte
		outs []int
		symTypes []*exprSymType
	} {
		{
			expr: []byte(&quot;123.456&quot;),
			outs: []int{NUM},
			symTypes: []*exprSymType{
				{
					num: 123.456,
				},
			},
		},
		{
			expr: []byte(&quot;(cons 1 2)&quot;),
			outs: []int{'(', CONS, NUM, NUM, ')'},
			symTypes: []*exprSymType{
				{},
				{},
				{
					num: 1,
				},
				{
					num: 2,
				},
				{},
			},
		},
		{
			expr: []byte(&quot;(cdr (CONS (car (cons () NIL)) 1e5))&quot;),
			outs: []int{'(', CDR, '(', CONS, '(', CAR, '(', CONS, '(', ')', NIL, ')', ')', NUM, ')', ')'},
			symTypes: []*exprSymType{
				{},
				{}, // CDR
				{},
				{}, // CONS
				{},
				{}, // CAR
				{},
				{}, // CONS
				{},
				{},
				{}, // NIL
				{},
				{},
				{
					num: 1e5,
				},
				{},
				{},
			},
		},
	}
	for _, test := range tests {
		t.Run(fmt.Sprintf(&quot;%s -&gt; %v&quot;, string(test.expr), test.outs), func(t *testing.T) {
			i := 0
			lexer := newLexer([]byte(test.expr))
			for {
				symType := &amp;exprSymType{}
				char := lexer.Lex(symType)
				if char == eof {
					break
				}
				assert.Equal(t, test.outs[i], char)
				assert.Equal(t, test.symTypes[i], symType)
				i++
			}
			assert.Equal(t, i, len(test.outs))
		})
	}
}
</code></pre><h3 id="parser">Parser</h3>
<p>サンプルでは直接<code>&lt;prefix&gt;Parse()</code>を呼んでいたが、評価した値を扱えるように<code>&lt;prefix&gt;ParserImpl</code>からParseする。</p>
<pre><code>package parser

func Parse(line string) (*Value, error) {
	exprErrorVerbose = true
	parser := &amp;exprParserImpl{}
	lexer := newLexer([]byte(line))
	parser.Parse(lexer)
	if lexer.err != nil {
		return nil, lexer.err
	}
	if len(parser.stack) &lt; 2 {
		return nil, nil
	}
	return parser.stack[1].value, nil
}
</code></pre><pre><code>package parser

import (
	&quot;github.com/stretchr/testify/assert&quot;
	&quot;testing&quot;
)

func TestParse(t *testing.T) {
	tests := []struct {
		in string
		expected string
	} {
		{
			in: &quot;123.456&quot;,
			expected: &quot;123.456&quot;,
		},
		{
			in: &quot;(cdr (CONS (car (cons () NIL)) 1e5))&quot;,
			expected: &quot;100000&quot;,
		},
		{
			in: &quot;(cons (cons 1 2) 3)&quot;,
			expected: &quot;((1 . 2) . 3)&quot;,
		},
	}
	for _, test := range tests {
		t.Run(test.in, func(t *testing.T) {
			out, err := Parse(test.in)
			assert.Equal(t, test.expected, out.String())
			assert.Nil(t, err)
		})
	}
}
</code></pre><h3 id="実行結果">実行結果</h3>
<p>動いた。</p>
<pre><code>$ go run main.go
&gt; (car (cdr (cons 1 (cons (cons 20 300.4) (cons 50 60)))))
(20 . 300.4)
</code></pre><h2 id="参考">参考</h2>
<p><a href="https://www.eidos.ic.i.u-tokyo.ac.jp/~tau/lecture/programming_languages/gen/slides/pdf/09-lexer-parser.pdf">プログラミング言語 8 字句解析器(lexer)と構文解析器(parser)</a></p>
<p><a href="http://i.loveruby.net/ja/rhg/book/yacc.html">第9章 速習yacc</a></p>

        </div>
      </article>
    </div>
  </div>
</div>

</div> 
<script src="//code.jquery.com/jquery-2.1.3.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script src="/js/slidebars.min.js"></script>
<script>
    ( function ( $ ) {
      
      var controller = new slidebars();
      controller.init();

      $( '.toggle-side' ).on( 'click', function ( event ) {
          event.stopPropagation();
          event.preventDefault();

          controller.toggle( 'id-1' );
        } );

        $( '#container' ).on( 'click', function ( event ) {
            controller.close( 'id-1' );
          });
    } ) ( jQuery );
</script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-39190067-3', 'auto');
ga('send', 'pageview');
</script>


  </body>
</html>

