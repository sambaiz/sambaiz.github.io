<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>http://sambaiz.net/tags/oauth/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>OAuth2.0のメモ</title>
          <link>http://sambaiz.net/article/48/</link>
          <pubDate>Sun, 08 Jan 2017 02:00:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/48/</guid>
          <description>

&lt;h2 id=&#34;認可-authorization-と認証-authentication&#34;&gt;認可(Authorization)と認証(Authentication)&lt;/h2&gt;

&lt;p&gt;それぞれAuthZ、AuthNとも書かれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;認可: リソースへのアクセスを許可する&lt;/li&gt;
&lt;li&gt;認証: ユーザーが何者かを検証する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;oauth2-0&#34;&gt;OAuth2.0&lt;/h2&gt;

&lt;p&gt;認可のプロトコル。
それによってアクセスできるようになったリソースの情報をもとに他のサービスが認証を行ったりしている。&lt;/p&gt;

&lt;h3 id=&#34;authorization-code-flow&#34;&gt;Authorization Code Flow&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/48_authcode.png&#34; alt=&#34;シーケンス図&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OAuthクライアントがアプリケーションサーバーのときのフロー。&lt;/p&gt;

&lt;p&gt;まずユーザーがOAuth認可ページで認可する。
このリクエストには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;client_id&lt;/li&gt;
&lt;li&gt;redirect_uri&lt;/li&gt;
&lt;li&gt;scope: アクセスできるリソースの種類&lt;/li&gt;
&lt;li&gt;response_type=code: 認可コードが返される&lt;/li&gt;
&lt;li&gt;state: CSRFを防ぐためのランダムで一意な文字列。アプリケーションサーバーが保持して、前後で一致するかチェックする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;が含まれる。&lt;/p&gt;

&lt;p&gt;認可されると認可コードとstateを付けてredirect_uriにリダイレクトするので、
アプリケーションサーバーは認可コードをアクセストークンに交換する。
この際、client_idとclient_secretも送って認証する。&lt;/p&gt;

&lt;p&gt;オプションでリフレッシュトークンを含み、これを使うと期限が切れたとき新しいアクセストークンを取得できる。&lt;/p&gt;

&lt;p&gt;アクセストークンは通常Bearer Token(Authorization: Bearer ***)としてリクエストに含まれる。&lt;/p&gt;

&lt;h3 id=&#34;implicit-flow&#34;&gt;Implicit Flow&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/48_implicit.png&#34; alt=&#34;シーケンス図&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OAuthクライアントがブラウザのときのフロー。
つまりclient_secretの機密性を保てないパターン。&lt;/p&gt;

&lt;p&gt;認可コードは不要なので&lt;code&gt;response_type=token&lt;/code&gt;でリクエストし、アクセストークンをブラウザで取得する。
リフレッシュトークンは含まない。
これをそのまま認証に使うと、他のサービスで発行された他人のトークンを使うことでなりすませてしまうので、
そのトークンがどのサービスに対して発行されたかを確認する術が必要。&lt;/p&gt;

&lt;p&gt;redirect_uriは&lt;a href=&#34;https://tools.ietf.org/html/rfc6749#section-3.1.2.2&#34;&gt;事前に登録しておく必要がある。&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873115580/&#34;&gt;O&amp;rsquo;Reilly Japan - OAuth 2.0をはじめよう&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://oauth.jp/blog/2014/05/07/covert-redirect-in-implicit-flow/&#34;&gt;Implicit Flow では Covert Redirect で Token 漏れるね - OAuth.jp&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
