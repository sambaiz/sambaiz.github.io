<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/web/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Headless Chromeでファイルをダウンロードする</title>
          <link>https://www.sambaiz.net/article/131/</link>
          <pubDate>Sun, 03 Sep 2017 18:51:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/131/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://chromedevtools.github.io/devtools-protocol/&#34;&gt;Chrome DevTools Protocol&lt;/a&gt;に
Experimentalだけど&lt;a href=&#34;https://chromedevtools.github.io/devtools-protocol/tot/Page#method-setDownloadBehavior&#34;&gt;Page.setDownloadBehavior&lt;/a&gt;
というのがあったので、これを呼んでファイルをダウンロードしてみた。&lt;/p&gt;

&lt;p&gt;今回は公式のDevToolsのNode API、&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer&#34;&gt;Puppeteer&lt;/a&gt;を使うけど、
setDownloadBehaviorを送るAPIはまだ&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer/blob/64124df62f4e81999fe1a0ab45c6fb9718a0e413/lib/Page.js#L29&#34;&gt;なく&lt;/a&gt;、直接clientを取ってsendするので他の言語でもやることは変わらないと思う。
Puppeteerのインストールの際にChromiumも入る。setDownloadBehaviorは現行Chromeの60では&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=696481&#34;&gt;対応していない&lt;/a&gt;ようだけど、62が入ったのでなんとかなりそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add puppeteer
$ find . -name &amp;quot;*chrome*&amp;quot;
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac/Chromium.app/Contents/Versions/62.0.3198.0/Chromium Framework.framework/Versions/A/Resources/chrome_100_percent.pak
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac/Chromium.app/Contents/Versions/62.0.3198.0/Chromium Framework.framework/Versions/A/Resources/chrome_200_percent.pak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChromeでChromeをダウンロードする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const puppeteer = require(&#39;puppeteer&#39;),
      fs        = require(&#39;fs&#39;);

const headless     = true,
      downloadPath = &#39;./Download&#39;;

(async () =&amp;gt; {
  const browser = await puppeteer.launch({headless: headless});
  
  const page = await browser.newPage();
  await page._client.send(
    &#39;Page.setDownloadBehavior&#39;,
    {behavior : &#39;allow&#39;, downloadPath: downloadPath}
  );

  await page.goto(&#39;https://www.google.co.jp/chrome/browser/desktop/index.html&#39;, {waitUntil: &#39;networkidle&#39;});
  await page.click(&#39;a.download-button&#39;);  /* Chromeをダウンロード         */
  await page.click(&#39;button#eula-accept&#39;); /* 利用規約に同意してインストール */

  await waitDownloadComplete(downloadPath)
        .catch((err) =&amp;gt; console.error(err));
 
  console.log(&#39;finished&#39;);
  browser.close();  
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルがダウンロードできたかどうかは.crdownloadのありなしで判定している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const waitDownloadComplete = async (path, waitTimeSpanMs = 1000, timeoutMs = 60 * 1000) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {

    const wait = (waitTimeSpanMs, totalWaitTimeMs) =&amp;gt; setTimeout(
      () =&amp;gt; isDownloadComplete(path).then(
        (completed) =&amp;gt; {
          if (completed) { 
            resolve();
          } else {

            const nextTotalTime = totalWaitTimeMs + waitTimeSpanMs;
            if (nextTotalTime &amp;gt;= timeoutMs) {
              reject(&#39;timeout&#39;);
            }

            const nextSpan = Math.min(
              waitTimeSpanMs,
              timeoutMs - nextTotalTime
            );
            wait(nextSpan, nextTotalTime);
          }           
        }
      ).catch(
        (err) =&amp;gt; { reject(err); }
      ),
      waitTimeSpanMs
    );
    
    wait(waitTimeSpanMs, 0);
  }); 
}

const isDownloadComplete = async (path) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    fs.readdir(path, (err, files) =&amp;gt; {
      if (err) {
        reject(err);
      } else {
        if (files.length === 0) {
          resolve(/* completed */ false);
          return;
        }
        for(let file of files){

          // .crdownloadがあればダウンロード中のものがある
          if (/.*\.crdownload$/.test(file)) { 
            resolve(/* completed */ false);
            return;
          }
        }
        resolve(/* completed */ true);
      }
    });
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;ちなみに、機能としては近い立ち位置の&lt;a href=&#34;http://www.nightmarejs.org/&#34;&gt;NightmareJS&lt;/a&gt;は
v1の&lt;a href=&#34;http://phantomjs.org/&#34;&gt;PhantomJS&lt;/a&gt;、現行v2の&lt;a href=&#34;https://electron.atom.io/&#34;&gt;Electron&lt;/a&gt;を経て
v3ではHeadless Chromeに&lt;a href=&#34;https://github.com/segmentio/nightmare/issues/1092&#34;&gt;なるかもしれない&lt;/a&gt;。
速いし、ウィンドウがないので&lt;a href=&#34;https://en.wikipedia.org/wiki/Xvfb&#34;&gt;xvfb(X virtual framebuffer)&lt;/a&gt;も&lt;a href=&#34;https://developers.google.com/web/updates/2017/04/headless-chrome&#34;&gt;必要ない&lt;/a&gt;し良さそうなんだけど、
現在のChrome DevTools ProtocolではNightmareの既存APIをサポートできなかったり、
Puppeteerとの住み分けはどうするのって話になっているみたいだ。&lt;/p&gt;

&lt;p&gt;現状Nightmare自体にダウンロード機能は含まれていないが、
Electronの&lt;a href=&#34;https://github.com/electron/electron/blob/master/docs-translations/jp/api/download-item.md&#34;&gt;will-download&lt;/a&gt;イベントを
ハンドリングする
&lt;a href=&#34;https://github.com/rosshinkley/nightmare-download-manager&#34;&gt;nightmare-download-manager&lt;/a&gt;や
&lt;a href=&#34;https://github.com/rosshinkley/nightmare-inline-download&#34;&gt;nightmare-inline-download&lt;/a&gt;
といったライブラリがある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CloudflareでカスタムドメインのGitHub PagesにHTTPSでアクセスできるようにする</title>
          <link>https://www.sambaiz.net/article/127/</link>
          <pubDate>Mon, 21 Aug 2017 23:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/127/</guid>
          <description>

&lt;p&gt;このサイトはGitHub Pagesでカスタムドメインsambaiz.netを設定して、
Apex Domain(sambaiz.net)に&lt;a href=&#34;https://help.github.com/articles/setting-up-an-apex-domain/&#34;&gt;Aレコード&lt;/a&gt;を登録して運用していたのだけれど、これだとカスタムドメインの証明書を置けないのでHTTPSでアクセスすると警告が出てしまう。
いい加減HTTPだと許されない風潮になってきたのでCloudflareを前に挟んでHTTPSでアクセスできるようにした。
ついでにCNAMEを登録できないApex Domain(sambaiz.net)をやめてwww.sambaiz.netに向ける。&lt;/p&gt;

&lt;h2 id=&#34;dnsの設定をする&#34;&gt;DNSの設定をする&lt;/h2&gt;

&lt;p&gt;Cloudflareでドメインを入れると既存のDNS Recordsを読み込むので必要に応じて修正する。
Cloudflareでは&lt;a href=&#34;https://support.cloudflare.com/hc/en-us/articles/200169056-CNAME-Flattening-RFC-compliant-support-for-CNAME-at-the-root&#34;&gt;CNAME Flattening&lt;/a&gt;によってApex Domainにも設定上ではCNAMEを与えることができ、内部でAレコードに解決してくれる。
そのためApex Domainをそのまま使っても実は問題ないのだけど、今後のために変えておく。
www.sambaiz.netにGitHub PagesのCNAMEを設定し、sambaiz.net(@)にはwww.sambaiz.netをCNAMEとして設定した。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/127.png&#34; alt=&#34;DNS設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;あとGitHub Pagesの方のカスタムドメインもwww.sambaiz.netにした。
wwwを設定するとApex Domainでアクセスしたときにリダイレクトするように&lt;a href=&#34;https://help.github.com/articles/setting-up-an-apex-domain-and-www-subdomain/&#34;&gt;なっている&lt;/a&gt;ので
既存のリンクが切れたり混在することはない。&lt;/p&gt;

&lt;p&gt;指示された&lt;code&gt;*.ns.cloudflare.com&lt;/code&gt;のようなCloudflareのネームサーバーをドメインに設定する。
さくらの場合、Apex Domainのネームサーバーはゾーン表示ではなくWHOIS情報のところから変更できる。
設定してしばらくするとCloudflareを通してアクセスが飛び警告なくHTTPSでアクセスできるようになる。
証明書は共有のものになっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/127-2.png&#34; alt=&#34;共有証明書&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正常にアクセスできることを確認できたら今HTTPになっている画像やリンクもHTTPSにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -name &#39;.git*&#39; -prune -o -name &#39;public&#39; -prune -o -name &#39;static&#39; -prune -o -type d -o -print | xargs sed -i &amp;quot;&amp;quot; &amp;quot;s/http:\/\/sambaiz.net/https:\/\/www.sambaiz.net/g&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cloudflareの機能&#34;&gt;Cloudflareの機能&lt;/h2&gt;

&lt;p&gt;Cloudflareにはいくつか&lt;a href=&#34;https://www.cloudflare.com/plans/&#34;&gt;プラン&lt;/a&gt;があって、今回はFreeプランにした。&lt;/p&gt;

&lt;h3 id=&#34;analytics&#34;&gt;Analytics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;キャッシュされている/ないリクエスト数や帯域、それによる節約量&lt;/li&gt;
&lt;li&gt;ブロックした&lt;a href=&#34;https://support.cloudflare.com/hc/en-us/articles/204191238-What-are-the-types-of-Threats-&#34;&gt;脅威&lt;/a&gt;の数&lt;/li&gt;
&lt;li&gt;何人/どこの国からアクセスが来たか&lt;/li&gt;
&lt;li&gt;コンテンツ(HTML/CSS/PNG)ごとのリクエストの割合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがわかる。FreeだとWeb TrafficやGeographyが直近24時間より短いスパンで取れない。&lt;/p&gt;

&lt;h3 id=&#34;crypto&#34;&gt;Crypto&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cloudflare.com/ssl/&#34;&gt;SSL&lt;/a&gt;まわりの設定。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Flexible: クライアントとCloudflareはHTTPS、CloudflareとオリジンサーバーはHTTPで通信する。&lt;/li&gt;
&lt;li&gt;Full: デフォルト。Cloudflareとオリジンサーバーの通信もHTTPSで行うが、証明書の検証は行われない。&lt;/li&gt;
&lt;li&gt;Full(Strict) 証明書の検証も行う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;から選択する。Business以上のPlanだと共有の証明書ではなく独自のものを上げることもできる。&lt;/p&gt;

&lt;p&gt;HTTPで来たらHTTPSにリダイレクトさせるのと、ブラウザでHTTPをHTTPSに置き換える&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/Security/HTTP_Strict_Transport_Security&#34;&gt;HTTP Strict Transport Security(HSTS)&lt;/a&gt;
の設定もある。
HSTSを設定するときに出るように
将来HTTPSをサポートしなくなった場合、HSTSの期限が残っているブラウザからはアクセスできなくなるので注意。
まあ今後HTTPのみに戻すということは考えにくいのだけど、推奨の有効期限は6ヶ月になっている。
あとNo-Sniff Headerの設定もここにあって、これをオンのままにしておくとContent-Typeがtext/cssでない
styleやJavaScriptのMIME Typeでないscriptのリクエストは&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options&#34;&gt;ブロック&lt;/a&gt;しXSSを防ぐ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Strict-Transport-Security: max-age=15552000
X-Content-Type-Options: nosniff
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;firewall&#34;&gt;Firewall&lt;/h3&gt;

&lt;p&gt;IPアドレスや国でブロックしたりとか。Pro以上のプランだと&lt;a href=&#34;https://www.cloudflare.com/waf/&#34;&gt;Web Application Firewall&lt;/a&gt;を有効にできる。&lt;/p&gt;

&lt;h3 id=&#34;speed&#34;&gt;Speed&lt;/h3&gt;

&lt;p&gt;JS/CSS/HTMLを自動でMinifyしたり、モバイルの場合リダイレクトさせたりできる。
Proプランでは画像を最適化してくれる。&lt;/p&gt;

&lt;h3 id=&#34;caching&#34;&gt;Caching&lt;/h3&gt;

&lt;p&gt;キャッシュをパージしたり、どのレベルでキャッシュするかの設定など。&lt;/p&gt;

&lt;h3 id=&#34;page-rules&#34;&gt;Page Rules&lt;/h3&gt;

&lt;p&gt;URL単位でルールを設定できる。example.com/hoge/*は静的なページなのでHTMLもキャッシュするとか。
3つルールが作れて、5つ追加するのに月5ドル。&lt;/p&gt;

&lt;h3 id=&#34;network&#34;&gt;Network&lt;/h3&gt;

&lt;p&gt;最大アップロードサイズやWebSocketを有効にするかなどの設定。
ユーザーのIPアドレスをTrue-Client-IPに乗せるのはEnterpriseプランが必要。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CSSのdisplayとposition</title>
          <link>https://www.sambaiz.net/article/98/</link>
          <pubDate>Sat, 06 May 2017 14:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/98/</guid>
          <description>

&lt;h2 id=&#34;display-https-developer-mozilla-org-ja-docs-web-css-display&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/display&#34;&gt;display&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;レンダリングに使うボックスを指定する。&lt;/p&gt;

&lt;h3 id=&#34;outer-display-type&#34;&gt;outer display type&lt;/h3&gt;

&lt;p&gt;pのようなブロックレベル要素やspanのようなインラインレベル要素に関わらず、指定したボックスにレンダリングする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99.png&#34; alt=&#34;outer display type&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:none&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;none&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;p style=&amp;quot;display:inline&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline&amp;lt;/p&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;this is &amp;lt;span style=&amp;quot;display:inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block&amp;lt;/span&amp;gt; desu&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;中央寄せ&#34;&gt;中央寄せ&lt;/h3&gt;

&lt;p&gt;中央寄せはblockにwidthを設定して&lt;code&gt;margin auto&lt;/code&gt;するか、
親要素で&lt;code&gt;text-align: center&lt;/code&gt;してinline(-block)にする。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99-center.png&#34; alt=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  height: 80px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block margin width&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;margin: 5 auto; display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block margin&amp;lt;/div&amp;gt;

&amp;lt;div style=&amp;quot;text-align: center&amp;quot;&amp;gt;
  
  &amp;lt;div style=&amp;quot;display: inline-block&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;inline-block align-center&amp;lt;/div&amp;gt;
  
  &amp;lt;div style=&amp;quot;width: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;block align-center width&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flex-https-developer-mozilla-org-ja-docs-web-css-css-flexible-box-layout-using-css-flexible-boxes&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes&#34;&gt;flex&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;displayでflexを指定するとflex containerになる。
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-flow&#34;&gt;flex-flow&lt;/a&gt;は
表示する方向の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-direction&#34;&gt;flex-direction&lt;/a&gt;と
折り返しの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-wrap&#34;&gt;flex-wrap&lt;/a&gt;のショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;子要素の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex&#34;&gt;flex&lt;/a&gt;は
伸びるときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-grow&#34;&gt;flex-grow&lt;/a&gt;(default: 0)と
縮むときの倍率の&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-shrink&#34;&gt;flex-shrink&lt;/a&gt;(default: 1)、
初期サイズの&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/flex-basis&#34;&gt;flex-basis&lt;/a&gt;(default: auto)の
ショートハンドプロパティ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99-flex.png&#34; alt=&#34;flex&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  this is
  &amp;lt;div style=&amp;quot;display:flex; flex-flow: row wrap&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;flex: auto; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item1&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 300px; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item2&amp;lt;/div&amp;gt;

    &amp;lt;!-- flex-grow | flex-shrink | flex-basis --&amp;gt;
    &amp;lt;div style=&amp;quot;flex: 0 1 30%; margin: 2px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;flex-item3&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  desu
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;position-https-developer-mozilla-org-ja-docs-web-css-position&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/position&#34;&gt;position&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;relative&#34;&gt;relative&lt;/h3&gt;

&lt;p&gt;この設定を考慮せずにすべての要素を配置した後に設定を適用する。
そのため、この例の3つ目のdivの&lt;code&gt;left: 30px&lt;/code&gt;は2つ目のdivの元々の位置から30px右になっている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99-relative.png&#34; alt=&#34;relative&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 30px; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;bbb&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; left: 30px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;ccc&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;absolute&#34;&gt;absolute&lt;/h3&gt;

&lt;p&gt;絶対位置で指定する。位置指定された祖先要素の相対的な位置になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99-absolute.png&#34; alt=&#34;absolute&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div&amp;gt;
  &amp;lt;div class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
  &amp;lt;div style=&amp;quot;position: relative; top: 50px&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;background-color: #eeeeee&amp;quot;&amp;gt;relative top 50px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;position: absolute; left: 100px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;left 100px&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fixed&#34;&gt;fixed&lt;/h3&gt;

&lt;p&gt;ビューポートに対して絶対的な位置を指定する。この例では2つ目のfixedなdivはスクロールしてもビューポートに対して位置が固定される。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/99-fixed.png&#34; alt=&#34;fixed&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bg {
  display: inline-block;
  background-color: #22ee22;
  width: 150px;
  height: 50px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div style=&amp;quot;height: 3000px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;aaa&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;position: fixed; top: 50px; left: 300px&amp;quot; class=&amp;quot;bg&amp;quot;&amp;gt;top 50px; left: 300px&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Firebaseをwebで使う(Hosting, Authentication, Realtime Database, Storage)</title>
          <link>https://www.sambaiz.net/article/94/</link>
          <pubDate>Sun, 16 Apr 2017 20:03:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/94/</guid>
          <description>

&lt;h2 id=&#34;firebase-https-firebase-google-com-hl-ja-とは&#34;&gt;&lt;a href=&#34;https://firebase.google.com/?hl=ja&#34;&gt;Firebase&lt;/a&gt;とは&lt;/h2&gt;

&lt;p&gt;GoogleのmBaaS。Android/iOSアプリの開発に使う認証、データストア、クラッシュレポート、分析、通知、広告などなど全部入りサービス。
今年のGoogleI/Oでも&lt;a href=&#34;https://events.google.com/io/schedule/?section=may-19&#34;&gt;毎時間のように&lt;/a&gt;
Firebaseのセッションがあって大分推している印象。&lt;/p&gt;

&lt;p&gt;基本的にはアプリで使うのだけれど、webで使える機能も結構ある。今回は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hosting&lt;/li&gt;
&lt;li&gt;Authentication&lt;/li&gt;
&lt;li&gt;Realtime Database&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を使ってみる。&lt;/p&gt;

&lt;h2 id=&#34;料金-https-firebase-google-com-pricing&#34;&gt;&lt;a href=&#34;https://firebase.google.com/pricing/&#34;&gt;料金&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;プランは無料のSPARKと25ドル/月のFLAME、従量課金のBLAZEがある。
試す分にはSPARKで十分だけど、Realtime Databaseの同時接続数が100なので注意。&lt;/p&gt;

&lt;h2 id=&#34;セットアップ-https-firebase-google-com-docs-web-setup&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/web/setup&#34;&gt;セットアップ&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/cli/&#34;&gt;firebase-cli&lt;/a&gt;をインストール、ログインして初期化する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g firebase-tools
$ firebase login
$ mkdir firebase-chat &amp;amp;&amp;amp; cd firebase-chat
$ firebase init
...
? What Firebase CLI features do you want to setup for this folder? 
❯◉ Database: Deploy Firebase Realtime Database Rules
 ◉ Functions: Configure and deploy Cloud Functions
 ◉ Hosting: Configure and deploy Firebase Hosting sites

? What Firebase project do you want to associate as default? *****

? What file should be used for Database Rules? database.rules.json

? Do you want to install dependencies with npm now? Yes

? What do you want to use as your public directory? public

? Configure as a single-page app (rewrite all urls to /index.html)? Yes

✔  Firebase initialization complete!

$ ls
database.rules.json	firebase.json		functions		public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;firebase.jsonはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat firebase.json
{
  &amp;quot;database&amp;quot;: {
    &amp;quot;rules&amp;quot;: &amp;quot;database.rules.json&amp;quot;
  },
  &amp;quot;hosting&amp;quot;: {
    &amp;quot;public&amp;quot;: &amp;quot;public&amp;quot;,
    &amp;quot;rewrites&amp;quot;: [
      {
        &amp;quot;source&amp;quot;: &amp;quot;**&amp;quot;,
        &amp;quot;destination&amp;quot;: &amp;quot;/index.html&amp;quot;
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ローカルでサーバーを立ち上げて確認する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase serve
Server listening at: http://localhost:5000

$ curl http://localhost:5000 # Firebase SDK loaded with auth, database, messaging, storage
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hosting-https-firebase-google-com-docs-hosting-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/hosting/?hl=ja&#34;&gt;Hosting&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;静的サイトのホスティング。もちろん独自ドメインも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only hosting
...
✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/*****/overview
Hosting URL: https://*****.firebaseapp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;authentication-https-firebase-google-com-docs-auth&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/auth/&#34;&gt;Authentication&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ユーザー認証。Googleだけではなく、TwitterやFacebook、Githubといったプロバイダや、メールとパスワードでの認証が用意されていて、
コンソールから有効にする必要がある。&lt;/p&gt;

&lt;p&gt;実装はFirebase SDKで自分でやるか、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const provider = new firebase.auth.GoogleAuthProvider();
firebase.auth().signInWithPopup(provider).then((result) =&amp;gt; {
    console.log(`sign in successfully. ${result.user.displayName}`)
}).catch((error) =&amp;gt; {
    console.log(`fail to sign in. ${error.message}`)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/firebase/FirebaseUI-Web&#34;&gt;FirebaseUI Auth&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script defer src=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link type=&amp;quot;text/css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.firebase.com/libs/firebaseui/1.0.1/firebaseui.css&amp;quot; /&amp;gt;

&amp;lt;div id=&amp;quot;firebaseui-auth-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// FirebaseUI config.
var uiConfig = {
  signInOptions: [
    // Leave the lines as is for the providers you want to offer your users.
    firebase.auth.GoogleAuthProvider.PROVIDER_ID
  ],
  callbacks: {
    signInSuccess: function(currentUser, credential, redirectUrl) {
      // リダイレクトさせない
      return false;
    }
  },
  // Terms of service url.
  tosUrl: &#39;&amp;lt;your-tos-url&amp;gt;&#39;
};

// Initialize the FirebaseUI Widget using Firebase.
var ui = new firebaseui.auth.AuthUI(firebase.auth());
// The start method will wait until the DOM is loaded.
ui.start(&#39;#firebaseui-auth-container&#39;, uiConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じにボタンが並ぶ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/93-firebase-authentication.png&#34; alt=&#34;Firebase authentication&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;onAuthStateChanged()&lt;/code&gt;でsign in/outをハンドリングでき、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firebase.auth().onAuthStateChanged((user) =&amp;gt; {
    if (user) {
      console.log(`${user.displayName} sign in`);
    } else {
      console.log(&#39;sign out&#39;);
    }
  }, (error) =&amp;gt; {
    console.log(error);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;currentUserでsign inしてるユーザーを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(firebase.auth().currentUser){
  console.log(firebase.auth().currentUser.displayName);
}else{
  // need to sign in
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;realtime-database-https-firebase-google-com-docs-database&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/&#34;&gt;Realtime Database&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NoSQLなデータベース。直接読み書きするのではなく、
ローカルにデータを保存してリアルタイムに同期するため一時的にオフライン状態になっても読み書きできる。&lt;/p&gt;

&lt;h3 id=&#34;読み書き-https-firebase-google-com-docs-database-web-read-and-write&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/web/read-and-write&#34;&gt;読み書き&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;データベースへの書き込みと更新。refで&lt;code&gt;users/1&lt;/code&gt;のように参照を取って操作する。
&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#push&#34;&gt;push()&lt;/a&gt;で
&lt;code&gt;hoge/-Khp36CCygw5AI6G8L1B&lt;/code&gt;のようなユニークなキーを発行することができ、これは時系列にソートされるようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const database = firebase.database();

for(let i = 0; i &amp;lt; 10; i++){
    
    const newHogeRef = database.ref(&#39;hoge&#39;).push();
    console.log(`newHogeRef: ${newHogeRef.toString()}`);
    
    newHogeRef.set({
        idx: i,
        aaa: &amp;quot;bbb123&amp;quot;,
    });

    newHogeRef.update({
        aaa: &amp;quot;bbb456&amp;quot;,
        eee: &amp;quot;fff&amp;quot;
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CCygw5AI6G8L1B
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CLyJ9BQVefW-l5
newHogeRef: https://test-3a363.firebaseio.com/hoge/-Khp36CMs9-jJoKUUgr0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.Reference?hl=ja#on&#34;&gt;on()&lt;/a&gt;で
value eventを拾うと、
呼んだときとデータに変更があったときに&lt;a href=&#34;https://firebase.google.com/docs/reference/js/firebase.database.DataSnapshot?hl=ja&#34;&gt;snapshot&lt;/a&gt;が取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;...
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 7}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 8}
Object {aaa: &amp;quot;bbb456&amp;quot;, eee: &amp;quot;fff&amp;quot;, idx: 9}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス権限-バリデーション-https-firebase-google-com-docs-database-security-securing-data&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data&#34;&gt;アクセス権限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;firebase.jsonで指定しているdatabase ruleファイル(database.rules.json)でルールを設定する。
デフォルトで認証していれば読み書きできる設定になっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read/writeだけではなくバリデーションの設定もこんな感じでできる。
これは&lt;code&gt;users/${ユーザーのuid}&lt;/code&gt;への読み書きを本人のみができるようにするもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ firebase deploy --only database
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の設定を適用したデータベースに読み書きしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const uid = firebase.auth().currentUser.uid;

database.ref(`users/${uid}`).set({
    age: 20,
    name: &amp;quot;taro&amp;quot;
});

// ok: Object {age: 20, name: &amp;quot;taro&amp;quot;}
database.ref(`users/${uid}`).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    console.log(snapshot.val()); // Object {age: 20, name: &amp;quot;taro&amp;quot;}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のような不正なデータや不正なキーに書き込もうとすると
&lt;code&gt;PERMISSION_DENIED: Permission denied&lt;/code&gt;になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ageがおかしい
database.ref(`users/${uid}`).set({
    age: &amp;quot;aaaa&amp;quot;,
    name: &amp;quot;jiro&amp;quot;
});

// 本人じゃない
database.ref(`users/hogehoge`).set({
    age: 20,
    name: &amp;quot;jiro&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、さっきまでアクセスできていたhogeにもアクセスできなくなっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// PERMISSION_DENIED: Permission denied
database.ref(&amp;quot;hoge&amp;quot;).orderByKey().limitToLast(3).on(&amp;quot;value&amp;quot;, (snapshot) =&amp;gt; {
    snapshot.forEach((data) =&amp;gt; console.log(data.val()));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを解決するためにrulesのルートに&lt;code&gt;auth != null&lt;/code&gt;の設定を入れてしまうと、
&lt;a href=&#34;https://firebase.google.com/docs/database/security/securing-data#read_and_write_rules_cascade&#34;&gt;浅い階層のルールが深い階層のルールより優先される&lt;/a&gt;
ためusersのread/writeの設定が無効になってしまうので注意。ただしvalidateはそれぞれの階層でチェックされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;rules&amp;quot;: {
    &amp;quot;.read&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;.write&amp;quot;: &amp;quot;auth != null&amp;quot;,
    &amp;quot;users&amp;quot;: {
      &amp;quot;$uid&amp;quot;: {
        &amp;quot;.read&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.write&amp;quot;: &amp;quot;$uid === auth.uid&amp;quot;,
        &amp;quot;.validate&amp;quot;: &amp;quot;newData.hasChildren([&#39;age&#39;, &#39;name&#39;]) &amp;amp;&amp;amp; newData.child(&#39;age&#39;).isNumber() &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;gt;= 0 &amp;amp;&amp;amp; newData.child(&#39;age&#39;).val() &amp;lt; 200 &amp;amp;&amp;amp; newData.child(&#39;name&#39;).isString() &amp;amp;&amp;amp; newData.child(&#39;name&#39;).val().length &amp;lt; 50&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;storage-https-firebase-google-com-docs-storage&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/&#34;&gt;Storage&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;画像などを保存しておくために使う。
Realtime Databaseと同様、
ネットワーク品質が良くない環境でも使えるように、処理が中断されても途中から処理を再開するようになっている。
裏側ではGoogle Cloud Storageが使われている。&lt;/p&gt;

&lt;h3 id=&#34;アップロード-https-firebase-google-com-docs-storage-web-upload-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/upload-files&#34;&gt;アップロード&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;file-upload&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const storage = firebase.storage();

const inputFile = document.getElementById(&#39;file-upload&#39;);

inputFile.addEventListener(&#39;change&#39;, (e) =&amp;gt; {
  const files = e.target.files;
  const user = firebase.auth().currentUser;
  if(user){
    const ref = storage.ref(`images/${user.uid}`);
    const uploadTask = ref.put(files[0]);
  }
}, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中断、再開、キャンセル。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.pause();
uploadTask.resume();
uploadTask.cancel();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アップロードの状態はstage_changed eventで確認し、完了するとダウンロードURLを取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uploadTask.on(&#39;state_changed&#39;, (snapshot) =&amp;gt; {

  const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
  console.log(&#39;Upload is &#39; + progress + &#39;% done&#39;);

  switch (snapshot.state) {
    case firebase.storage.TaskState.PAUSED: // or &#39;paused&#39;
      console.log(&#39;Upload is paused&#39;);
      break;
    case firebase.storage.TaskState.RUNNING: // or &#39;running&#39;
      console.log(&#39;Upload is running&#39;);
      break;
  }
}, (error) =&amp;gt; {
  // Handle unsuccessful uploads
  console.log(error);
}, () =&amp;gt; {
  // Handle successful uploads on complete
  // For instance, get the download URL: https://firebasestorage.googleapis.com/...
  console.log(uploadTask.snapshot.downloadURL);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;アクセス制限-バリデーション-https-firebase-google-com-docs-storage-security-hl-ja&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/security/?hl=ja&#34;&gt;アクセス制限・バリデーション&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Realtime Databaseと同様にアクセス制限やバリデーションをかけることができる。
設定はコンソールから。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/93-firebase-storage-rule.png&#34; alt=&#34;Storageのルール&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service firebase.storage {
  match /b/*****.appspot.com/o {
    match /images/{imageId} {
      // Only allow uploads of any image file that&#39;s less than 5MB
      allow write: if request.resource.size &amp;lt; 5 * 1024 * 1024
                   &amp;amp;&amp;amp; request.resource.contentType.matches(&#39;image/.*&#39;)
                   &amp;amp;&amp;amp; request.auth != null;
      allow read: if request.auth != null;             
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ダウンロード-https-firebase-google-com-docs-storage-web-download-files&#34;&gt;&lt;a href=&#34;https://firebase.google.com/docs/storage/web/download-files&#34;&gt;ダウンロード&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;getDownloadURL()&lt;/code&gt;でURLを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img id=&amp;quot;myimg&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const ref = storage.ref(`images/${user.uid}`).getDownloadURL().then((url) =&amp;gt; {
  
  const img = document.getElementById(&#39;myimg&#39;);
  img.src = url;

}).catch((error) =&amp;gt; {

  switch (error.code) {
    case &#39;storage/object-not-found&#39;:
      console.log(&amp;quot;not found&amp;quot;);
      break;

    default:
      console.log(error);
  }
});;
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Cookieのメモ</title>
          <link>https://www.sambaiz.net/article/69/</link>
          <pubDate>Wed, 22 Feb 2017 20:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/69/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&#34;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レスポンスに&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーが含まれていればブラウザはcookieに保存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエスト時には&lt;code&gt;Cookie&lt;/code&gt;ヘッダーにcookieを入れて送る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CookieにExpire(ある期間まで有効)またはMax-Age(特定の期間の間有効)を設定するとPermanent cookieとなる。
いずれも設定しなかった場合Session cookieとなり、ブラウザを閉じると削除されることになっているが、
ブラウザのセッション復元機能が有効になっていれば永続化される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Secureを付けるとHTTPSでのみ送られる。
また、HttpOnlyはjsから&lt;code&gt;document.cookie&lt;/code&gt;などでアクセスすることができなくなる。
サイトにXSSの脆弱性があるとき、cookieが盗まれてしまうのを防ぐことができるので問題なければ設定するべき。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Domainを指定するとそのドメインとサブドメインへのリクエストのときに送られる。しないとそのドメインだけ。Pathも指定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Domain=example.com; Path=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエストが飛び、&lt;code&gt;Set-Cookie&lt;/code&gt;ヘッダーを受け取ればCookieに書かれるので、アクセスしたサイトのドメイン以外のCookieが書かれることがある。
このようなCookieを3rd party cookieといって、広告のトラッキングによく使われるが、
Safariなどのデフォルト設定では書き込めなくなっている。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
