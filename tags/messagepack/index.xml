<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz.net</title>
    <link>http://sambaiz.net/tags/messagepack/</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>2016-12-30 18:48:00 &#43;0900 JST</updated>

    
      
        <item>
          <title>汎用シリアライズ方法(MessagePack/Protocol Buffers/FlatBuffers)のGoでのベンチマーク</title>
          <link>http://sambaiz.net/article/46/</link>
          <pubDate>Fri, 30 Dec 2016 18:48:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/46/</guid>
          <description>

&lt;h2 id=&#34;messagepackとは&#34;&gt;MessagePackとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://msgpack.org/&#34;&gt;http://msgpack.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JSONのように使うことができ、速くてサイズが小さい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&amp;quot;compact&amp;quot;:true,&amp;quot;スキーマ&amp;quot;:{&amp;quot;number&amp;quot;: 999, &amp;quot;string&amp;quot;: &amp;quot;aaa&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のjson(61bytes)をMessagePack(45bytes)に変換したのがこれ。見やすいように改行している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;82 
a7 63 6f 6d 70 61 63 74 c3 
ac e3 82 b9 e3 82 ad e3 83 bc e3 83 9e 
   82 
   a6 6e 75 6d 62 65 72 cd 03 e7 
   a6 73 74 72 69 6e 67 a3 61 61 61
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一行目の&lt;code&gt;82&lt;/code&gt;は&lt;a href=&#34;https://github.com/msgpack/msgpack/blob/master/spec.md#map-format-family&#34;&gt;要素数2のfixmap(要素数15まで)&lt;/a&gt;を表す。&lt;/p&gt;

&lt;p&gt;二行目の&lt;code&gt;a7&lt;/code&gt;が&lt;a href=&#34;https://github.com/msgpack/msgpack/blob/master/spec.md#str-format-family&#34;&gt;7バイトのfixstr(31bytesまで)&lt;/a&gt;で、
&lt;code&gt;63 6f 6d 70 61 63 74&lt;/code&gt;が&amp;rdquo;compact&amp;rdquo;。&lt;code&gt;c3&lt;/code&gt;は&lt;a href=&#34;https://github.com/msgpack/msgpack/blob/master/spec.md#bool-format-family&#34;&gt;true&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;三行目の&lt;code&gt;ac&lt;/code&gt;は12バイトのfixstrで、&lt;code&gt;e3 82 b9 e3 82 ad e3 83 bc e3 83 9e&lt;/code&gt;が&amp;rdquo;スキーマ&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;四行目はこれのvalueで、要素数2のfixmap(&lt;code&gt;82&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;五行目は6バイトのfixstr(&lt;code&gt;a6&lt;/code&gt;)、&amp;rdquo;number&amp;rdquo;(&lt;code&gt;6e 75 6d 62 65 72&lt;/code&gt;)、
&lt;code&gt;cd&lt;/code&gt;が&lt;a href=&#34;https://github.com/msgpack/msgpack/blob/master/spec.md#int-format-family&#34;&gt;uint16&lt;/a&gt;で、999(&lt;code&gt;03 e7&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;六行目は6バイトのfixstr(&lt;code&gt;a6&lt;/code&gt;)、&amp;rdquo;string&amp;rdquo;(&lt;code&gt;73 74 72 69 6e 67&lt;/code&gt;)、3バイトのfixstr(&lt;code&gt;a3&lt;/code&gt;)、&amp;rdquo;aaa&amp;rdquo;(&lt;code&gt;61 61 61&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;と、こんな感じで分かりやすいバイナリになっている。&lt;/p&gt;

&lt;h3 id=&#34;使い方&#34;&gt;使い方&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/ugorji/go/codec
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;mh := codec.MsgpackHandle{RawToString: true}
origin := serialize.Data{
	Title: &amp;quot;aaaa&amp;quot;,
}

func MessagePackEncode(mh codec.MsgpackHandle, origin Data) []byte {
	var encoded []byte

	enc := codec.NewEncoderBytes(&amp;amp;encoded, &amp;amp;mh)
	if err := enc.Encode(&amp;amp;origin); err != nil {
		panic(err)
	}

	return encoded
}

func MessagePackDecode(mh codec.MsgpackHandle, bytes []byte) Data {
	var decoded Data

	dec := codec.NewDecoderBytes(bytes, &amp;amp;mh)
	if err := dec.Decode(&amp;amp;decoded); err != nil {
		panic(err)
	}

	return decoded
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;protocol-buffersとは&#34;&gt;Protocol Buffersとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;https://developers.google.com/protocol-buffers/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Googleのシリアライズライブラリ。gRPCでも使われる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/12/&#34;&gt;Googleが作ったRPCフレームワークgRPCを使ってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;message typeを&lt;code&gt;proto&lt;/code&gt;ファイルで定義する(proto3)。このファイルから各言語のコードを生成することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;

message SearchResponse {
  repeated Result results = 1;
}

message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;それぞれのmessage typeには名前と型を持つユニークな数値のフィールドが含まれる。一度割り当てた数値のtypeは変更しないようにする。
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#assigning-tags&#34;&gt;(Assigning Tags)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;repeated&lt;/code&gt;は0以上の任意の個数で、順番は保存される。
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules&#34;&gt;(Specifying Field Rules)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;新しいコードがフィールドを追加してメッセージを送ると、古いコードは未知のフィールドを無視する。
逆に、古いコードがメッセージを送ると、
新しいコードの新しいフィールドには&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#default&#34;&gt;デフォルト値&lt;/a&gt;が入る。
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#updating&#34;&gt;(Updating A Message Type)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;使い方-1&#34;&gt;使い方&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;syntax = &amp;quot;proto3&amp;quot;;

message Data {
  string title = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ brew install protobuf
$ protoc --version
libprotoc 3.1.0

$ go get github.com/golang/protobuf/protoc-gen-go

$ mkdir -p build/gen 
$ protoc --proto_path=proto --go_out=data proto/data.proto
$ ls data
data.pb.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// Code generated by protoc-gen-go.
// source: data.proto
// DO NOT EDIT!

/*
Package data is a generated protocol buffer package.

It is generated from these files:
	data.proto

It has these top-level messages:
	Data
*/
package data

import proto &amp;quot;github.com/golang/protobuf/proto&amp;quot;
import fmt &amp;quot;fmt&amp;quot;
import math &amp;quot;math&amp;quot;

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Data struct {
	Title string `protobuf:&amp;quot;bytes,1,opt,name=title&amp;quot; json:&amp;quot;title,omitempty&amp;quot;`
}

func (m *Data) Reset()                    { *m = Data{} }
func (m *Data) String() string            { return proto.CompactTextString(m) }
func (*Data) ProtoMessage()               {}
func (*Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func init() {
	proto.RegisterType((*Data)(nil), &amp;quot;Data&amp;quot;)
}

func init() { proto.RegisterFile(&amp;quot;data.proto&amp;quot;, fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 67 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0x49, 0x2c, 0x49,
	0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x57, 0x92, 0xe1, 0x62, 0x71, 0x49, 0x2c, 0x49, 0x14, 0x12,
	0xe1, 0x62, 0x2d, 0xc9, 0x2c, 0xc9, 0x49, 0x95, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c, 0x82, 0x70,
	0x92, 0xd8, 0xc0, 0x8a, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x0d, 0xbe, 0x9b, 0x32,
	0x00, 0x00, 0x00,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/golang/protobuf/proto
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func ProtoBufEncode(origin data.Data) []byte {
	encoded, err := proto.Marshal(&amp;amp;origin)
	if err != nil {
		panic(err)
	}

	return encoded
}

func ProtoBufDecode(bytes []byte) data.Data {
	var decoded data.Data
	if err := proto.Unmarshal(bytes, &amp;amp;decoded); err != nil {
		panic(err)
	}

	return decoded
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flatbuffers&#34;&gt;FlatBuffers&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://google.github.io/flatbuffers/&#34;&gt;http://google.github.io/flatbuffers/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Googleの、ゲームなどパフォーマンスを要求するアプリケーションのためのシリアライズライブラリ。
データにアクセスする前にparseやunpackする必要がなく、オブジェクトごとのメモリ割り当てが必要。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;proto&lt;/code&gt;の代わりにこんな&lt;code&gt;schema&lt;/code&gt;ファイルを書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace MyGame.Sample;
enum Color:byte { Red = 0, Green, Blue = 2 }
union Equipment { Weapon } // Optionally add more tables.
struct Vec3 {
  x:float;
  y:float;
  z:float;
}
table Monster {
  pos:Vec3; // Struct.
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];  // Vector of scalars.
  color:Color = Blue; // Enum.
  weapons:[Weapon];   // Vector of tables.
  equipped:Equipment; // Union.
}
table Weapon {
  name:string;
  damage:short;
}
root_type Monster;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使い方-2&#34;&gt;使い方&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;namespace dataf;

table data {
    title:string;
}

root_type data;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ brew install flatbuffers

$ flatc --go fbs/dataf.fbs
$ ls dataf/
data.go

$ go get github.com/google/flatbuffers/go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// automatically generated by the FlatBuffers compiler, do not modify

package dataf

import (
	flatbuffers &amp;quot;github.com/google/flatbuffers/go&amp;quot;
)

type data struct {
	_tab flatbuffers.Table
}

func GetRootAsdata(buf []byte, offset flatbuffers.UOffsetT) *data {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &amp;amp;data{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *data) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *data) Title() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func dataStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func dataAddTitle(builder *flatbuffers.Builder, title flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(title), 0)
}
func dataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
