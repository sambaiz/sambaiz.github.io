<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/linux/</link>
    <description>Recent content in Linux on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Thu, 23 Aug 2018 00:52:00 +0900</lastBuildDate>
    
	<atom:link href="https://www.sambaiz.net/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>nohupし忘れた時間のかかる処理をdisownしてexit後も実行させ続ける</title>
      <link>https://www.sambaiz.net/article/184/</link>
      <pubDate>Thu, 23 Aug 2018 00:52:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/184/</guid>
      <description>時間がかかるコマンドを実行する場合、通常はnohupで実行し ターミナル終了時に飛ぶSIGHUP(SIGnal Hang UP)を無視させることで exitしても実行させ続けることができる。
$ nohup ./foo &amp;amp;  ただnohupを付けずに実行し始めてから思ったより時間がかかるということもある。 その場合は、Ctrl+Zで一旦停止してからbgでバックラウンドで実行するようにしてdisown -hでSIGHUPが送られないようにできる。 disownはシェルのジョブテーブルから削除するコマンドで、そのままでもSIGHUPが送られないようにできるが、 -hを付けるとジョブテーブルから削除せずに済む。
$ jobs [1]+ 停止 ./foo $ bg1 $ jobs [1]+ 実行中 ./foo $ disown -h %1  </description>
    </item>
    
    <item>
      <title>tmuxのメモ</title>
      <link>https://www.sambaiz.net/article/95/</link>
      <pubDate>Fri, 21 Apr 2017 00:25:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/95/</guid>
      <description>https://tmux.github.io/
セッションを立ち上げてその中で複数のウィンドウやペインからコマンドを実行できるやつ。 サーバーでの作業中にネットワークが切断されてしまってもセッションをattachすることで再開することができる。 ローカル環境でもコマンドキーでのウィンドウ作成やペインの分割、 複数のサーバーにsshで入って調査するようなときにペインの同時入力は便利。 もちろんターミナルを閉じてしまっても再開できる。
$ brew install tmux $ tmux $ tmux ls $ tmux a # sessionをattachする  bind key(デフォルトでCtrl + b)を入れてからコマンドキーを入れる。よく使うもの。
 c: 新しいウインドウをCreateする d: 今のクライアントをDetachする n: Nextウィンドウに移動する p: Previousウィンドウに戻る w: Windowを一覧表示して選択する x: ペインを削除する ,: ウィンドウの名前を変更する z: ウィンドウ一杯にペインをzoomする/解除 [: ペイン内をスクロールできるようになる。qで解除  ~/.tmux.confはこんな感じにしている。
# bind keyをC-tに変更してC-bを解除 set -g prefix C-t unbind C-b # Vimのキーバインドでペインを移動する bind h select-pane -L bind j select-pane -D bind k select-pane -U bind l select-pane -R # - でペインを横に分割する(縦に切る) bind - split-window -h # | でペインを縦に分割する(横に切る) bind | split-window -v # 同時入力 bind s set-window-option synchronize-panes on bind S set-window-option synchronize-panes off  </description>
    </item>
    
    <item>
      <title>Unixのパイプをmkfifo()で作ってdup2()で標準出力にコピーして書き込む</title>
      <link>https://www.sambaiz.net/article/87/</link>
      <pubDate>Fri, 24 Mar 2017 22:06:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/87/</guid>
      <description>パイプとは Unixでプロセス間通信するためのもの。シェルで使う|は無名パイプ。 mkfifo()システムコールで名前付きパイプを作成でき、これを読み書きすることで任意のプロセス間でやりとりできる。
$ mkfifo hoge $ ls -lh $ prw-r--r-- ... 0B ... hoge  通常のファイルと同様に読み書きすることができ、読み書きどちらかを行おうとすると待つことになる。
$ echo hoge &amp;amp; # 読まれるまで待つ $ cat hoge aaaaa [1]+ Done echo &amp;quot;aaaaa&amp;quot; &amp;gt; hoge $ cat hoge &amp;amp; # 書かれるまで待つ $ echo &amp;quot;bbbbb&amp;quot; &amp;gt; hoge bbbbb [1]+ Done cat hoge  ファイルディスクリプタをコピーするシステムコールdup2()でopenしたパイプを標準出力(1)にコピーしてみる。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; int main(){ int fd = open(&amp;quot;./hoge&amp;quot;, O_WRONLY); if(fd &amp;lt; 0){ printf(&amp;quot;fail to open\n&amp;quot;); return 1; } printf(&amp;quot;OPEN %d \n&amp;quot;, fd); if(dup2(fd, 1) &amp;lt; 0){ printf(&amp;quot;fail to dup2\n&amp;quot;); return 2; } printf(&amp;quot;WRITE\n&amp;quot;); // これがどこに書き込まれるか close(fd); }  最後のprintfの内容は標準出力ではなく、パイプに書き込まれていることがわかる。</description>
    </item>
    
    <item>
      <title>crontabのメモ</title>
      <link>https://www.sambaiz.net/article/70/</link>
      <pubDate>Fri, 24 Feb 2017 21:40:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/70/</guid>
      <description>各ユーザーごとのcron設定。crontab -eでも編集できるけど、間違えて-rにすると全部消えてしまうのでこういう風に一旦取り出してから編集すると安全。
$ crontab -l &amp;gt; ~/crontab $ echo &amp;quot;*/1 * * * * /hoge/fuga.sh&amp;quot; &amp;gt;&amp;gt; ~/crontab $ crontab &amp;lt; ~/crontab $ crontab -l */1 * * * * /hoge/fuga.sh  参考 cron 設定ファイル (crontab ファイル) の置き場所と書式について - ひだまりソケットは壊れない</description>
    </item>
    
    <item>
      <title>iftopでネットワークの帯域を見る</title>
      <link>https://www.sambaiz.net/article/60/</link>
      <pubDate>Tue, 07 Feb 2017 20:30:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/60/</guid>
      <description>$ yum install --enablerepo=epel iftop $ iftop -f &amp;quot;not dst net 10.0.0.0/8&amp;quot;  -i eth0のようにしてインタフェースを指定し、-fでフィルタをかけられる。フィルタの詳細はman pcap-filterで。
 12.5Kb 25.0Kb 37.5Kb 50.0Kb	62.5Kb └─────────────────────────┴──────────────────────────┴──────────────────────────┴──────────────────────────┴────────────────────────── ip-172-31-9-9.ap-northeast-1.compute.internal =&amp;gt; 61-121-217-66.dh-connect.net 1.72Kb 6.57Kb 2.40Kb &amp;lt;= 416b 2.13Kb 702b ... ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── TX: cum: 22.6KB peak: 13.2Kb rates: 1.22Kb 1.27Kb 2.46Kb RX: 6.63KB 5.03Kb 208b 330b 748b TOTAL: 29.2KB 18.2Kb 1.42Kb 1.59Kb 3.19Kb  左から2, 10, 40秒間の平均kbps。TXが送信量、RXが受信量で、cumが総量、peakが最大。
実行中にSでソースのポートをDでディスティネーションのポートが表示される。</description>
    </item>
    
    <item>
      <title>SSHポートフォワーディングとnetstatのメモ</title>
      <link>https://www.sambaiz.net/article/42/</link>
      <pubDate>Sat, 17 Dec 2016 12:15:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/42/</guid>
      <description> SSHポートフォワーディング ローカルの8080ポートを、example.comを通したexample2.comの80ポートに向ける。
$ ssh hoge@example.com -Nf -L 8080:example2.com:80 $ curl localhost:8080 # =&amp;gt; example2.com:80   -N: リモートでコマンドを実行しない -f: バックグラウンドで実行  netstat ネットワークの状態を確認する。
$ netstat -ant Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN ...   -a: non-listening(TCPではESTABLISHED状態)しているソケットだけではなく、listeningしている情報も出す -n: 数値のアドレスで表示する -t: TCPで制限  </description>
    </item>
    
    <item>
      <title>ファイルディスクリプタの上限を増やす</title>
      <link>https://www.sambaiz.net/article/41/</link>
      <pubDate>Thu, 08 Dec 2016 21:36:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/41/</guid>
      <description>ファイルディスクリプタとは プロセスの外部とやりとりするための識別子。POSIXではint型で、0がstdin、1がstdout、2がstderrといったもの。 ファイルやデバイスに対するopen()や、 ネットワーク(INETドメインソケット)やホスト内(UNIXドメインソケット)で 通信するためのソケットを生成するsocket()などのシステムコールで生成される。
ファイルディスクリプタの上限 一つのプロセスがリソースを食いつぶさないように 使えるファイルディスクリプタの上限が決まっていて、ulimit -nで確認できる。デフォルトは大体1024。
$ ulimit -n 1024  各プロセスの上限と使っているファイルディスクリプタはこれで確認できる。
$ cat /proc/&amp;lt;プロセスID&amp;gt;/limits ... Max open files 1024 4096 files ... $ ls -l /proc/&amp;lt;プロセスID&amp;gt;/fd  webサーバーのように同時にたくさん通信したりすると上限に達してしまい、Too many open filesになってしまうので増やす必要がある。
/etc/security/limits.confで変更する PAM認証時(ログインするときなど)に適用されるので、サーバーの起動時に立ち上がったデーモンには使えない。
$ cat /etc/pam.d/sshd ... session required pam_limits.so ...  全てのユーザー(*)のプロセスが使える ファイルディスクリプタ(nofile)のsoft(ユーザーが設定できる)とhard(rootが設定できる)上限を共に64000にする。
$ echo &amp;quot;* hard nofile 64000&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf $ echo &amp;quot;* soft nofile 64000&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf $ ulimit -n 64000  ulimit -nで変更する シェルと、起動したプロセスで有効。</description>
    </item>
    
  </channel>
</rss>