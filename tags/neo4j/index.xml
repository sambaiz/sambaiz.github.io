<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/neo4j/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2018</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>グラフデータベースNeo4jを触ってみた</title>
          <link>https://www.sambaiz.net/article/10/</link>
          <pubDate>Thu, 21 Jul 2016 09:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/10/</guid>
          <description>

&lt;p&gt;社内勉強会で&lt;a href=&#34;https://github.com/neo4j/neo4j&#34;&gt;オープンソース&lt;/a&gt;の
グラフデータベース&lt;a href=&#34;https://neo4j.com/&#34;&gt;Neo4j&lt;/a&gt;が紹介されていたので触ってみた。&lt;/p&gt;

&lt;h2 id=&#34;what-is-a-graph-database-https-neo4j-com-developer-graph-database&#34;&gt;&lt;a href=&#34;https://neo4j.com/developer/graph-database/&#34;&gt;What is a Graph Database?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;つながりも含めたグラフとしてデータを扱うデータベース。
データセットのサイズによらず、複雑なつながりや、クエリをうまく扱える。
無数のデータの中から、関係ないデータを見ることなく多数のノードとつながりからなる必要なデータだけを取れる。&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://neo4j.com/download/&#34;&gt;ここ&lt;/a&gt;からCommunity Editionを選んで
OSごとに用意されている実行ファイルをダウンロードしてくる。
ファイルを実行し、Startを押すとブラウザで開けるようになる。&lt;/p&gt;

&lt;h2 id=&#34;グラフ&#34;&gt;グラフ&lt;/h2&gt;

&lt;p&gt;グラフは以下の要素から構成される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node: データそのもので、まとめるためのラベルを複数付けられる&lt;/li&gt;
&lt;li&gt;Relationships: typeを持つ、Nodeのつながり&lt;/li&gt;
&lt;li&gt;Properties: NodeやRelationshipsが持てるkey-valueの値&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cypher&#34;&gt;Cypher&lt;/h2&gt;

&lt;p&gt;Neo4jで使うクエリ言語。&lt;/p&gt;

&lt;p&gt;まずはCREATE文でNodeを作る。Personはラベルだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE (ee:Person { name: &amp;quot;Emil&amp;quot;, from: &amp;quot;Sweden&amp;quot;, klout: 99 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CREATE文では使われていなかった謎のeeだが、MATCH文を見るとデータが格納される変数だということがわかる。
このeeは次のCREATE文でも参照できて、&lt;code&gt;(ee)-[:KNOWS {since: 2001}]-&amp;gt;(js)&lt;/code&gt;で
作ったNodeとのRelationshipsを張るのに使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (ee:Person) WHERE ee.name = &amp;quot;Emil&amp;quot; RETURN ee;

CREATE (js:Person { name: &amp;quot;Johan&amp;quot;, from: &amp;quot;Sweden&amp;quot;, learn: &amp;quot;surfing&amp;quot; }),
(ir:Person { name: &amp;quot;Ian&amp;quot;, from: &amp;quot;England&amp;quot;, title: &amp;quot;author&amp;quot; }),
(rvb:Person { name: &amp;quot;Rik&amp;quot;, from: &amp;quot;Belgium&amp;quot;, pet: &amp;quot;Orval&amp;quot; }),
(ally:Person { name: &amp;quot;Allison&amp;quot;, from: &amp;quot;California&amp;quot;, hobby: &amp;quot;surfing&amp;quot; }),
(ee)-[:KNOWS {since: 2001}]-&amp;gt;(js),(ee)-[:KNOWS {rating: 5}]-&amp;gt;(ir),
(js)-[:KNOWS]-&amp;gt;(ir),(js)-[:KNOWS]-&amp;gt;(rvb),
(ir)-[:KNOWS]-&amp;gt;(js),(ir)-[:KNOWS]-&amp;gt;(ally),
(rvb)-[:KNOWS]-&amp;gt;(ally)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようにパターンマッチもできる。この例だとEmilの友達が取得できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (ee:Person)-[:KNOWS]-(friends)
WHERE ee.name = &amp;quot;Emil&amp;quot; RETURN ee, friends
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必ずしも変数に入れなくても良く、&lt;code&gt;()&lt;/code&gt;のように無視することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)
WHERE js.name = &amp;quot;Johan&amp;quot; AND surfer.hobby = &amp;quot;surfing&amp;quot;
RETURN DISTINCT surfer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最短経路を取得するのも簡単だ。&lt;code&gt;[*1..4]&lt;/code&gt;にして、ホップ数に制限をかけたり、範囲を指定したりすることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MATCH p=shortestPath(
  (bacon:Person {name:&amp;quot;Kevin Bacon&amp;quot;})-[*]-(meg:Person {name:&amp;quot;Meg Ryan&amp;quot;})
)
RETURN p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろんSQLの&lt;code&gt;LIMIT&lt;/code&gt;や&lt;code&gt;ORDER BY&lt;/code&gt;、&lt;code&gt;GROUP BY&lt;/code&gt;相当のこともできる。
文法が直感的に分かりやすいものになっていて良いと思った。&lt;/p&gt;

&lt;h2 id=&#34;欠点&#34;&gt;欠点&lt;/h2&gt;

&lt;p&gt;とにかくSQLのJOIN地獄から脱出できそうなのが大きくて、それだけで採用したい気になってしまうが、
データの総量とは関係なく一つのNodeに大量にRelationshipsが付くと非常に遅くなるという問題があるらしい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cyberagent.co.jp/technology/ca_tech/report/8980456.html&#34;&gt;【CyberAgent】技術情報／TechReport - テックレポート／MongoDB de GraphDB | 株式会社サイバーエージェント&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;なぜかというと隣接Node/RelationshipsのポインタをLinkedListで持っているからみたいだ。これは苦しい。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://the.igreque.info/posts/2014-06-08-neo4j.html&#34;&gt;igreque : Info -&amp;gt; Neo4jについてちょちょいと調べたまとめ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;電車の路線のように一つのNodeに対して高々いくつかのRelationshipsしかつながらないことが分かっている場合には問題ないので、
そういうモデルを作るか、あるいはデータの数を絞るか、使うにあたって工夫が必要そうだ。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
