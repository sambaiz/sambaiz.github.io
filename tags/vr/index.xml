<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>http://sambaiz.net/tags/vr/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>WebVRを動かす</title>
          <link>http://sambaiz.net/article/36/</link>
          <pubDate>Wed, 16 Nov 2016 00:46:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/36/</guid>
          <description>

&lt;h3 id=&#34;webvrとは&#34;&gt;WebVRとは&lt;/h3&gt;

&lt;p&gt;Webブラウザ上でVRアプリケーションを動かすためのAPI。
ヘッドマウントディスプレイの動きを3D空間上の動きに変換してくれる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/WebVR_API&#34;&gt;WebVR API - Web API インターフェイス | MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ただし、まだほとんどのブラウザがVR APIをサポートしていないので、
実際は&lt;a href=&#34;https://github.com/googlevr/webvr-polyfill&#34;&gt;Polyfill&lt;/a&gt;で動かすことになる。&lt;/p&gt;

&lt;h3 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h3&gt;

&lt;p&gt;まず、&lt;a href=&#34;https://github.com/borismus/webvr-boilerplate&#34;&gt;webvr-boilerplate&lt;/a&gt;を動かしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm init
$ npm install node-static
$ git clone https://github.com/borismus/webvr-boilerplate.git
$ cd webvr-boilerplate/ &amp;amp;&amp;amp; npm install &amp;amp; cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var static = require(&#39;node-static&#39;);

var fileServer = new static.Server(&#39;./webvr-boilerplate&#39;);

require(&#39;http&#39;).createServer(function (request, response) {
    request.addListener(&#39;end&#39;, function () {
        fileServer.serve(request, response);
    }).resume();
}).listen(8080);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;を見ると箱が回っているのが映る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/36_webvr1.png&#34; alt=&#34;箱が回っている&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ただ、start_modeに3を指定してVRモードにしようとしたところ、&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:8080/index.html?start_mode=3&#34;&gt;http://localhost:8080/index.html?start_mode=3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PCのChromeから見ると&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;base.js:191 Uncaught (in promise) Error: VRDisplay is not capable of presenting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーが出てしまった。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Only enable VR mode if there&amp;rsquo;s a VR device attached or we are running the polyfill on mobile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書いてあったので、Android端末から見てみたところ
Cardboardのマークが出てきて、それを押したら二眼の表示になった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/36_vrview.png&#34; alt=&#34;二眼で映っている&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;描画&#34;&gt;描画&lt;/h3&gt;

&lt;p&gt;webvr-boilerplateでは、描画に&lt;a href=&#34;https://threejs.org/&#34;&gt;Three.js&lt;/a&gt;を使っている。&lt;/p&gt;

&lt;p&gt;まずシーンやカメラを作る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、cameraをTHREE.VRControlsに渡す。この中でVR APIを呼んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var controls = new THREE.VRControls(camera);
controls.standing = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをupdateしていくことでVRデバイスにcameraが連動するようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;controls.update();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自分でVR APIを呼んでいるところもあって、
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/Navigator/getVRDisplays&#34;&gt;Navigator.getVRDisplays()&lt;/a&gt;で
VRDisplayを取得し、
&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/VRDevice/requestAnimationFrame&#34;&gt;VRDisplay.requestAnimationFrame()&lt;/a&gt;で、VRDisplayのリフレッシュレートでアニメーションさせるコールバックが呼ばれるようにしている。
このコールバックの中で&lt;code&gt;controls.update()&lt;/code&gt;を呼んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length &amp;gt; 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
      }
      vrDisplay.requestAnimationFrame(animate);
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>剣を振るVRゲームを作った</title>
          <link>http://sambaiz.net/article/29/</link>
          <pubDate>Sun, 30 Oct 2016 19:05:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/29/</guid>
          <description>

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/29_game.png&#34; alt=&#34;ゲーム画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Tlonh7D5UzY&#34;&gt;プレイ動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vr.google.com/intl/ja_jp/cardboard/&#34;&gt;Cardboard&lt;/a&gt;にAndroidを入れて、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/29_card.jpg&#34; alt=&#34;Cardboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;iPhoneをくくりつけた傘を動かすと、画面の剣も動くのでこれで敵を倒すゲーム。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//sambaiz.net/images/29_sword.jpg&#34; alt=&#34;iPhoneをくくりつけた傘&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;h3 id=&#34;剣-ios&#34;&gt;剣(iOS)&lt;/h3&gt;

&lt;p&gt;剣にくくりつけたiPhoneの傾きの値をUnity(Android)に送信している。
iOSはClassic Bluetoothを自由に使えないので、Androidと通信する場合はBLEを使う。
BLEは通常だと20byteしか一度に送れないので、これを超えないよう注意する必要がある。&lt;/p&gt;

&lt;p&gt;BLEで通信するところは&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/26&#34;&gt;iOS端末をBLEのPeripheralにする&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で作ったので、端末の傾きを取得して送るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import CoreMotion

class Motion{

    let peripheral: BLEPeripheral
    let accelHandler:CMDeviceMotionHandler
    let manager = CMMotionManager()

    public init(peripheral :BLEPeripheral, label :UILabel){
        self.peripheral = peripheral

        accelHandler = {
            (data: CMDeviceMotion?, error: Error?) -&amp;gt; Void in
            let str = String(format: &amp;quot;%.1f %.1f %.1f&amp;quot;,
                             arguments: [data!.attitude.pitch * 180 / M_PI,
                                         data!.attitude.roll * 180 / M_PI,
                                         data!.attitude.yaw * 180 / M_PI]
                )
            let res = peripheral.update(str.data(using: String.Encoding.utf8))
            label.text = str + &amp;quot; &amp;quot; + String(res)
        }
    }

    func start(){
        if manager.isDeviceMotionAvailable {
            manager.deviceMotionUpdateInterval = 1 / 12;
            manager.startDeviceMotionUpdates(to: OperationQueue.current!, withHandler: accelHandler)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ゲーム-unity-android&#34;&gt;ゲーム(Unity &amp;amp; Android)&lt;/h3&gt;

&lt;p&gt;オライリーから&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873117577/&#34;&gt;UnityによるVRアプリケーション開発――作りながら学ぶバーチャルリアリティ入門&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;という本が出ていたので買った。Unityの初歩的なところやBlenderとかも説明があるのでおすすめ。
とりあえず&lt;a href=&#34;https://developers.google.com/vr/unity/&#34;&gt;GoogleのSDK&lt;/a&gt;をimportして、
Prefabの&lt;code&gt;GvrViewerMain&lt;/code&gt;を置くと二眼のそれっぽい感じになる。&lt;/p&gt;

&lt;p&gt;スコアとかゲームオーバーの状態と処理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class Game : MonoBehaviour {

	public static int score = 0;
	public static bool gameOver = false;
	public static bool killed = false;

	public Text gameOverText;
	public Text scoreText;
	public GameObject enemy;

	void Start () {
		gameOverText.enabled = false;
	}

	void Update () {
		scoreText.text = &amp;quot;Score: &amp;quot; + score;
		if (gameOver) gameOverText.enabled = true;
		if (killed) {
			nextLevel ();
			killed = false;
		}
	}

	public void nextLevel(){
		var old = enemy;
		var x = Random.Range (-10, 10);
		enemy = (GameObject) Instantiate (
			enemy, new Vector3(x, 0, Mathf.Sqrt(10 * 10 - x * x)), Quaternion.Euler(0, 0, 0));
		Destroy (old);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵の当たり判定。剣に当たったら爆発して次のが出てくる。
体(見えないCapsule Colliderを設定している)に当たるとゲームオーバー。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class MonsterHit : MonoBehaviour {

	public GameObject killEffect;

	void OnCollisionEnter(Collision collision) {
		switch (collision.gameObject.name) {
		case &amp;quot;sword&amp;quot;:
			if (!Game.gameOver) {
				Game.score += 1;
				Instantiate (killEffect, transform.position, transform.rotation);
				Game.killed = true;
			}
			break;

		case &amp;quot;Body&amp;quot;:
			Game.gameOver = true;
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵を動かす。スコアが上がるとスピードも上がる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class MonsterMove : MonoBehaviour {

	private float moveRate;

	void Start () {
		moveRate = 0.0f;
	}

	void Update () {
		transform.position = Vector3.Lerp (transform.position, new Vector3 (0, 0, -1.5f), moveRate);
		moveRate += 0.0001f * (Game.score + 1);
		transform.LookAt (new Vector3 (0, 0, -1.5f));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;センサーの値を受け取って、剣を動かす。ここで使っているネイティブライブラリは前作ったもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/27&#34;&gt;UnityでAndroidのBLEを使うネイティブプラグインを作る&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class SwordMotion : MonoBehaviour {

	private AndroidJavaObject ble;
	private Quaternion q;

	void Start () {
		ble = new AndroidJavaObject (&amp;quot;net.sambaiz.unity_ble.BLE&amp;quot;, this.gameObject.name, &amp;quot;received&amp;quot;);
		q = Quaternion.Euler (0, 0, 0);
	}

	void Update () {
		transform.rotation = q;
	}

	void received(string message){
		var motionData = message.Split (&#39; &#39;); // pitch roll yaw
		q = Quaternion.Euler (
				90 - float.Parse (motionData [0]),
				float.Parse (motionData [1]),
				0) ;
	}

	void OnApplicationPause (bool pauseStatus)
	{
		if (ble != null) {
			if (pauseStatus) {
				ble.Call (&amp;quot;onPause&amp;quot;);
			} else {
				ble.Call (&amp;quot;onActive&amp;quot;);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
