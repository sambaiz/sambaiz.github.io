<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/crypto/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>RSA暗号とPEM/DERの構造</title>
          <link>https://www.sambaiz.net/article/135/</link>
          <pubDate>Sun, 01 Oct 2017 21:02:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/135/</guid>
          <description>

&lt;h2 id=&#34;rsa暗号とは&#34;&gt;RSA暗号とは&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;暗号化: &lt;code&gt;c ≡ m^e (mod n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;複合: &lt;code&gt;m ≡ c^d (mod n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公開鍵がe,nで秘密鍵がd。nはとても大きく近くない素数p,qの積で、
これを公開しても素因数分解できないのがこの暗号の前提になっている。
768bit(10進数で232桁)では既に解読されているので、少なくとも1024bit以上にする。&lt;/p&gt;

&lt;p&gt;eは&lt;a href=&#34;https://en.wikipedia.org/wiki/Euler%27s_totient_function&#34;&gt;Euler totient function&lt;/a&gt;(1~nまでの整数でnと互いに素なものの個数。今回の場合は&lt;code&gt;φ(n)=(p-1)(q-1)&lt;/code&gt;)未満で互いに素な正の整数で、小さすぎても大きすぎてもだめ。&lt;code&gt;2^16 + 1 = 65537&lt;/code&gt;がよく使われる。&lt;/p&gt;

&lt;p&gt;dは&lt;code&gt;ed ≡ 1 (mod φ(n))&lt;/code&gt;を満たすd。&lt;/p&gt;

&lt;h2 id=&#34;例&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;例として(p,q)=(193,709)とするとこんな感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;n = p * q = 136837&lt;/li&gt;
&lt;li&gt;φ(n) = (p-1)(q-1) = 135936&lt;/li&gt;
&lt;li&gt;e = 65537 &amp;lt; φ(n)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;秘密鍵dは&lt;code&gt;65537*d ≡ 1 (mod 135936)&lt;/code&gt;の式を変形した
&lt;code&gt;65537*d - 135936*x = gcd(65537,135936) = 1&lt;/code&gt;を、拡張されたユークリッドの互除法で解く。
以下のように135936と65537を残しながら展開していく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;135936 = 65537 * 2 + 4862 
=&amp;gt; 4862 = 135936 * 1 + 65537 * -2

65537 = 4862 * 13 + 2331 
=&amp;gt; 2331 = 65537 - (135936 * 1 + 65537 * -2) * 13
        = 135936 * -13 + 65537 * 27

4862 = 2331 * 2 + 200 
=&amp;gt; 200 = (135936 * 1 + 65537 * -2) - (135936 * -13 + 65537 * 27) * 2
       = 135936 * 27 + 65537 * -56

2331 = 200 * 11 + 131 
=&amp;gt; 131 = (135936 * -13 + 65537 * 27) - (135936 * 27 + 65537 * -56) * 11
       = 135936 * -310 + 65537 * 643 
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをコードに表したのがこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const d = (phi,e) =&amp;gt; {
    let history = {[phi]: [1,0], [e]:[0,1]} // [x,y] =&amp;gt; φ * x + e * y
    let x = phi
    let y = e
    while(y &amp;gt; 1){
        const nextY = x % y
        history[x % y] = history[x].map((vx,index) =&amp;gt; vx - history[y][index] * Math.floor(x/y))
        x = y
        y = nextY;
    }
    return history;
}

const phi = (193-1) * (709-1)
const e = 65537
const result = d(phi,e);
console.log(result);
console.log(`1 = ${phi}*${result[1][0]} + ${e}*${result[1][1]}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{ &#39;1&#39;: [ 9503, -19711 ],
  &#39;6&#39;: [ -8519, 17670 ],
  &#39;7&#39;: [ 984, -2041 ],
  &#39;62&#39;: [ -647, 1342 ],
  &#39;69&#39;: [ 337, -699 ],
  &#39;131&#39;: [ -310, 643 ],
  &#39;200&#39;: [ 27, -56 ],
  &#39;2331&#39;: [ -13, 27 ],
  &#39;4862&#39;: [ 1, -2 ],
  &#39;65537&#39;: [ 0, 1 ],
  &#39;135936&#39;: [ 1, 0 ] }
1 = 135936*9503 + 65537*-19711
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;135936*-65537 + 65537*135936 = 0&lt;/code&gt;より
&lt;code&gt;1 = 135936*(9503-65537) + 65537*(-19711 + 135936)&lt;/code&gt;なので
&lt;code&gt;d=116225&lt;/code&gt;。実際&lt;code&gt;(65537*116225) % 135936 = 1&lt;/code&gt;が成り立つ。&lt;/p&gt;

&lt;p&gt;平文が12345とすると、公開鍵で暗号化したのが&lt;code&gt;(12345 ** 65537) % 136837 = 6964&lt;/code&gt;。
これを秘密鍵で複合すると&lt;code&gt;(6964 ** 116225) % 136837 = 12345&lt;/code&gt;のように平文が得られる。&lt;/p&gt;

&lt;h2 id=&#34;鍵ファイルの生成&#34;&gt;鍵ファイルの生成&lt;/h2&gt;

&lt;p&gt;ssh-keygenで生成されるようなPEMファイルを作る。&lt;/p&gt;

&lt;h3 id=&#34;用語&#34;&gt;用語&lt;/h3&gt;

&lt;p&gt;DER(Distinguished Encoding Rules)は
&lt;a href=&#34;https://ja.wikipedia.org/wiki/Abstract_Syntax_Notation_One&#34;&gt;ASN.1(Abstract Syntax Notation One)&lt;/a&gt;記法で定義されたデータを
エンコードするルールの一つ。
&lt;code&gt;1a(INTEGER) 0b(byte) 68 65 6c 6c 6f 20 77 6f 72 6c 64(&amp;quot;hello world&amp;quot;))&lt;/code&gt;
のようなtype-length-valueで表す。&lt;/p&gt;

&lt;p&gt;PEM(Privacy-enhanced Electronic Mail)は
公開鍵のフォーマットの定義&lt;a href=&#34;https://en.wikipedia.org/wiki/X.509&#34;&gt;X.509&lt;/a&gt;で
定められている拡張子で、Base64でエンコードされたDER。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/PKCS&#34;&gt;PKCS(Public-Key Cryptography Standards)&lt;/a&gt;は公開鍵暗号における標準仕様を定めたもの。PKCS#1(&lt;a href=&#34;https://tools.ietf.org/html/rfc2313&#34;&gt;RFC2313&lt;/a&gt;)にはRSA暗号の方式やASN.1表現などが含まれている。&lt;/p&gt;

&lt;p&gt;RFC2313に書かれているASN.1を見ながらPEMの内容を確認する。&lt;/p&gt;

&lt;h3 id=&#34;rsaprivatekey&#34;&gt;RSAPrivateKey&lt;/h3&gt;

&lt;p&gt;n,e,dに加えて生成に使った素数まで含んでいる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RSAPrivateKey ::= SEQUENCE {
     version Version,
     modulus INTEGER, -- n
     publicExponent INTEGER, -- e
     privateExponent INTEGER, -- d
     prime1 INTEGER, -- p
     prime2 INTEGER, -- q
     exponent1 INTEGER, -- d mod (p-1)
     exponent2 INTEGER, -- d mod (q-1)
     coefficient INTEGER -- (inverse of q) mod p }

   Version ::= INTEGER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pemを生成し、Base64デコードしてDERにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl genrsa 1024 &amp;gt; secret.pem
$ cat secret.pem 
-----BEGIN RSA PRIVATE KEY-----
(内容)
-----END RSA PRIVATE KEY-----

$ echo (内容) | base64 -D | xxd
00000000: 3082 025c 0201 0002 8181 .... .... .... 
00000080: .... .... .... .... .... ..02 0301 0001
00000090: 0281 80..
00000110: .... ..02 41.. 
00000150: .... .... .... 0241 ....
00000190: .... .... .... .... ..02 40.. 
000001d0: .... .... .... .... .... ..02 41.. ....  
00000210: .... .... .... .... .... .... .... 0240 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整理するとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0000] 30 82 02 5c       
(30-&amp;gt;Type=SEQUENCE 82-&amp;gt;先頭bitが1なのでlengthに使うバイト数(2bytes) 025c-&amp;gt;Length=605bytes)

  [0000] 02 01 00
  (version: 02-&amp;gt;Type=INTEGER, 01-&amp;gt;先頭が0なのでそのままLength=3bytes, Value=0)

  [0000] 02 81 81 .. 
  (modulus: Type=INTEGER, Length=129bytes)

  [0080] 02 03 01 00 01 
  (publicExponent: Type=INTEGER, Length=3bytes, Value=65537)

  [0090] 02 81 80 ..
  (privateExponent: Type=INTEGER, Length=128bytes)

  [0110] 02 41 ..
  (prime1: Type=INTEGER, Length=65bytes)

  [0150] 02 41 .. 
  (prime2: Type=INTEGER, Length=65bytes)

  [0190] 02 40 ..
  (exponent1: Type=INTEGER, Length=64bytes)

  [01d0] 02 41 ..
  (exponent2: Type=INTEGER, Length=65bytes)

  [0210] 02 40 ..
  (coefficient: Type=INTEGER, Length=64bytes)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rsapublickey&#34;&gt;RSAPublicKey&lt;/h3&gt;

&lt;p&gt;nとeだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RSAPublicKey ::= SEQUENCE {
     modulus INTEGER, -- n
     publicExponent INTEGER -- e }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;秘密鍵から公開鍵を生成して同様にDERにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl rsa -pubout &amp;lt; secret.pem &amp;gt; public.pem
$ cat public.pem 
-----BEGIN PUBLIC KEY-----
(内容)
-----END PUBLIC KEY-----

$ echo (内容) | base64 -D | xxd
00000000: 3081 9f30 0d06 092a 8648 86f7 0d01 0101
00000010: 0500 0381 8d00 3081 8902 8181 .... ....
00000090: .... .... .... .... .... .... ..02 0301 
000000a0: 0001
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[0000] 30 81 9f
(Type=SEQUENCE, Length=159bytes)
  [0000] 30 0d
  (Type=SEQUENCE, Length=13bytes)
    [0000] 06 09 2a 86 48 86 f7 0d 01 01 01
    (Type=OBJECT IDENTIFIER, Length=9bytes, 
    value=http://www.oid-info.com/get/1.2.840.113549.1.1.1
          最上位ビットは区切りのサイン
          2a ((0)010 1010) =&amp;gt; 40 * 1 + 2 =&amp;gt; 1(iso) 2(member-body)
          86 48 ((1)000 0110 (0)100 1000) =&amp;gt; 840(us)
          86 f7 0d ((1)000 0110 (1)111 0111 (0)000 1101) =&amp;gt; 113549(rsadsi)
          01 ((0)000 0001) =&amp;gt; 1(pkcs)
          01 ((0)000 0001) =&amp;gt; 1(pcks-1)
          01 ((0)000 0001) =&amp;gt; 1(rsaEncryption)

    [0010] 05 00
    (アルゴリズムパラメータ: Type=Null 0byte)

    [0010] 03 81 8d 00 
    (Type=BIT STRING, 141bytes, 最終byteの切り捨て0bit)

      [0010] 30 81 89
      (Type=SEQUENCE, 137bytes)

        [0010] 02 81 81 ..
        (modulus: Type=INTEGER, Length=129bytes)

        [0090] 02 03 01 00 01
        (publicExponent: Type=INTEGER, Length=3bytes, Value=65537)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;digestinfo&#34;&gt;digestInfo&lt;/h3&gt;

&lt;p&gt;署名に使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digestInfo ::= SEQUENCE {
     digestAlgorithm DigestAlgorithmIdentifier,
     digest Digest 
}

Digest ::= OCTET STRING
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;digestAlgorithmでデータをハッシュ化したものをdigestInfoに詰め、秘密鍵で暗号化したものを署名とし、
公開鍵で複合してdigestと実際のハッシュ値が一致することを確認する。
RSASSA-PKCS1-v1_5では暗号化の前に&lt;code&gt;00 01 ff ff ff .. 00&lt;/code&gt;のパディングを加える。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://people.csail.mit.edu/rivest/Rsapaper.pdf&#34;&gt;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.livedoor.jp/k_urushima/archives/979220.html&#34;&gt;自堕落な技術者の日記 : 図説RSA署名の巻&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bearmini.hatenablog.com/entry/2014/02/05/143510&#34;&gt;RSA 秘密鍵/公開鍵ファイルのフォーマット - bearmini&amp;rsquo;s blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://crypto.stackexchange.com/questions/29115/how-is-oid-2a-86-48-86-f7-0d-parsed-as-1-2-840-113549&#34;&gt;openssl - How is OID 2a 86 48 86 f7 0d parsed as 1.2.840.113549? - Cryptography Stack Exchange&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
