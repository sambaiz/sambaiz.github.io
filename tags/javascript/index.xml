<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/javascript/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>JavaScriptのrequire/import</title>
          <link>https://www.sambaiz.net/article/143/</link>
          <pubDate>Sat, 11 Nov 2017 20:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/143/</guid>
          <description>

&lt;h2 id=&#34;scriptタグを並べる&#34;&gt;scriptタグを並べる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
&amp;lt;script src=&amp;quot;a.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;b.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先に書かれた&lt;code&gt;a.js&lt;/code&gt;で定義された内容は&lt;code&gt;b.js&lt;/code&gt;で読むことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat a.js 
const a = &#39;a is defined&#39;;
const divA = document.createElement(&#39;div&#39;);
divA.textContent = (typeof b !== &#39;undefined&#39;) ? b : &#39;b is undefined&#39;;
document.body.appendChild(divA);

$ cat b.js 
const b = &#39;b is defined&#39;;
const divB = document.createElement(&#39;div&#39;);
divB.textContent = (typeof a !== &#39;undefined&#39;) ? a : &#39;a is undefined&#39;;
document.body.appendChild(divB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存が増えてくると順番を考えるのが大変。さらにグローバルな名前空間を汚染してしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b is undefined
a is defined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;amdとcommonjsとes-modules&#34;&gt;AMDとCommonJSとES Modules&lt;/h2&gt;

&lt;p&gt;というのも、かつてのJSにはモジュールを読み込む仕組みがなかった。
そこで考えられたのがAMDやCommonJSというフォーマット。
AMD(Asynchronous module definition)は&lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;によって提供される&lt;code&gt;require()&lt;/code&gt;で動的にscriptタグを埋める。CommonJSはNodeでもおなじみの&lt;code&gt;require()&lt;/code&gt;で、これにWebpackなどを通して一つのファイルにまとめておく。同じ関数名が使われているが全くの別物。&lt;/p&gt;

&lt;p&gt;今は言語仕様にECMAScript Modulesが追加され、普通に&lt;code&gt;import&lt;/code&gt;でモジュールを読み込めるようになったが、
対応ブラウザがまだ少ないのでWebpackなどをかける必要がある。
Nodeにも実装されているがStableになるのは&lt;a href=&#34;https://nodejs.org/api/esm.html&#34;&gt;まだ先&lt;/a&gt;のようだ。&lt;/p&gt;

&lt;h2 id=&#34;requirejs-http-requirejs-org&#34;&gt;&lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;define()&lt;/code&gt;でモジュールを定義し、&lt;code&gt;require()&lt;/code&gt;で読み込む。
エントリーポイントは&lt;code&gt;data-main&lt;/code&gt;に指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/b.js
require([&#39;a&#39;], (a) =&amp;gt; {
  const divB = document.createElement(&#39;div&#39;);
  divB.textContent = a.a();
  document.body.appendChild(divB);
});

$ cat src/a.js
define({
  a: () =&amp;gt; &#39;a is defined&#39;
});

$ cat src/index.html
&amp;lt;body&amp;gt;
&amp;lt;script data-main=&amp;quot;b.js&amp;quot; src=&amp;quot;require.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CommonJSのモジュールを読み込もうとするとエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/c.js 
const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

$ cat src/d.js 
exports.d = () =&amp;gt; &#39;d is defined&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Uncaught Error: Module name &amp;quot;d&amp;quot; has not been loaded yet for context: _. Use require([])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RequireJSのNode版、&lt;a href=&#34;https://github.com/requirejs/r.js&#34;&gt;r.js&lt;/a&gt;でCommonJSのモジュールをAMDに変換することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g requirejs
$ r.js -convert src out
$ cat c.js 
define(function (require, exports, module) {const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

});

$ cat d.js 
define(function (require, exports, module) {exports.d = () =&amp;gt; &#39;d is defined&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、Webpackのようにコードを一つのjsファイルにbundleすることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ r.js -o baseUrl=out name=b out=bundle.js optimize=none
$ cat bundle.js 
define(&#39;a&#39;,{
  a: () =&amp;gt; &#39;a is defined&#39;
});

define(&#39;d&#39;,[&#39;require&#39;,&#39;exports&#39;,&#39;module&#39;],function (require, exports, module) {exports.d = () =&amp;gt; &#39;d is defined&#39;;


});

define(&#39;c&#39;,[&#39;require&#39;,&#39;exports&#39;,&#39;module&#39;,&#39;d&#39;],function (require, exports, module) {const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

});

require([&#39;a&#39;,&#39;c&#39;], (a,c) =&amp;gt; {
  const divB = document.createElement(&#39;div&#39;);
  divB.textContent = a.a();
  document.body.appendChild(divB);

  const divB2 = document.createElement(&#39;div&#39;);
  divB2.textContent = c.c();
  document.body.appendChild(divB2);
});

define(&amp;quot;b&amp;quot;, function(){});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに&lt;code&gt;optimize=none&lt;/code&gt;を付けているのはES6のコードに対応していないため。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If the source uses ES2015 or later syntax, please pass &amp;quot;optimize: &#39;none&#39;&amp;quot; to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/guybedford/require-css&#34;&gt;guybedford/require-css&lt;/a&gt;を使うと
cssも依存に含めることができ、scriptタグと同様にstyleタグが動的に入る。&lt;/p&gt;

&lt;h2 id=&#34;webpack-https-webpack-js-org&#34;&gt;&lt;a href=&#34;https://webpack.js.org/&#34;&gt;Webpack&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;の
&lt;code&gt;entry&lt;/code&gt;にエントリーポイント、
&lt;code&gt;output&lt;/code&gt;に出力場所、
&lt;code&gt;module&lt;/code&gt;にJS以外のファイルを処理するloader、
&lt;code&gt;plugins&lt;/code&gt;に全体を処理するpluginの
設定を書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev webpack html-webpack-plugin
$ cat webpack.config.js 
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);
const path = require(&#39;path&#39;);

const config = {
  entry: &#39;./src/main.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  },
  module: {},
  plugins: [
    // new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})
  ]
};

module.exports = config;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES Modulesの記法を使っている。CommonJSにも対応しているが今はこちらが&lt;a href=&#34;https://webpack.js.org/api/module-methods/&#34;&gt;推奨&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.js 
import { bar } from &#39;./foo&#39;;
const div = document.createElement(&#39;div&#39;);
div.textContent = bar();
document.body.appendChild(div);

$ cat src/foo.js 
export function bar() {
  return &#39;bar&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行するとこんな感じにbundleされる。実際はUglifyJsPluginによってもう少しサイズが小さくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node_modules/.bin/webpack 
$ cat dist/index.html 
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

$ z$ cat dist/bundle.js 
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
...
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&amp;quot;use strict&amp;quot;;
Object.defineProperty(__webpack_exports__, &amp;quot;__esModule&amp;quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foo__ = __webpack_require__(1);

const div = document.createElement(&#39;div&#39;);
div.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__foo__[&amp;quot;a&amp;quot; /* bar */])();
document.body.appendChild(div);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&amp;quot;use strict&amp;quot;;
/* harmony export (immutable) */ __webpack_exports__[&amp;quot;a&amp;quot;] = bar;
function bar() {
  return &#39;bar&#39;;
};


/***/ })
/******/ ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/webpack-contrib/css-loader&#34;&gt;css-loader&lt;/a&gt;を使うとCSSをbundleできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev style-loader css-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS Moduleを有効にして、ほかの同名のクラスに影響を及ぼさないようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module: {
    rules: [
      {
        test: /\.css$/,
        use: [ 
          &#39;style-loader&#39;, 
          {
            loader: &#39;css-loader&#39;,
            options: {
              modules: true,
            }
          }
        ]
      }
    ]
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;importするとCSSに書かれたクラスと変換後の対応が取れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.js 
import { bar } from &#39;./foo&#39;;
import css from &#39;./style.css&#39;;

const div = document.createElement(&#39;div&#39;);
div.textContent = bar();
div.className = css[&#39;bg&#39;]; /* {&amp;quot;bg&amp;quot;:&amp;quot;_2T2hBh3FkCro4-BOuqaGg5&amp;quot;} */
document.body.appendChild(div);

$ cat src/style.css 
.bg {
  background-color: #22ee22;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動的に&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;が埋められる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat dist/bundle.js | grep &amp;quot;#22ee22&amp;quot;
exports.push([module.i, &amp;quot;._2T2hBh3FkCro4-BOuqaGg5 {\n  background-color: #22ee22;\n}\n&amp;quot;, &amp;quot;&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest)</title>
          <link>https://www.sambaiz.net/article/100/</link>
          <pubDate>Tue, 09 May 2017 20:25:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/100/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;merge-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-merge&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge&#34;&gt;merge&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;2つのstreamの両方の値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.merge(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`merge ${data}`),
  err =&amp;gt; console.log(`merge ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;forkjoin-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-forkjoin&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin&#34;&gt;forkJoin&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;completeしたときの最後の値を配列としてemitする。
非同期で一つ値をemitするようなstreamで、Promise.allのようなことをしたいときはこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.forkJoin(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`      forkJoin: ${data}`),
  err =&amp;gt; console.log(`      forkJoin: ${err}`)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;concat-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-concat&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-concat&#34;&gt;concat&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;前のstreamがcompleteしたら次のstreamの値がemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.concat(
  stream1,
  stream2
).subscribe(
  data =&amp;gt; console.log(`  concat ${data}`),
  err =&amp;gt; console.log(`  concat ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;combinelatest-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-combinelatest&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-combineLatest&#34;&gt;combineLatest&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;stream自体を結合するのではなく値を結合する。
この例だと、streamでemitされた値がa、stream2で最後のemitされた値がbになる。
combineする値がない場合はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stream1.combineLatest(stream2, (a, b) =&amp;gt; a + b).subscribe(
  data =&amp;gt; console.log(`    combineLatest ${data}`),
  err =&amp;gt; console.log(`    combineLatest ${err}`)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;同時に実行したときの結果&#34;&gt;同時に実行したときの結果&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;const stream1 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 1-${v+1}`).take(3);
const stream2 = Rx.Observable.interval(100).map(v =&amp;gt; `stream 2-${v+1}`).take(3).delay(150);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/100.png&#34; alt=&#34;stream1とstream2&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;merge stream 1-1
  concat stream 1-1
merge stream 1-2
  concat stream 1-2
merge stream 2-1 &amp;lt;- mergeではstream1はcompleteしていないが、stream2がemitされる
merge stream 1-3
  concat stream 1-3
    combineLatest stream 1-3stream 2-1 &amp;lt;- stream2の値がemitされたのでcombineする
merge stream 2-2
    combineLatest stream 1-3stream 2-2
      forkJoin: stream 1-3,stream 2-3 &amp;lt;- stream1とstream2がcompleteしたのでforkJoinでemitされる
    combineLatest stream 1-3stream 2-3
merge stream 2-3
  concat stream 2-1 &amp;lt;- concatではstream1がcompleteしたので、stream2がemitされる
  concat stream 2-2
  concat stream 2-3
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>RxJSでRxをはじめる</title>
          <link>https://www.sambaiz.net/article/85/</link>
          <pubDate>Sat, 18 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/85/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;https://github.com/ReactiveX/rxjs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rx-reactivex-とは-http-reactivex-io-intro-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;Rx(ReactiveX)とは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;非同期処理をうまく扱えるようにするライブラリ。いろんな言語で実装されている。
非同期処理の結果はObservableなStreamに流される。
ObservableはIteratableのように扱うことができる。&lt;/p&gt;

&lt;p&gt;Rxは&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;Observer pattern&lt;/a&gt;
を拡張したもの。
Observer patternというのは、Subjectが、Observeしている全てのObserverに対して通知を送るデザインパターン。
C#などのeventのそれ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/83/&#34;&gt;C#のdelegateとevent - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;inputのkeyupイベントのObservableを作成し、それを&lt;code&gt;subscribe()&lt;/code&gt;して出力している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input&amp;quot; /&amp;gt;

&amp;lt;script&amp;gt;

const inputForm = document.querySelector(&#39;#input&#39;);

const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err)
);

&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力するとこんなのが出力される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;b&amp;quot;, code: &amp;quot;KeyB&amp;quot;, location: 0, ctrlKey: false…}
KeyboardEvent {isTrusted: true, key: &amp;quot;c&amp;quot;, code: &amp;quot;KeyC&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;observable-http-reactivex-io-rxjs-class-es6-observable-js-observable-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html&#34;&gt;Observable&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;create-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-create&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-create&#34;&gt;create&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;でObservableに値をemitし、&lt;code&gt;complete()&lt;/code&gt;で終了させる。
&lt;code&gt;error()&lt;/code&gt;でエラーをemitするとそれ以後の値はemitされない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.create(function (observer) {
    observer.next(&amp;quot;AAAAA&amp;quot;);
    observer.next(&amp;quot;BBBBB&amp;quot;);
    observer.next(&amp;quot;CCCCC&amp;quot;);
    observer.complete();
}).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;AAAA
BBBB
CCCC
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;from-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-from&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-from&#34;&gt;from&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;配列などのIteratableをObservableに変換する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.from([1,2,3]).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
2
3
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fromevent-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-fromevent&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent&#34;&gt;fromEvent&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上で使ったやつ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromEvent(document.querySelector(&#39;#input&#39;), &#39;keyup&#39;).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;frompromise-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-frompromise&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromPromise&#34;&gt;fromPromise&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;PromiseもObservableに変換できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.fromPromise(Promise.resolve(&amp;quot;ok&amp;quot;)).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ok
completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interval-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-static-method-interval&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-interval&#34;&gt;interval&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一定時間ごとにemitし続ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rx.Observable.interval(1000).subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0
1
2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/100/&#34;&gt;RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest) - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;operator-http-reactivex-io-rxjs-manual-overview-html-operators&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/manual/overview.html#operators&#34;&gt;Operator&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observableのメソッド。新しいObservableを作って返す。&lt;/p&gt;

&lt;p&gt;上で試したkeyupのObservableにいろいろやってみる。&lt;/p&gt;

&lt;h3 id=&#34;pluck-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-pluck&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-pluck&#34;&gt;pluck&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;nestされたプロパティを指定する。この例だと&lt;code&gt;.target.value&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;h
ho
hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-filter&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-filter&#34;&gt;filter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;フィルタリングする。この例だと長さが2より大きいものだけがemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 );
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;hog
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;map-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-map&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map&#34;&gt;map&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;map。この例だと&lt;code&gt;value: ${text}&lt;/code&gt;のフォーマットでemitされる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;value: hog
value: hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce-http-reactivex-io-rxjs-class-es6-observable-js-observable-html-instance-method-reduce&#34;&gt;&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-reduce&#34;&gt;reduce&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;reduce。emitされるのはcompleteされたときなので、&lt;a href=&#34;http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-takeUntil&#34;&gt;takeUntil()&lt;/a&gt;で
渡したObservableが何かemitしたときにcompleteさせるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;)
  .takeUntil(Rx.Observable.interval(5000))
  .pluck(&#39;target&#39;, &#39;value&#39;)
  .filter(text =&amp;gt; text.length &amp;gt; 2 )
  .map(text =&amp;gt; `value: ${text}`)
  .reduce((acc, curr) =&amp;gt; `${acc} ${curr}`, &amp;quot;&amp;quot;);

keyups.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; console.log(err),
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; value: aaa value: aaaa value: aaaaa value: aaaaaa value: aaaaaaa value: aaaaaaaa value: aaaaaaaaa value: aaaaaaaaaa value: aaaaaaaaaaa
 completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;subject-http-reactivex-io-documentation-subject-html&#34;&gt;&lt;a href=&#34;http://reactivex.io/documentation/subject.html&#34;&gt;Subject&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Observerでもあり、Observableでもあるブリッジのようなもの。&lt;/p&gt;

&lt;p&gt;これまでのObservableはSubscribeされるまでemitしない&amp;rdquo;Cold&amp;rdquo;なものだったが、
SubjectはそんなObservableをSubscribeし、それをトリガーにemitするので、
&amp;ldquo;Cold&amp;rdquo;なObservableを常にemitし得る&amp;rdquo;Hot&amp;rdquo;なものに変えることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ColdなObservable
const cold = Rx.Observable.from([1,2,3]);

// Coldだと、いつから、何回読んでも同じ値が得られる

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);

// 1, 2, 3, completed
cold.subscribe(
  data =&amp;gt; console.log(data), 
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;publish-subject&#34;&gt;(Publish)Subject&lt;/h3&gt;

&lt;p&gt;Subscribeした時点からemitされたアイテムをemitする。それまでにemitされたアイテムはしない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.Subject(); 

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;) // 1: AAA

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;BBB&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
2: BBB
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;asyncsubject&#34;&gt;AsyncSubject&lt;/h3&gt;

&lt;p&gt;complete時に最後にemitされた値だけをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.AsyncSubject();

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;); 
subject.next(&amp;quot;BBB&amp;quot;);

subject.complete();

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: BBB
1: completed
2: BBB
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;behaviorsubject&#34;&gt;BehaviorSubject&lt;/h3&gt;

&lt;p&gt;Subscribeしたとき、最近のアイテムをemitする。あとはSubjectと同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.BehaviorSubject(&amp;quot;ZZZ&amp;quot;)

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.next(&amp;quot;CCC&amp;quot;); 

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1: ZZZ
1: AAA
1: BBB
2: BBB
1: CCC
2: CCC
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;replaysubject&#34;&gt;ReplaySubject&lt;/h3&gt;

&lt;p&gt;いつSubscribeしてもbufferにある全てのアイテムをemitする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const subject = new Rx.ReplaySubject(2) // buffer size = 2

subject.subscribe(
  data =&amp;gt; console.log(`1: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;1: completed&amp;quot;)
);

subject.next(&amp;quot;AAA&amp;quot;);
subject.next(&amp;quot;BBB&amp;quot;);
subject.next(&amp;quot;CCC&amp;quot;);
subject.next(&amp;quot;DDD&amp;quot;);

subject.subscribe(
  data =&amp;gt; console.log(`2: ${data}`),
  err =&amp;gt; {},
  () =&amp;gt; console.log(&amp;quot;2: completed&amp;quot;)
);

subject.complete(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buffer size = 2 なので2がSubscribeしたときにはAAAとBBBはもうない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: AAA
1: BBB
1: CCC
1: DDD
2: CCC
2: DDD
1: completed
2: completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/wilfrem/tech-rxjs&#34;&gt;歌舞伎座tech発表資料 RxJSの中を追う&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
