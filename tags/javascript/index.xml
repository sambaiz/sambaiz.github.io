<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/javascript/</link>
    <description>Recent content in Javascript on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Fri, 23 Feb 2018 02:01:00 +0900</lastBuildDate>
    
	<atom:link href="https://www.sambaiz.net/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ブラウザのwindow間の値渡し</title>
      <link>https://www.sambaiz.net/article/156/</link>
      <pubDate>Fri, 23 Feb 2018 02:01:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/156/</guid>
      <description>直接Windowを参照する プロトコル、ポート、ドメインが全て同じ場合は、親はopen()した返り値で、子はwindow.openerで相手のwindowが取れて、直接参照したりDOMを操作したりすることもできる。
$ cat index.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Open window&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;quot;btn2&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; let win2; const button = document.getElementById(&amp;quot;btn&amp;quot;); button.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { window.foo = &amp;quot;bar from window1&amp;quot;; win2 = window.open(&amp;quot;index2.html&amp;quot;); }, false); const button2 = document.getElementById(&amp;quot;btn2&amp;quot;); button2.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { if (win2) { win2.close(); } }, false); &amp;lt;/script&amp;gt;  $ cat index2.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; console.log(window.aaa); const parentWindow = window.opener; const view = document.getElementById(&amp;quot;view&amp;quot;); view.</description>
    </item>
    
    <item>
      <title>Chromeで任意のscriptを読み込まれる前に差し替える</title>
      <link>https://www.sambaiz.net/article/150/</link>
      <pubDate>Thu, 01 Feb 2018 21:54:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/150/</guid>
      <description>ChromeのDevToolsではSourcesからscriptを書き換えられるようになっているが、 一行目にbreakpointを挟んで更新するとそこで止まるので読み込まれる前に差し替えることができる。 ページの読み込み時に呼ばれるSDKやライブラリの影響範囲を調べたりデバッグしたりするのに便利。
確認用jsとhtml
console.log(&amp;quot;original&amp;quot;)  &amp;lt;script src=&amp;quot;index.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  読み込み時に実行されるconsole.logの文章を変えた。</description>
    </item>
    
    <item>
      <title>JavaScriptのrequire/importの歴史</title>
      <link>https://www.sambaiz.net/article/143/</link>
      <pubDate>Sat, 11 Nov 2017 20:20:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/143/</guid>
      <description>scriptタグを並べる &amp;lt;body&amp;gt; &amp;lt;script src=&amp;quot;a.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;b.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;  先に書かれたa.jsで定義された内容はb.jsで読むことができる。
$ cat a.js const a = &#39;a is defined&#39;; const divA = document.createElement(&#39;div&#39;); divA.textContent = (typeof b !== &#39;undefined&#39;) ? b : &#39;b is undefined&#39;; document.body.appendChild(divA); $ cat b.js const b = &#39;b is defined&#39;; const divB = document.createElement(&#39;div&#39;); divB.textContent = (typeof a !== &#39;undefined&#39;) ? a : &#39;a is undefined&#39;; document.body.appendChild(divB);  依存が増えてくると順番を考えるのが大変。さらにグローバルな名前空間を汚染してしまう。
b is undefined a is defined  AMDとCommonJS というのも、かつてのJSにはモジュールを読み込む仕組みがなかった。 そこで考えられたのがAMDやCommonJSというフォーマット。 AMD(Asynchronous module definition)はRequireJSによって提供されるrequire()で動的にscriptタグを埋める。CommonJSはNodeでもおなじみのrequire()で、これにWebpackを通して一つのファイルにまとめておく。同じ関数名が使われているが全くの別物。</description>
    </item>
    
    <item>
      <title>RxJSでObservableを結合する(merge, forkJoin, concat, combineLatest)</title>
      <link>https://www.sambaiz.net/article/100/</link>
      <pubDate>Tue, 09 May 2017 20:25:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/100/</guid>
      <description>RxJSでRxをはじめる - sambaiz.net
merge 2つのstreamの両方の値がemitされる。
Rx.Observable.merge( stream1, stream2 ).subscribe( data =&amp;gt; console.log(`merge ${data}`), err =&amp;gt; console.log(`merge ${err}`) );  forkJoin completeしたときの最後の値を配列としてemitする。 非同期で一つ値をemitするようなstreamで、Promise.allのようなことをしたいときはこれ。
Rx.Observable.forkJoin( stream1, stream2 ).subscribe( data =&amp;gt; console.log(` forkJoin: ${data}`), err =&amp;gt; console.log(` forkJoin: ${err}`) )  concat 前のstreamがcompleteしたら次のstreamの値がemitされる。
Rx.Observable.concat( stream1, stream2 ).subscribe( data =&amp;gt; console.log(` concat ${data}`), err =&amp;gt; console.log(` concat ${err}`) );  combineLatest stream自体を結合するのではなく値を結合する。 この例だと、streamでemitされた値がa、stream2で最後のemitされた値がbになる。 combineする値がない場合はemitされない。
stream1.combineLatest(stream2, (a, b) =&amp;gt; a + b).subscribe( data =&amp;gt; console.</description>
    </item>
    
    <item>
      <title>RxJSでRxをはじめる</title>
      <link>https://www.sambaiz.net/article/85/</link>
      <pubDate>Sat, 18 Mar 2017 21:36:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/85/</guid>
      <description>https://github.com/ReactiveX/rxjs
Rx(ReactiveX)とは 非同期処理をうまく扱えるようにするライブラリ。いろんな言語で実装されている。 非同期処理の結果はObservableなStreamに流される。 ObservableはIteratableのように扱うことができる。
RxはObserver pattern を拡張したもの。 Observer patternというのは、Subjectが、Observeしている全てのObserverに対して通知を送るデザインパターン。 C#などのeventのそれ。
C#のdelegateとevent - sambaiz.net
試してみる inputのkeyupイベントのObservableを作成し、それをsubscribe()して出力している。
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input&amp;quot; /&amp;gt; &amp;lt;script&amp;gt; const inputForm = document.querySelector(&#39;#input&#39;); const keyups = Rx.Observable.fromEvent(inputForm, &#39;keyup&#39;); keyups.subscribe( data =&amp;gt; console.log(data), err =&amp;gt; console.log(err) ); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  入力するとこんなのが出力される。
KeyboardEvent {isTrusted: true, key: &amp;quot;a&amp;quot;, code: &amp;quot;KeyA&amp;quot;, location: 0, ctrlKey: false…} KeyboardEvent {isTrusted: true, key: &amp;quot;b&amp;quot;, code: &amp;quot;KeyB&amp;quot;, location: 0, ctrlKey: false…} KeyboardEvent {isTrusted: true, key: &amp;quot;c&amp;quot;, code: &amp;quot;KeyC&amp;quot;, location: 0, ctrlKey: false…}  Observable create next()でObservableに値をemitし、complete()で終了させる。 error()でエラーをemitするとそれ以後の値はemitされない。</description>
    </item>
    
  </channel>
</rss>