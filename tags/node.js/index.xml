<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/node.js/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2018</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>SlackのInteractive messagesでボタンの入力を受け付ける</title>
          <link>https://www.sambaiz.net/article/148/</link>
          <pubDate>Tue, 16 Jan 2018 21:59:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/148/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://api.slack.com/interactive-messages&#34;&gt;Interactive messages&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/148.gif&#34; alt=&#34;ボタンを押す&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずはサーバーを用意する。コードは&lt;a href=&#34;https://github.com/sambaiz/node-slack-interactive-messages-sample&#34;&gt;ここ&lt;/a&gt;にあって、
Interactive messagesのハンドリングはSlack公式の&lt;a href=&#34;https://github.com/slackapi/node-slack-interactive-messages&#34;&gt;node-slack-interactive-messages&lt;/a&gt;を使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(&#39;/slack&#39;, slackMessages.expressMiddleware());

slackMessages.action(&#39;question_button&#39;, (payload) =&amp;gt; {
  let replacement = payload.original_message;
  replacement.text =`${payload.user.name} likes ${payload.actions[0].value}`;
  delete replacement.attachments[0].actions;
  return replacement;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ボタンの表示はattachmentsを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web.chat.postMessage(channelId, &#39;Question&#39;, {
  attachments: [
    {
      text: &amp;quot;Which buttons do you like?&amp;quot;,
      color: &amp;quot;#f9a41b&amp;quot;,
      callback_id: &amp;quot;question_button&amp;quot;,
      actions: [
        {
          name: &amp;quot;primary_button&amp;quot;,
          type: &amp;quot;button&amp;quot;,
          style: &amp;quot;primary&amp;quot;,
          text: &amp;quot;Primary&amp;quot;,
          value: &amp;quot;Primary Button&amp;quot;,
        },
        {
          name: &amp;quot;normal_button&amp;quot;,
          type: &amp;quot;button&amp;quot;,
          text: &amp;quot;Normal&amp;quot;,
          value: &amp;quot;Normal Button&amp;quot;
        },
        {
          name: &amp;quot;danger_button&amp;quot;,
          type: &amp;quot;button&amp;quot;,
          style: &amp;quot;danger&amp;quot;,
          text: &amp;quot;Danger&amp;quot;,
          value: &amp;quot;Danger Button&amp;quot;,
          confirm: {
            title: &amp;quot;Really?&amp;quot;,
            text: &amp;quot;This is danger&amp;quot;,
            ok_text: &amp;quot;Yes&amp;quot;,
            dismiss_text: &amp;quot;No&amp;quot;
          }
        },
      ]
    }
  ]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外に公開する必要があるので、メッセージの送信のエンドポイントはBasic認証をかけてみた。
Interactive messagesのエンドポイントはVerification tokenが一致することを確認している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(bodyParser.urlencoded({ extended: false }));
app.all(&#39;/auth/*&#39;, (req, res, next) =&amp;gt; {
  const credentials = auth(req);
  if (!credentials || !check(credentials.name, credentials.pass)) {
    res.status(401).send(&#39;Unauthorized&#39;);
  } else {
    next();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://*****.ngrok.com/auth/message -H &amp;quot;Authorization: Basic $(echo -n &#39;foobar:dolphins&#39; | base64)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://api.slack.com/apps&#34;&gt;Build&lt;/a&gt;からWorkspaceを選択してAppを作成し、
Appに紐づくBot Userを追加後、Install Appすると&lt;code&gt;Bot User OAuth Access Token&lt;/code&gt;
が表示されるので、これで&lt;a href=&#34;https://api.slack.com/methods/chat.postMessage&#34;&gt;postMessage&lt;/a&gt;し、Basic InformationのApp Credentialsにある&lt;code&gt;Verification Token&lt;/code&gt;をInteractive messagesのチェックに使う。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tech.mercari.com/entry/2017/05/23/095500&#34;&gt;GolangでSlack Interactive Messageを使ったBotを書く - Mercari Engineering Blog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Athenaのmigrationやpartitionするathena-adminを作った</title>
          <link>https://www.sambaiz.net/article/145/</link>
          <pubDate>Sun, 24 Dec 2017 23:31:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/145/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/athena-admin&#34;&gt;https://github.com/sambaiz/athena-admin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AthenaはS3をデータソースとするマネージドなデータ分析基盤。Prestoベースで標準SQLを実行できる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/athena/pricing/&#34;&gt;料金&lt;/a&gt;はスキャンしたデータ量にかかり、$5/TB。1MB切り上げで、10MB以下のクエリは10MBになる。
データ量に対してかなり安く使えるものの、フルスキャンしてしまうとBigQueryと同様にお金が溶けてしまうので、大抵はパーティションを切ることになるのだけど都度locationを指定して&lt;code&gt;ADD PARTITION&lt;/code&gt;を実行するのは大変。さらにスキーマを変更するのにも&lt;code&gt;ALTER TABLE ADD COLUMNS&lt;/code&gt;などはないのでテーブルを作り直すことになるが、当然パーティションも全部作り直すことになる。&lt;/p&gt;

&lt;p&gt;ではどうしようもないかというと&lt;code&gt;MSCK REPAIR TABLE&lt;/code&gt;というのがあって、
これはS3のObjectの&lt;code&gt;dt=YYYY-MM-DD&lt;/code&gt;のようなkey=valueのprefixを認識してパーティションを作るもの。作り直す際もこれ1クエリで終わる。それなら最初からそういう風に置けばよいのではというところだけど、勝手に&lt;code&gt;YYYY/MM/DD/HH&lt;/code&gt;のprefixを付けてしまうFirehoseのようなのもある。&lt;/p&gt;

&lt;p&gt;今回作った&lt;a href=&#34;https://github.com/sambaiz/athena-admin&#34;&gt;athena-admin&lt;/a&gt;は以下のような定義ファイルから、
パーティションのkey=valueのprefixが付くように置き換えたり、変更があったらmigrationする。
このファイルを書き換えるだけで基本的にどうにかなるし、バージョン管理すればテーブル定義の変更を追うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;general&amp;quot;: {
    &amp;quot;athenaRegion&amp;quot;: &amp;quot;ap-northeast-1&amp;quot;,
    &amp;quot;databaseName&amp;quot;: &amp;quot;aaaa&amp;quot;,
    &amp;quot;saveDefinitionLocation&amp;quot;: &amp;quot;s3://saveDefinitionBucket/aaaa.json&amp;quot;
  },
  &amp;quot;tables&amp;quot;: {
    &amp;quot;sample_data&amp;quot;: {
      &amp;quot;columns&amp;quot;: {
        &amp;quot;user_id&amp;quot;: &amp;quot;int&amp;quot;,
        &amp;quot;value&amp;quot;: {
          &amp;quot;score&amp;quot;: &amp;quot;int&amp;quot;,
          &amp;quot;category&amp;quot;: &amp;quot;string&amp;quot;
        } /* &amp;quot;struct&amp;lt;score:int,category:string&amp;gt;&amp;quot; のように書くこともできる */
      },
      &amp;quot;srcLocation&amp;quot;: &amp;quot;s3://src/location/&amp;quot;,
      &amp;quot;partition&amp;quot;: {
        &amp;quot;prePartitionLocation&amp;quot;: &amp;quot;s3://pre/partition/&amp;quot;, /* optional */
        &amp;quot;regexp&amp;quot;: &amp;quot;(\\d{4})/(\\d{2})/(\\d{2})/&amp;quot;, /* optional */
        &amp;quot;keys&amp;quot;: [
          {
            &amp;quot;name&amp;quot;: &amp;quot;dt&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
            &amp;quot;format&amp;quot;: &amp;quot;{1}-{2}-{3}&amp;quot;, /* optional */
          }
        ]
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使い方はこんな感じ。使い方によっては&lt;code&gt;migrate()&lt;/code&gt;だけ呼ぶこともあると思う。
&lt;code&gt;replaceObjects()&lt;/code&gt;にはmatchedHandlerというのを渡すこともできて、
UTCからJSTに変換するといったこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install athena-admin
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const AthenaAdmin = require(&#39;athena-admin&#39;).AthenaAdmin;
const dbDef = require(&#39;./sampledatabase.json&#39;);
const admin = new AthenaAdmin(dbDef);
await admin.replaceObjects();
await admin.migrate();
await admin.partition();
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ApexでデプロイしたLambdaのトリガーをTerraformで管理する</title>
          <link>https://www.sambaiz.net/article/144/</link>
          <pubDate>Sun, 12 Nov 2017 22:23:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/144/</guid>
          <description>

&lt;p&gt;Apexでfunctionをデプロイするとトリガーが登録されないのであとで追加することになる。
これを手作業で行うこともできるのだけど、せっかくなのでアプリケーションと一緒に管理したい。
そんなときのために&lt;code&gt;terraform&lt;/code&gt;コマンドをラップした&lt;a href=&#34;http://apex.run/#managing-infrastructure&#34;&gt;apex infra&lt;/a&gt;が用意されている。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/121/&#34;&gt;TerraformでVPCを管理するmoduleを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;functionsと同列にinfrastructureディレクトリを作成してtfファイルを置く。
その下に環境ごとのディレクトリを作成することもできて、その場合は&lt;code&gt;--env&lt;/code&gt;で指定した環境のものが使われる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- functions
- infrastructure
  main.tf
  variables.tf
  - modules
    - cloudwatch_schedule
      main.tf
      variables.tf
project.json 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;functionをデプロイするとそのARNが変数で取れるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex list --tfvars
apex_function_hello=&amp;quot;arn:aws:lambda:ap-northeast-1:*****:function:usetf_hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回設定するトリガーはCloudwatch Eventのスケジューリング。作成するリソースは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_rule.html&#34;&gt;aws_cloudwatch_event_rule&lt;/a&gt;でイベントルール(今回はschedule)を作成&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_target.html&#34;&gt;aws_cloudwatch_event_target&lt;/a&gt;でルールにターゲット(今回はLambda)を設定&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/docs/providers/aws/r/lambda_permission.html&#34;&gt;aws_lambda_permission&lt;/a&gt;でルールに対象Lambdaをinvokeする権限を付ける&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ cat infrastructure/modules/cloudwatch_schefule/variables.tf
variable &amp;quot;lambda_function_name&amp;quot; {}
variable &amp;quot;lambda_function_arn&amp;quot; {}
variable &amp;quot;schedule_expression&amp;quot; {
    description = &amp;quot;cloudwatch schedule expression e.g. \&amp;quot;cron(0/5 * * * ? *)\&amp;quot;&amp;quot;
}

$ cat infrastructure/modules/cloudwatch_schefule/main.tf
resource &amp;quot;aws_cloudwatch_event_rule&amp;quot; &amp;quot;lambda&amp;quot; {
  name        = &amp;quot;lambda_rule_${var.lambda_function_name}&amp;quot;
  description = &amp;quot;invoke lambda ${var.lambda_function_name}&amp;quot;
  schedule_expression = &amp;quot;${var.schedule_expression}&amp;quot;
}
 
resource &amp;quot;aws_cloudwatch_event_target&amp;quot; &amp;quot;lambda&amp;quot; {
  target_id = &amp;quot;lambda_target_${var.lambda_function_name}&amp;quot;
  rule      = &amp;quot;${aws_cloudwatch_event_rule.lambda.name}&amp;quot;
  arn       = &amp;quot;${var.lambda_function_arn}&amp;quot;
}
 
resource &amp;quot;aws_lambda_permission&amp;quot; &amp;quot;lambda&amp;quot; {
  statement_id  = &amp;quot;AllowExecutionFromCloudWatch&amp;quot;
  action        = &amp;quot;lambda:InvokeFunction&amp;quot;
  function_name = &amp;quot;${aws_cloudwatch_event_target.lambda.arn}&amp;quot;
  principal     = &amp;quot;events.amazonaws.com&amp;quot;
  source_arn    = &amp;quot;${aws_cloudwatch_event_rule.lambda.arn}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat infrastructure/variables.tf 
variable &amp;quot;apex_function_names&amp;quot; {
    type=&amp;quot;map&amp;quot;
}
variable &amp;quot;apex_function_hello&amp;quot; {}

$ cat infrastructure/main.tf
terraform {
  backend &amp;quot;s3&amp;quot; {
    bucket = &amp;quot;sambaiz-terraform&amp;quot;
    key    = &amp;quot;usetf.tfstate&amp;quot;
    region = &amp;quot;ap-northeast-1&amp;quot;
  }
}

module &amp;quot;hello_trigger&amp;quot; {
  source = &amp;quot;./modules/cloudwatch_schedule&amp;quot;
  lambda_function_name = &amp;quot;${var.apex_function_names[&amp;quot;hello&amp;quot;]}&amp;quot;
  lambda_function_arn = &amp;quot;${var.apex_function_hello}&amp;quot;
  schedule_expression = &amp;quot;cron(0/5 * * * ? *)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt;してbackendを初期化してmoduleを準備する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex infra init
$ ls infrastructure/.terraform/modules/*****
main.tf		variables.tf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plan&lt;/code&gt;するとこんな感じ。ApexによってfunctionのARNが渡っていることが分かる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex infra plan
+ module.hello_trigger.aws_cloudwatch_event_rule.lambda
    arn:                 &amp;quot;&amp;lt;computed&amp;gt;&amp;quot;
    description:         &amp;quot;invoke lambda usetf_hello&amp;quot;
    is_enabled:          &amp;quot;true&amp;quot;
    name:                &amp;quot;lambda_rule_usetf_hello&amp;quot;
    schedule_expression: &amp;quot;cron(0/5 * * * ? *)&amp;quot;

+ module.hello_trigger.aws_cloudwatch_event_target.lambda
    arn:       &amp;quot;arn:aws:lambda:ap-northeast-1:*****:function:usetf_hello&amp;quot;
    rule:      &amp;quot;lambda_rule_usetf_hello&amp;quot;
    target_id: &amp;quot;lambda_target_usetf_hello&amp;quot;

+ module.hello_trigger.aws_lambda_permission.lambda
    action:        &amp;quot;lambda:InvokeFunction&amp;quot;
    function_name: &amp;quot;arn:aws:lambda:ap-northeast-1:*****:function:usetf_hello&amp;quot;
    principal:     &amp;quot;events.amazonaws.com&amp;quot;
    source_arn:    &amp;quot;${aws_cloudwatch_event_rule.lambda.arn}&amp;quot;
    statement_id:  &amp;quot;AllowExecutionFromCloudWatch&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt;するとトリガーが登録される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex infra apply
$ apex logs hello
...
/aws/lambda/usetf_hello 2017-11-12T13:20:14.561Z	37e75818-c7ac-11e7-a333-111863808b13	processing event:
...
/aws/lambda/usetf_hello 2017-11-12T13:25:15.182Z	eb178941-c7ac-11e7-bde0-998ea9659640 processing event:
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.classmethod.jp/cloud/aws/ami-and-snapshot-delete-with-apex-and-terraform/&#34;&gt;ApexとTerraformでCloudWatch EventsによりInvokeされるLambda関数をデプロイする ｜ Developers.IO&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>JavaScriptのrequire/import</title>
          <link>https://www.sambaiz.net/article/143/</link>
          <pubDate>Sat, 11 Nov 2017 20:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/143/</guid>
          <description>

&lt;h2 id=&#34;scriptタグを並べる&#34;&gt;scriptタグを並べる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
&amp;lt;script src=&amp;quot;a.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;b.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先に書かれた&lt;code&gt;a.js&lt;/code&gt;で定義された内容は&lt;code&gt;b.js&lt;/code&gt;で読むことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat a.js 
const a = &#39;a is defined&#39;;
const divA = document.createElement(&#39;div&#39;);
divA.textContent = (typeof b !== &#39;undefined&#39;) ? b : &#39;b is undefined&#39;;
document.body.appendChild(divA);

$ cat b.js 
const b = &#39;b is defined&#39;;
const divB = document.createElement(&#39;div&#39;);
divB.textContent = (typeof a !== &#39;undefined&#39;) ? a : &#39;a is undefined&#39;;
document.body.appendChild(divB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存が増えてくると順番を考えるのが大変。さらにグローバルな名前空間を汚染してしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;b is undefined
a is defined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;amdとcommonjs&#34;&gt;AMDとCommonJS&lt;/h2&gt;

&lt;p&gt;というのも、かつてのJSにはモジュールを読み込む仕組みがなかった。
そこで考えられたのがAMDやCommonJSというフォーマット。
AMD(Asynchronous module definition)は&lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;によって提供される&lt;code&gt;require()&lt;/code&gt;で動的にscriptタグを埋める。CommonJSはNodeでもおなじみの&lt;code&gt;require()&lt;/code&gt;で、これにWebpackを通して一つのファイルにまとめておく。同じ関数名が使われているが全くの別物。&lt;/p&gt;

&lt;h2 id=&#34;es-modules&#34;&gt;ES Modules&lt;/h2&gt;

&lt;p&gt;今は言語仕様にECMAScript Modulesが追加され、普通に&lt;code&gt;import&lt;/code&gt;でモジュールを読み込めるようになったが、
対応ブラウザがまだ少ないこともあり基本的にはWebpackをかけることになる。
Nodeにも実装されつつあるがStableになるのは&lt;a href=&#34;https://nodejs.org/api/esm.html&#34;&gt;まだ先&lt;/a&gt;のようだ。&lt;/p&gt;

&lt;h2 id=&#34;requirejs-http-requirejs-org&#34;&gt;&lt;a href=&#34;http://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;define()&lt;/code&gt;でモジュールを定義し、&lt;code&gt;require()&lt;/code&gt;で読み込む。
エントリーポイントは&lt;code&gt;data-main&lt;/code&gt;に指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/b.js
require([&#39;a&#39;], (a) =&amp;gt; {
  const divB = document.createElement(&#39;div&#39;);
  divB.textContent = a.a();
  document.body.appendChild(divB);
});

$ cat src/a.js
define({
  a: () =&amp;gt; &#39;a is defined&#39;
});

$ cat src/index.html
&amp;lt;body&amp;gt;
&amp;lt;script data-main=&amp;quot;b.js&amp;quot; src=&amp;quot;require.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CommonJSのモジュールを読み込もうとするとエラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/c.js 
const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

$ cat src/d.js 
exports.d = () =&amp;gt; &#39;d is defined&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Uncaught Error: Module name &amp;quot;d&amp;quot; has not been loaded yet for context: _. Use require([])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RequireJSのNode版、&lt;a href=&#34;https://github.com/requirejs/r.js&#34;&gt;r.js&lt;/a&gt;でCommonJSのモジュールをAMDに変換することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g requirejs
$ r.js -convert src out
$ cat c.js 
define(function (require, exports, module) {const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

});

$ cat d.js 
define(function (require, exports, module) {exports.d = () =&amp;gt; &#39;d is defined&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、Webpackのようにコードを一つのjsファイルにbundleすることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ r.js -o baseUrl=out name=b out=bundle.js optimize=none
$ cat bundle.js 
define(&#39;a&#39;,{
  a: () =&amp;gt; &#39;a is defined&#39;
});

define(&#39;d&#39;,[&#39;require&#39;,&#39;exports&#39;,&#39;module&#39;],function (require, exports, module) {exports.d = () =&amp;gt; &#39;d is defined&#39;;


});

define(&#39;c&#39;,[&#39;require&#39;,&#39;exports&#39;,&#39;module&#39;,&#39;d&#39;],function (require, exports, module) {const d = require(&#39;d&#39;);
exports.c = () =&amp;gt; {
  return d.d();
};

});

require([&#39;a&#39;,&#39;c&#39;], (a,c) =&amp;gt; {
  const divB = document.createElement(&#39;div&#39;);
  divB.textContent = a.a();
  document.body.appendChild(divB);

  const divB2 = document.createElement(&#39;div&#39;);
  divB2.textContent = c.c();
  document.body.appendChild(divB2);
});

define(&amp;quot;b&amp;quot;, function(){});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに&lt;code&gt;optimize=none&lt;/code&gt;を付けているのはES6のコードに対応していないため。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If the source uses ES2015 or later syntax, please pass &amp;quot;optimize: &#39;none&#39;&amp;quot; to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/guybedford/require-css&#34;&gt;guybedford/require-css&lt;/a&gt;を使うと
cssも依存に含めることができ、scriptタグと同様にstyleタグが動的に入る。&lt;/p&gt;

&lt;h2 id=&#34;webpack-https-webpack-js-org&#34;&gt;&lt;a href=&#34;https://webpack.js.org/&#34;&gt;Webpack&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;の
&lt;code&gt;entry&lt;/code&gt;にエントリーポイント、
&lt;code&gt;output&lt;/code&gt;に出力場所、
&lt;code&gt;module&lt;/code&gt;にJS以外のファイルをbundleするloader、
&lt;code&gt;plugins&lt;/code&gt;に全体を処理するpluginの
設定を書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev webpack html-webpack-plugin
$ cat webpack.config.js 
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const webpack = require(&#39;webpack&#39;);
const path = require(&#39;path&#39;);

const config = {
  entry: &#39;./src/main.js&#39;,
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;
  },
  module: {},
  plugins: [
    // new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: &#39;./src/index.html&#39;})
  ]
};

module.exports = config;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES Modulesの記法を使っている。CommonJSにも対応しているが今はこちらが&lt;a href=&#34;https://webpack.js.org/api/module-methods/&#34;&gt;推奨&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.js 
import { bar } from &#39;./foo&#39;;
const div = document.createElement(&#39;div&#39;);
div.textContent = bar();
document.body.appendChild(div);

$ cat src/foo.js 
export function bar() {
  return &#39;bar&#39;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行するとこんな感じにbundleされる。実際はUglifyJsPluginによってもう少しサイズが小さくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node_modules/.bin/webpack 
$ cat dist/index.html 
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

$ z$ cat dist/bundle.js 
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
...
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&amp;quot;use strict&amp;quot;;
Object.defineProperty(__webpack_exports__, &amp;quot;__esModule&amp;quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__foo__ = __webpack_require__(1);

const div = document.createElement(&#39;div&#39;);
div.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__foo__[&amp;quot;a&amp;quot; /* bar */])();
document.body.appendChild(div);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&amp;quot;use strict&amp;quot;;
/* harmony export (immutable) */ __webpack_exports__[&amp;quot;a&amp;quot;] = bar;
function bar() {
  return &#39;bar&#39;;
};


/***/ })
/******/ ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/webpack-contrib/css-loader&#34;&gt;css-loader&lt;/a&gt;でCSSをbundleする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev style-loader css-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS Moduleを有効にして、ほかの同名のクラスに影響を及ぼさないようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module: {
    rules: [
      {
        test: /\.css$/,
        use: [ 
          &#39;style-loader&#39;, 
          {
            loader: &#39;css-loader&#39;,
            options: {
              modules: true,
            }
          }
        ]
      }
    ]
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;importするとCSSに書かれたクラスと変換後の対応が取れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.js 
import { bar } from &#39;./foo&#39;;
import css from &#39;./style.css&#39;;

const div = document.createElement(&#39;div&#39;);
div.textContent = bar();
div.className = css[&#39;bg&#39;]; /* {&amp;quot;bg&amp;quot;:&amp;quot;_2T2hBh3FkCro4-BOuqaGg5&amp;quot;} */
document.body.appendChild(div);

$ cat src/style.css 
.bg {
  background-color: #22ee22;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じでbundleされている。動的にstyleタグが入るのは同じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat dist/bundle.js | grep &amp;quot;#22ee22&amp;quot;
exports.push([module.i, &amp;quot;._2T2hBh3FkCro4-BOuqaGg5 {\n  background-color: #22ee22;\n}\n&amp;quot;, &amp;quot;&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ApexでLambdaをデプロイする</title>
          <link>https://www.sambaiz.net/article/140/</link>
          <pubDate>Sun, 22 Oct 2017 16:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/140/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/apex/apex&#34;&gt;Apex&lt;/a&gt;でLambdaをデプロイする。
とても簡単に使えるし、変なこともしないので良い感じ。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Serverless Frameworkだとeventの設定までカバーできてより便利。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/155/&#34;&gt;Serverless FrameworkでLambdaをデプロイする - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;インストール。ダウンロードして実行できるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl https://raw.githubusercontent.com/apex/apex/master/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;IAMFullAccess&lt;/li&gt;
&lt;li&gt;AWSLambdaFullAccess&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を付けたIAMのプロファイルを登録しておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ aws configure --profile apex
$ aws configure list --profile apex
      Name                    Value             Type    Location
      ----                    -----             ----    --------
   profile                     apex           manual    --profile
access_key     ****************OVGQ shared-credentials-file    
secret_key     ****************oi5t shared-credentials-file    
    region           ap-northeast-1      config-file    ~/.aws/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apex init&lt;/code&gt;してnameとdescriptionを入れるとIAMが登録され、
ディレクトリ構造が作られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex init --profile apex
Project name: try-apex
Project description: test  
[+] creating IAM try-apex_lambda_function role
[+] creating IAM try-apex_lambda_logs policy
[+] attaching policy to lambda_function role.
[+] creating ./project.json
[+] creating ./functions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;package.jsonで環境変数などの設定ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -R
functions	project.json

./functions:
hello

./functions/hello:
index.js

$ cat project.json 
{
  &amp;quot;name&amp;quot;: &amp;quot;try-apex&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;test&amp;quot;,
  &amp;quot;memory&amp;quot;: 128,
  &amp;quot;timeout&amp;quot;: 5,
  &amp;quot;role&amp;quot;: &amp;quot;arn:aws:iam::524580158183:role/try-apex_lambda_function&amp;quot;,
  &amp;quot;environment&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apex deploy&lt;/code&gt;するとlambdaが作られる。&lt;code&gt;--dry-run&lt;/code&gt;もできる。
バージョン管理されているので&lt;code&gt;rollback&lt;/code&gt;もできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex deploy hello --profile apex
   • creating function         env= function=hello
   • created alias current     env= function=hello version=1
   • function created          env= function=hello name=try-apex_hello version=1

$ apex list

  hello
    runtime: nodejs6.10
    memory: 128mb
    timeout: 5s
    role: arn:aws:iam::*****:role/try-apex_lambda_function
    handler: index.handle
    arn: arn:aws:lambda:ap-northeast-1:*****:function:try-apex_hello:current
    aliases: current@v1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;マネジメントコンソールではここでバージョンが確認できる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.sambaiz.net/images/140.png&#34; alt=&#34;バージョンの確認&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apex invoke&lt;/code&gt;で実行。標準入力でイベントを渡せる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apex invoke hello
{&amp;quot;hello&amp;quot;:&amp;quot;world&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パッケージに含めないファイルは.apexignoreに書く。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのコードをPrettierでフォーマットしてESLintにかける</title>
          <link>https://www.sambaiz.net/article/139/</link>
          <pubDate>Thu, 19 Oct 2017 00:35:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/139/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/prettier/prettier&#34;&gt;Prettier&lt;/a&gt;はJSやTSのコードフォーマッタで、
ReactやBabel、Yarnなどの開発にも使われている。&lt;/p&gt;

&lt;p&gt;今回はPrettierでフォーマットしたものを
&lt;code&gt;eslint --fix&lt;/code&gt;する&lt;a href=&#34;https://github.com/prettier/prettier-eslint-cli&#34;&gt;prettier-eslint-cli&lt;/a&gt;を使う。役割が被っているけどPrettierは&lt;code&gt;eslint --fix&lt;/code&gt;よりも強力にフォーマットしてくれるようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init
$ yarn add --dev eslint eslint-config-google prettier-eslint-cli husky lint-staged
$ cat .eslintrc.js 
module.exports = {
    &amp;quot;extends&amp;quot;: &amp;quot;google&amp;quot;,
    &amp;quot;parserOptions&amp;quot;: {
    	&amp;quot;ecmaVersion&amp;quot;: 2017,
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;対象のコードはこれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat src/main.js
/**
 * hoge function
 */
function hoge() {

  const f = (aaaaaaaaaaaaaaa, bbbbbbbbbb, ccccccccc, dddddddddddd, eeeeeeeeeeeeee) =&amp;gt;
    console.log(&#39;a&#39;);


  f(1, 2, 3, 4, 5);
}


hoge();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prettierのドキュメントでも紹介されているように&lt;a href=&#34;https://github.com/okonet/lint-staged&#34;&gt;lint-staged&lt;/a&gt;を使うとCommit時にフォーマットし、Lintをかけることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;precommit&amp;quot;: &amp;quot;lint-staged&amp;quot;,
    &amp;quot;lint&amp;quot;: &amp;quot;eslint src&amp;quot;,
    &amp;quot;format&amp;quot;: &amp;quot;prettier-eslint --write \&amp;quot;src/**/*.js\&amp;quot;&amp;quot;
  },
  &amp;quot;lint-staged&amp;quot;: {
    &amp;quot;*.js&amp;quot;: [
      &amp;quot;prettier-eslint --write&amp;quot;,
      &amp;quot;eslint&amp;quot;,
      &amp;quot;git add&amp;quot;
    ]
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;eslint&amp;quot;: &amp;quot;^4.9.0&amp;quot;,
    &amp;quot;eslint-config-google&amp;quot;: &amp;quot;^0.9.1&amp;quot;,
    &amp;quot;husky&amp;quot;: &amp;quot;^0.14.3&amp;quot;,
    &amp;quot;lint-staged&amp;quot;: &amp;quot;^4.2.3&amp;quot;,
    &amp;quot;prettier-eslint-cli&amp;quot;: &amp;quot;^4.4.0&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;test&amp;quot;
husky &amp;gt; npm run -s precommit (node v8.2.1)

 ✔ Running tasks for *.js
[master e325ea3] test

$ cat src/main.js 
/**
 * hoge function
 */
function hoge() {
  const f = (
    aaaaaaaaaaaaaaa,
    bbbbbbbbbb,
    ccccccccc,
    dddddddddddd,
    eeeeeeeeeeeeee
  ) =&amp;gt; console.log(&#39;a&#39;);

  f(1, 2, 3, 4, 5);
}

hoge();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prettierは&lt;code&gt;eslint --fix&lt;/code&gt;で修正されないmax-lenも良い感じにしてくれる。
なのでESLintのフォーマットに関するところはほとんど修正いらないはず。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;test&amp;quot;
husky &amp;gt; npm run -s precommit (node v8.2.1)

 ❯ Running tasks for *.js
   ✖ eslint --fix
     git add
✖ eslint --fix found some errors. Please fix them and try committing again.

***/src/main.js
  5:1  error  Line 5 exceeds the maximum line length of 80  max-len

✖ 1 problem (1 error, 0 warnings)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Lambda上でPuppeteer/Headless Chromeを動かすStarter Kitを作った</title>
          <link>https://www.sambaiz.net/article/132/</link>
          <pubDate>Sun, 10 Sep 2017 23:45:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/132/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer&#34;&gt;Puppeteer&lt;/a&gt;でHeadless Chromeを動かすコードを
Lambda上で動かすStarter Kitを作った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sambaiz/puppeteer-lambda-starter-kit&#34;&gt;puppeteer-lambda-starter-kit&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;chromeの準備&#34;&gt;Chromeの準備&lt;/h2&gt;

&lt;p&gt;Puppeteerのインストール時に落としてくるChromeをLambda上で動かそうとしても
Lambdaにないshared libraryに依存しているため失敗する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error while loading shared libraries: libpangocairo-1.0.so.0: cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lambda上でHeadless Chromeを動かす例がないか調べたら&lt;a href=&#34;https://github.com/adieuadieu/serverless-chrome&#34;&gt;serverless-chrome&lt;/a&gt;というのがあって、
Headless用の設定でChromeをビルドしていた。
ほかには&lt;a href=&#34;https://github.com/graphcool/chromeless&#34;&gt;chromeless&lt;/a&gt;というのもあるけど
これはserverless-chromeに
&lt;a href=&#34;https://github.com/graphcool/chromeless/blob/master/serverless/serverless.yml#L46&#34;&gt;依存している&lt;/a&gt;。
最小構成でPuppeteerを使いたかったので、今回はこれらを使わず一から作ることにした。&lt;/p&gt;

&lt;p&gt;serverless-chromeにもビルドしたものが置いてあるが、少しバージョンが古いようだったので最新版でビルドした。
基本的には&lt;a href=&#34;https://github.com/adieuadieu/serverless-chrome/tree/master/chrome&#34;&gt;書いてある&lt;/a&gt;
通りやればうまくいく。他のプロセスとのshared memoryとして/dev/shmを使っているのを、/tmpに&lt;a href=&#34;https://github.com/sambaiz/puppeteer-lambda-starter-kit/blob/master/chrome/buildChrome.sh#L20&#34;&gt;置き換える&lt;/a&gt;
ようにしないと、実行時の&lt;code&gt;page.goto()&lt;/code&gt;で&lt;code&gt;Failed Provisional Load: ***, error_code: -12&lt;/code&gt;になる。&lt;/p&gt;

&lt;p&gt;ビルドしたheadless_shellには問題になった依存は含まれていないようだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ldd headless_shell 
	linux-vdso.so.1 =&amp;gt;  (0x00007ffcb6fed000)
	libpthread.so.0 =&amp;gt; /lib64/libpthread.so.0 (0x00007f5f17dbe000)
	libdl.so.2 =&amp;gt; /lib64/libdl.so.2 (0x00007f5f17bba000)
	librt.so.1 =&amp;gt; /lib64/librt.so.1 (0x00007f5f179b1000)
	libnss3.so =&amp;gt; /usr/lib64/libnss3.so (0x00007f5f17692000)
	libnssutil3.so =&amp;gt; /usr/lib64/libnssutil3.so (0x00007f5f17466000)
	libsmime3.so =&amp;gt; /usr/lib64/libsmime3.so (0x00007f5f1723e000)
	libnspr4.so =&amp;gt; /lib64/libnspr4.so (0x00007f5f17001000)
	libexpat.so.1 =&amp;gt; /lib64/libexpat.so.1 (0x00007f5f16dd8000)
	libfontconfig.so.1 =&amp;gt; not found
	libfreetype.so.6 =&amp;gt; /usr/lib64/libfreetype.so.6 (0x00007f5f16b3b000)
	libm.so.6 =&amp;gt; /lib64/libm.so.6 (0x00007f5f16839000)
	libstdc++.so.6 =&amp;gt; /usr/lib64/libstdc++.so.6 (0x00007f5f16533000)
	libgcc_s.so.1 =&amp;gt; /lib64/libgcc_s.so.1 (0x00007f5f1631d000)
	libc.so.6 =&amp;gt; /lib64/libc.so.6 (0x00007f5f15f5b000)
	/lib64/ld-linux-x86-64.so.2 (0x000055ba0af5e000)
	libplc4.so =&amp;gt; /lib64/libplc4.so (0x00007f5f15d55000)
	libplds4.so =&amp;gt; /lib64/libplds4.so (0x00007f5f15b51000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puppetterで落としてくる普通のChromeは&lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/limits.html&#34;&gt;Lambdaの制限&lt;/a&gt;の50MBを超えていたが、
ビルドしたものはぎりぎり超えていないのでパッケージに含められるようになった。
PuppeteerのChromeは環境変数&lt;code&gt;PUPPETEER_SKIP_CHROMIUM_DOWNLOAD&lt;/code&gt;を設定することで&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer/blob/2817130fe099a7431e98c20ce1f44c6e547d4ca9/docs/api.md#puppeteer&#34;&gt;含めないようにできる&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;他のパッケージのサイズによっては50MBを超えてしまうこともあるので、
パッケージに含めず&lt;a href=&#34;https://github.com/sambaiz/puppeteer-lambda-starter-kit/blob/v0.9.0/src/util.js#L62&#34;&gt;S3からダウンロード&lt;/a&gt;できるようにもした。&lt;/p&gt;

&lt;p&gt;いずれの場合も最終的な置き先はLambdaで唯一書き込める&lt;code&gt;/tmp&lt;/code&gt;になる。
この領域は512MBまで使えるので展開してもまだ余裕がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error: EROFS: read-only file system, open &#39;node_modules/puppeteer/.local-chromium&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;chromeのlaunch時のoption&#34;&gt;ChromeのLaunch時のOption&lt;/h2&gt;

&lt;p&gt;いろいろ試した結果、最低限必要だったのはこのあたり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.launchOptionForLambda = [
    // error when launch(); No usable sandbox! Update your kernel
    &#39;--no-sandbox&#39;,
    // error when launch(); Failed to load libosmesa.so
    &#39;--disable-gpu&#39;, 
    // freeze when newPage()
    &#39;--single-process&#39;
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーは分かりづらいものが多く、ときにはエラーすら出ずに止まってしまうこともある。
デバッグの際はdumpioを有効にする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const browser = await puppeteer.launch({
    ...
    dumpio: !!util.DEBUG,
});  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;babel&#34;&gt;Babel&lt;/h2&gt;

&lt;p&gt;現在のLambdaのNodeのバージョンはv6.10.3。
&lt;a href=&#34;http://node.green/&#34;&gt;node.green&lt;/a&gt;によるとES2015は99%対応していて、ES2016もべき乗演算子(2 ** 3 = 8)以外は対応しているが、ES2017のasync/awaitは7.6からなので、8系に対応するまではbabelにかける必要がある。
ちなみにPuppeteerは6.4以降で&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer/tree/master/utils/node6-transform&#34;&gt;動く&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev babel-cli babel-preset-env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/babel/babel-preset-env&#34;&gt;babel-preset-env&lt;/a&gt;
.babelrcはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat .babelrc
{
  &amp;quot;presets&amp;quot;: [
    [&amp;quot;env&amp;quot;, {
      &amp;quot;targets&amp;quot;: {
        &amp;quot;node&amp;quot;: &amp;quot;6.10&amp;quot;
      }
    }]
  ]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Headless Chromeでファイルをダウンロードする</title>
          <link>https://www.sambaiz.net/article/131/</link>
          <pubDate>Sun, 03 Sep 2017 18:51:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/131/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://chromedevtools.github.io/devtools-protocol/&#34;&gt;Chrome DevTools Protocol&lt;/a&gt;に
Experimentalだけど&lt;a href=&#34;https://chromedevtools.github.io/devtools-protocol/tot/Page#method-setDownloadBehavior&#34;&gt;Page.setDownloadBehavior&lt;/a&gt;
というのがあったので、これを呼んでファイルをダウンロードしてみた。&lt;/p&gt;

&lt;p&gt;今回は公式のDevToolsのNode API、&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer&#34;&gt;Puppeteer&lt;/a&gt;を使うけど、
setDownloadBehaviorを送るAPIはまだ&lt;a href=&#34;https://github.com/GoogleChrome/puppeteer/blob/64124df62f4e81999fe1a0ab45c6fb9718a0e413/lib/Page.js#L29&#34;&gt;なく&lt;/a&gt;、直接clientを取ってsendするので他のライブラリでもやることは変わらないと思う。
Puppeteerのインストールの際にChromiumも入る。setDownloadBehaviorは現行Chromeの60では&lt;a href=&#34;https://bugs.chromium.org/p/chromium/issues/detail?id=696481&#34;&gt;対応していない&lt;/a&gt;ようだけど、62が入ったのでなんとかなりそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add puppeteer
$ find . -name &amp;quot;*chrome*&amp;quot;
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac/Chromium.app/Contents/Versions/62.0.3198.0/Chromium Framework.framework/Versions/A/Resources/chrome_100_percent.pak
./node_modules/puppeteer/.local-chromium/mac-497674/chrome-mac/Chromium.app/Contents/Versions/62.0.3198.0/Chromium Framework.framework/Versions/A/Resources/chrome_200_percent.pak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに、このChromeをLambda上で実行しようとすると失敗する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/132/&#34;&gt;Lambda上でPuppeteer/Headless Chromeを動かすStarter Kitを作った&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ChromeでChromeをダウンロードしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const puppeteer = require(&#39;puppeteer&#39;),
      fs        = require(&#39;fs&#39;);

const headless     = true,
      downloadPath = &#39;./Download&#39;;

(async () =&amp;gt; {
  const browser = await puppeteer.launch({headless: headless});
  
  const page = await browser.newPage();
  await page._client.send(
    &#39;Page.setDownloadBehavior&#39;,
    {behavior : &#39;allow&#39;, downloadPath: downloadPath}
  );

  await page.goto(&#39;https://www.google.co.jp/chrome/browser/desktop/index.html&#39;, {waitUntil: &#39;networkidle&#39;});
  await page.click(&#39;a.download-button&#39;);  /* Chromeをダウンロード         */
  await page.click(&#39;button#eula-accept&#39;); /* 利用規約に同意してインストール */

  await waitDownloadComplete(downloadPath)
        .catch((err) =&amp;gt; console.error(err));
 
  console.log(&#39;finished&#39;);
  browser.close();  
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ファイルがダウンロードできたかどうかは.crdownloadのありなしで判定している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const waitDownloadComplete = async (path, waitTimeSpanMs = 1000, timeoutMs = 60 * 1000) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {

    const wait = (waitTimeSpanMs, totalWaitTimeMs) =&amp;gt; setTimeout(
      () =&amp;gt; isDownloadComplete(path).then(
        (completed) =&amp;gt; {
          if (completed) { 
            resolve();
          } else {

            const nextTotalTime = totalWaitTimeMs + waitTimeSpanMs;
            if (nextTotalTime &amp;gt;= timeoutMs) {
              reject(&#39;timeout&#39;);
            }

            const nextSpan = Math.min(
              waitTimeSpanMs,
              timeoutMs - nextTotalTime
            );
            wait(nextSpan, nextTotalTime);
          }           
        }
      ).catch(
        (err) =&amp;gt; { reject(err); }
      ),
      waitTimeSpanMs
    );
    
    wait(waitTimeSpanMs, 0);
  }); 
}

const isDownloadComplete = async (path) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    fs.readdir(path, (err, files) =&amp;gt; {
      if (err) {
        reject(err);
      } else {
        if (files.length === 0) {
          resolve(false);
          return;
        }
        for(let file of files){

          // .crdownloadがあればダウンロード中のものがある
          if (/.*\.crdownload$/.test(file)) { 
            resolve(false);
            return;
          }
        }
        resolve(true);
      }
    });
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Headlessだと何もでてこないのでうまくいったか良くわからないけど、
指定したパスを見にいったらちゃんと保存されていた。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;機能的には近い立ち位置の&lt;a href=&#34;http://www.nightmarejs.org/&#34;&gt;NightmareJS&lt;/a&gt;の方も、
v1の&lt;a href=&#34;http://phantomjs.org/&#34;&gt;PhantomJS&lt;/a&gt;、現行v2の&lt;a href=&#34;https://electron.atom.io/&#34;&gt;Electron&lt;/a&gt;を経て
v3ではHeadless Chromeに&lt;a href=&#34;https://github.com/segmentio/nightmare/issues/1092&#34;&gt;なるかもしれない&lt;/a&gt;。
速いし、ウィンドウがないので&lt;a href=&#34;https://en.wikipedia.org/wiki/Xvfb&#34;&gt;xvfb(X virtual framebuffer)&lt;/a&gt;も&lt;a href=&#34;https://developers.google.com/web/updates/2017/04/headless-chrome&#34;&gt;必要ない&lt;/a&gt;し良さそうなんだけど、
現在のChrome DevTools ProtocolではNightmareの既存APIをサポートできなかったり、
Puppeteerとの住み分けはどうするのって話になっているみたいだ。&lt;/p&gt;

&lt;p&gt;現状Nightmare自体にダウンロード機能は含まれていないが、
Electronの&lt;a href=&#34;https://github.com/electron/electron/blob/master/docs-translations/jp/api/download-item.md&#34;&gt;will-download&lt;/a&gt;イベントを
ハンドリングする
&lt;a href=&#34;https://github.com/rosshinkley/nightmare-download-manager&#34;&gt;nightmare-download-manager&lt;/a&gt;や
&lt;a href=&#34;https://github.com/rosshinkley/nightmare-inline-download&#34;&gt;nightmare-inline-download&lt;/a&gt;
といったライブラリがある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsをTypeScriptで書く</title>
          <link>https://www.sambaiz.net/article/123/</link>
          <pubDate>Sat, 29 Jul 2017 19:34:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/123/</guid>
          <description>

&lt;p&gt;公式の&lt;a href=&#34;https://github.com/Microsoft/TypeScript-Node-Starter&#34;&gt;TypeScript-Node-Starter&lt;/a&gt;から始めてもいいけど、依存が少し余分なので一から作ることにした。&lt;/p&gt;

&lt;p&gt;コードは&lt;a href=&#34;https://github.com/sambaiz/typescript-nodejs-sample&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev typescript tslint tslint-microsoft-contrib jest ts-jest @types/jest
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;package-json&#34;&gt;package.json&lt;/h2&gt;

&lt;p&gt;scriptsとテストフレームワーク&lt;a href=&#34;https://facebook.github.io/jest/&#34;&gt;Jest&lt;/a&gt;の設定を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;devDependencies&amp;quot;: {
    ...
    &amp;quot;typescript&amp;quot;: &amp;quot;^2.4.2&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;npm run build &amp;amp;&amp;amp; node dist/app.js&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;npm run lint &amp;amp;&amp;amp; tsc&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;jest --forceExit&amp;quot;,
    &amp;quot;lint&amp;quot;: &amp;quot;tslint -c tslint.json -p tsconfig.json --type-check&amp;quot;
  },
  &amp;quot;jest&amp;quot;: {
    &amp;quot;transform&amp;quot;: {
      &amp;quot;^.+\\.ts$&amp;quot;: &amp;quot;./node_modules/ts-jest/preprocessor.js&amp;quot;
    },
    &amp;quot;testRegex&amp;quot;: &amp;quot;/test/.*\\.test\\.(ts|js)$&amp;quot;,
    &amp;quot;moduleFileExtensions&amp;quot;: [
      &amp;quot;ts&amp;quot;,
      &amp;quot;js&amp;quot;
    ],
    &amp;quot;testEnvironment&amp;quot;: &amp;quot;node&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsconfig-json-https-www-typescriptlang-org-docs-handbook-tsconfig-json-html&#34;&gt;&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&#34;&gt;tsconfig.json&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;公式のそのまま。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;compilerOptions&amp;quot;: {
        &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
        &amp;quot;target&amp;quot;: &amp;quot;es6&amp;quot;,
        &amp;quot;noImplicitAny&amp;quot;: true,
        &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
        &amp;quot;sourceMap&amp;quot;: true,
        &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;,
        &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
        &amp;quot;paths&amp;quot;: {
            &amp;quot;*&amp;quot;: [
                &amp;quot;node_modules/*&amp;quot;,
                &amp;quot;src/types/*&amp;quot;
            ]
        }
    },
    &amp;quot;include&amp;quot;: [
        &amp;quot;src/**/*&amp;quot;
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tslint-json-https-palantir-github-io-tslint-usage-tslint-json&#34;&gt;&lt;a href=&#34;https://palantir.github.io/tslint/usage/tslint-json/&#34;&gt;tslint.json&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;MSでも使われているらしいルールを使うことにする。
結構厳しくて&lt;code&gt;console.log&lt;/code&gt;なんかもエラーになるので必要に応じてruleを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;extends&amp;quot;: &amp;quot;tslint-microsoft-contrib&amp;quot;,
    &amp;quot;rules&amp;quot;: {
        &amp;quot;no-console&amp;quot;: [&amp;quot;&amp;quot;],
        &amp;quot;no-relative-imports&amp;quot;: false,
        &amp;quot;no-http-string&amp;quot;: false,
        &amp;quot;no-backbone-get-set-outside-model&amp;quot;: false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使うパッケージをインストール&#34;&gt;使うパッケージをインストール&lt;/h2&gt;

&lt;p&gt;本体と型。&lt;/p&gt;

&lt;p&gt;以前は型ファイルを持ってくるのにtsdとかtypingsが使われていたけど
今は&lt;a href=&#34;https://github.com/DefinitelyTyped/DefinitelyTyped&#34;&gt;DefinelyTyped&lt;/a&gt;の内容が
npmの@types/~に&lt;a href=&#34;https://github.com/Microsoft/types-publisher&#34;&gt;上がる&lt;/a&gt;ようになった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add express
$ yarn add --dev @types/express
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コードを書く&#34;&gt;コードを書く&lt;/h2&gt;

&lt;p&gt;VSCodeだったらtslintプラグインがあるので入れる。tsとtslintをglobal installする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import * as express from &#39;express&#39;;

/**
 * GET /echo
 * Return a string same as &amp;quot;say&amp;quot; query param.
 */
export function echoApi(req: express.Request, res: express.Response): void {

    const query: { say: string } = &amp;lt;{ say: string }&amp;gt; req.query;
    if (query.say === undefined) {
        res.send(echo(query.say));
    } else {
        res.status(400).send(&#39;&amp;quot;say&amp;quot; query param is required&#39;);
    }
}

/**
 * return a string same as input
 * @param say input (= output)
 */
export function echo(say: string): string {
    return say;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;テストを書く&#34;&gt;テストを書く&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/visionmedia/superagent&#34;&gt;superagent&lt;/a&gt;を使って
HTTPサーバーのテストを行う&lt;a href=&#34;https://github.com/visionmedia/supertest&#34;&gt;supertest&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yarn add --dev supertest @types/supertest
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;import * as supertest from &#39;supertest&#39;;
import { app } from &#39;../src/app&#39;;
import { echo } from &#39;../src/echo&#39;;

let request: supertest.SuperTest&amp;lt;supertest.Test&amp;gt;;
beforeAll(() =&amp;gt; {
  request = supertest(app);
});

/**
 * integration test
 */
describe(&#39;GET /echo&#39;, () =&amp;gt; {
  it(&#39;should return a string same as &amp;quot;say&amp;quot; query param&#39;, (): {} =&amp;gt; {
    const say: string = &#39;Aa 1あ&#39;;

    return request
    .get(&#39;/echo&#39;)
    .query({ say: say })
    .expect(200, say);
  });

  it(&#39;is bad request that &amp;quot;say&amp;quot; query param is not given&#39;, (): {} =&amp;gt; {
    return request
    .get(&#39;/echo&#39;)
    .expect(400);
  });
});

/**
 * unit test
 */
describe(&#39;echo&#39;, () =&amp;gt; {
  it(&#39;should return a string same as input&#39;, () =&amp;gt; {
    const say: string = &#39;Aa 1あ&#39;;
    expect(echo(say)).toBe(say);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;requestしたのをreturnするのを忘れるとテストが無条件で通ってしまうので注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm test
...
 PASS  test/echo.test.ts
  GET /echo
    ✓ should return a string same as &amp;quot;say&amp;quot; query param (34ms)
    ✓ is bad request that &amp;quot;say&amp;quot; query param is not given (4ms)
  echo
    ✓ should return a string same as input (1ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.601s, estimated 2s
Ran all test suites.
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのStream API</title>
          <link>https://www.sambaiz.net/article/96/</link>
          <pubDate>Sat, 22 Apr 2017 19:06:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/96/</guid>
          <description>

&lt;h2 id=&#34;stream-apiとは-https-nodejs-org-docs-v7-9-0-api-stream-html&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html&#34;&gt;Stream APIとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NodeでStreamデータを扱うためのもの。
例えばサイズが大きいファイルの入出力をStreamとして扱うことでバッファを最小限にできる。&lt;/p&gt;

&lt;p&gt;Streamは&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/events.html&#34;&gt;EventEmitter&lt;/a&gt;で、
Readable streamやWritable stream、ReadableとWritableを合わせたDuplex streamと
Readしたものを加工してWriteするTransform streamの種類があり、
それぞれ特定の関数が&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_api_for_stream_implementers&#34;&gt;実装&lt;/a&gt;されている必要がある。&lt;/p&gt;

&lt;h2 id=&#34;readable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-streams&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_streams&#34;&gt;Readable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamには&lt;code&gt;flowing&lt;/code&gt;と&lt;code&gt;paused&lt;/code&gt;の
&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_two_modes&#34;&gt;二つのモード&lt;/a&gt;がある。
最初は&lt;code&gt;paused&lt;/code&gt;モードで、readableになってからread()することで読むことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;readable&#39;, () =&amp;gt; {
  let chunk;
  while (null !== (chunk = readable.read(10))) {
    console.log(`${i++}: ${chunk}`);
  }
});
dable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat sample.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

$ node main.js
0: abcdefghij
1: klmnopqrst
2: uvwxyz
123
3: 4567890
あい
4: うえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dataのイベントハンドラーを追加するか、後で書くpipeを使うと&lt;code&gt;flowing&lt;/code&gt;モードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
var i = 0;
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;end&#39;, () =&amp;gt; {
  console.log(&#39;end&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0: abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーハンドリングはこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
readable.on(&#39;data&#39;, (chunk) =&amp;gt; {
  console.log(`${i++}: ${chunk}`);
});
readable.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js
{ Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native) errno: -2, code: &#39;ENOENT&#39;, syscall: &#39;open&#39;, path: &#39;error.txt&#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-readable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_readable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_read&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Readable = require(&#39;stream&#39;).Readable;

class Random extends Readable {
  constructor(opt) {
    super(opt); 
  }
  
  _read() {
    
    // error handling
    // if(err){ 
    //   this.emit(&#39;error&#39;, err)
    //   return
    // }
    
    this.push(Math.random()+&#39;&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;writable-stream-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-class-stream-writable&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_class_stream_writable&#34;&gt;Writable stream&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;output.txtに出力するWritable stream。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let writable = fs.createWriteStream(&#39;output.txt&#39;)

writable.write(&#39;hoge\n&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入力の流量が多く、Writable streamのバッファが&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_constructor_new_stream_writable_options&#34;&gt;highWaterMark&lt;/a&gt;を超えてしまうと、write()はfalseを返す。そのまま書き込み続けるとメモリを食いつぶしてしまうので、
全てのバッファが捌けて&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_event_drain&#34;&gt;drain&lt;/a&gt;イベントが発行されるまで書き込みを止めてback-pressureとする必要がある。
ただし、pipeを使う場合このあたりはやってくれるので、あまり気にすることはない。&lt;/p&gt;

&lt;h3 id=&#34;実装-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-implementing-a-writable-stream&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_implementing_a_writable_stream&#34;&gt;実装&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;実装する関数は&lt;code&gt;_write&lt;/code&gt;と、バッファされているchunkをまとめて扱うなら&lt;code&gt;_writev&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Writable = require(&#39;stream&#39;).Writable;

class DummyWritable extends Writable {
  constructor(opt) {
    super(opt);
  }

  _write(chunk, encoding, callback) {
    const chunkStr = chunk.toString()
    if (chunkStr == &#39;this is error&#39;) {
      callback(new Error(&#39;chunk is invalid&#39;));
    } else {
      console.log(chunkStr);
      callback();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipe-https-nodejs-org-docs-v7-9-0-api-stream-html-stream-readable-pipe-destination-options&#34;&gt;&lt;a href=&#34;https://nodejs.org/docs/v7.9.0/api/stream.html#stream_readable_pipe_destination_options&#34;&gt;pipe&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Readable streamをWritable streamとつなげる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;sample.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
readable.pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ cat output.txt
abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意すべきなのは、pipeしたものをまとめてエラーハンドリングすることはできないこと。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
let piped = readable.pipe(writable);

piped.on(&#39;error&#39;, (error) =&amp;gt; {
  console.log(error);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;events.js:160
      throw er; // Unhandled &#39;error&#39; event
      ^

Error: ENOENT: no such file or directory, open &#39;error.txt&#39;
    at Error (native)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面倒だけど、毎度エラーハンドリングする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
let readable = fs.createReadStream(&#39;error.txt&#39;);
let writable = fs.createWriteStream(&#39;output.txt&#39;);
const errorHandling = (err) =&amp;gt; { console.log(err) }
let piped = readable.on(&#39;error&#39;, errorHandling).pipe(writable);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeを組み合わせると、こんな風にcsvをfetchして加工し、文字コードを変えて出力するといったこともStreamでできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fetch = require(&#39;node-fetch&#39;);
const Iconv = require(&#39;iconv&#39;).Iconv;
const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
const csv = require(&#39;csv&#39;);
const fs = require(&#39;fs&#39;);

const errorHandling = (err) =&amp;gt; { console.log(err); };

const outputFile = fs.createWriteStream(&#39;output.csv&#39;);

fetch(&#39;http://example.com/test.csv&#39;).then((res) =&amp;gt; {

  res.body
  .pipe(csv.parse({columns : true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.transform(function(record){
    if(record[&#39;hoge&#39;] &amp;lt; 100000){
      return null;
    }
    return record;
  }))
  .on(&#39;error&#39;, errorHandling)
  .pipe(csv.stringify({header: true}))
  .on(&#39;error&#39;, errorHandling)
  .pipe(iconv)
  .on(&#39;error&#39;, errorHandling)
  .pipe(outputFile)
  .on(&#39;error&#39;, errorHandling);

}).then(() =&amp;gt; console.log(&amp;quot;done&amp;quot;)).catch((err) =&amp;gt; console.log(err));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeではないけど、readlineのcreateInterfaceに入力と出力のStreamを渡すと、
行ごとに処理することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);

let readable = fs.createReadStream(&#39;sample.txt&#39;);
const rl = readline.createInterface({
  input: readable,
  output: process.stdout
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;abcdefghijklmnopqrstuvwxyz
1234567890
あいうえお
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rxjsで扱う&#34;&gt;RxJSで扱う&lt;/h2&gt;

&lt;p&gt;StreamはEventEmitterなのでRxJSのfromEvent()でObservableとして扱うこともできる。ただし&lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;v5&lt;/a&gt;にはpipeがない(v4には&lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS/blob/8fa95ac884181fb6cbff8ce7c1d669ffb190f5e4/src/core/linq/observable/pipe.js#L6&#34;&gt;ある&lt;/a&gt;)ので、pipeする場合は自分でSubscribeしてwriteする必要がありそう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sambaiz.net/article/85/&#34;&gt;RxJSでRxをはじめる - sambaiz.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const fs = require(&#39;fs&#39;);
const Rx = require(&#39;rxjs/Rx&#39;);
const writable = fs.createWriteStream(&#39;output.txt&#39;)

Rx.Observable.fromEvent(process.stdin, &#39;data&#39;)
.map((v) =&amp;gt; `- ${v}`)
.subscribe((v) =&amp;gt; write(v));

function write(v){
  // TODO: back-pressure
  writable.write(v);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ node main.js 
aiueo
kakikukeko
^C

$ cat output.txt 
- aiueo
- kakikukeko
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Nightmareでブラウザでの操作を自動化する</title>
          <link>https://www.sambaiz.net/article/90/</link>
          <pubDate>Wed, 29 Mar 2017 23:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/90/</guid>
          <description>&lt;p&gt;最近、&lt;a href=&#34;http://postwash.net/&#34;&gt;POSTWASH&lt;/a&gt;という洗濯代行サービスを使っている。
専用のカバンに詰めて集荷にきた人に渡すと、きれいに畳まれた洗濯ものが届く便利なサービスだ。
注文時にはWebのフォームから集荷、配達時間や支払い方法などを選ぶ必要があるんだけど、毎週のことなのでこれを自動化してみる。&lt;/p&gt;

&lt;p&gt;ブラウザの操作を自動化するのに&lt;a href=&#34;https://github.com/segmentio/nightmare&#34;&gt;Nightmare&lt;/a&gt;を使う。
&lt;a href=&#34;https://electron.atom.io/&#34;&gt;Electron&lt;/a&gt;を使っていて、&lt;a href=&#34;http://phantomjs.org/&#34;&gt;PahntomJS&lt;/a&gt;より2倍くらい速く、簡潔に書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install nightmare
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Nightmare()&lt;/code&gt;の引数に&lt;code&gt;show: true&lt;/code&gt;を渡すとウィンドウが開いて実行し始める。
これで確認画面までいくのであとは注文ボタンを押すだけ。
ウィンドウが閉じないように最後に&lt;code&gt;nightmare.end()&lt;/code&gt;を呼んでいない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const co = require(&#39;co&#39;);
const moment = require(&#39;moment&#39;)
const jst = +9
const Nightmare = require(&#39;nightmare&#39;);		
const nightmare = Nightmare({ 
  show: true,
  waitTimeout: 3000,
  gotoTimeout: 3000
});
const loginID = process.env.LOGIN_ID;
const loginPassword = process.env.LOGIN_PASSWORD;

moment.locale(&#39;ja&#39;);
const now = moment().utcOffset(jst)
const dayAfterTomorrow = now.add(2, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;);
const nextWeek = now.add(7, &#39;days&#39;).format(&amp;quot;YYYY年M月D日(ddd)&amp;quot;)
console.log(`${dayAfterTomorrow}~${nextWeek}`);

// IDとパスワードを入れてログイン
const login = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/accounts/&#39;)
  .type(&#39;#loginid&#39;, loginID)
  .insert(&#39;#loginpw&#39;, loginPassword) // .insert() is faster than .type() but does not trigger the keyboard events.
  .click(&#39;#submit&#39;)
  .wait(&#39;#yokoso&#39;)
  .evaluate(() =&amp;gt; document.querySelector(&#39;#yokoso h5&#39;).textContent);

// 注文フォームを埋めていく
const order = () =&amp;gt; nightmare
  .goto(&#39;https://sv359.xserver.jp/~postwash/postwash.net/mypage/order.html&#39;)
  .wait(&#39;#item\\[4\\]&#39;)
  .check(&#39;#item\\[4\\]&#39;)
  .insert(&#39;#itemnum\\[4\\]&#39;, &#39;1&#39;)
  .select(&#39;#pickup_date_request&#39;, dayAfterTomorrow)
  .select(&#39;#pickup_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .wait(500) // #delivery_date_request が切り替わってしまうので少し待つ
  .select(&#39;#delivery_date_request&#39;, nextWeek)
  .select(&#39;#delivery_time_request&#39;, &#39;午前中（8時～12時）&#39;)
  .select(&#39;#payment&#39;, &#39;代金引換&#39;)
  .check(&#39;#agreement&#39;)
  .click(&#39;#submit&#39;)

co(function *(){
    yield login().then(
        (result) =&amp;gt; console.log(result), // ようこそ
        (err) =&amp;gt; console.log(err)
    );
    yield order();
    // yield nightmare.end();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでの文字コードの変換</title>
          <link>https://www.sambaiz.net/article/89/</link>
          <pubDate>Tue, 28 Mar 2017 21:36:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/89/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/bnoordhuis/node-iconv&#34;&gt;node-iconv&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install iconv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SHIFT_JISからUTF-8への変換はこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = new Buffer([
    0x8b, 0x8d, 
    0x8e, 0x4d, 
    0x26,
    0x82, 0xb2,
    0x94, 0xd1
]);

const iconv = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
console.log(`before: ${before.toString(&#39;hex&#39;)} ${before.toString()}`)
const after = iconv.convert(before);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;before: 8b8d8e4d2682b294d1 ���M&amp;amp;����
after:  e7899be79abf26e38194e9a3af 牛皿&amp;amp;ご飯
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字コードによっては変換後に表せないことがある。
例えば、UTF-8からSHIFT_JISへの変換でサロゲートペア🍚を渡すと変換できず、エラーになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw errnoException(&#39;EILSEQ&#39;, &#39;Illegal character sequence.&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;//IGNORE&lt;/code&gt;を&lt;a href=&#34;https://www.npmjs.com/package/iconv#dealing-with-untranslatable-characters&#34;&gt;付ける&lt;/a&gt;ことで
そのような文字があった場合でもエラーにしないようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const Iconv  = require(&#39;iconv&#39;).Iconv;

const before = &amp;quot;牛皿&amp;amp;🍚&amp;quot;;

const iconv = new Iconv(&#39;UTF-8&#39;, &#39;SHIFT_JIS//IGNORE&#39;);
console.log(`before: ${new Buffer(before).toString(&#39;hex&#39;)} ${before.toString()}`)
const conv = iconv.convert(before);
const iconv2 = new Iconv(&#39;SHIFT_JIS&#39;, &#39;UTF-8&#39;);
const after = iconv2.convert(conv);
console.log(`after:  ${after.toString(&#39;hex&#39;)} ${after.toString()}`);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変換できないものは無視される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before: e7899be79abf26f09f8d9a 牛皿&amp;amp;🍚
after:  e7899be79abf26 牛皿&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambdaでは&#34;&gt;Lambdaでは&lt;/h2&gt;

&lt;p&gt;Lambdaではインストールされているiconvコマンドを使うことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new Promise((resolve, reject) =&amp;gt; {
    let filePath = &amp;quot;/tmp/shiftjis&amp;quot;;
    fs.writeFileSync(filePath, shiftjis);
    var exec = require(&#39;child_process&#39;).exec;
    var cmd = `iconv -c -f sjis -t utf-8 ${filePath}`;
    var child = exec(cmd, (err, stdout, stderr) =&amp;gt; {
      if (err) reject(err);
      else resolve(stdout);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bokukoko.info/entry/2015/08/30/AWS_Lambda%E5%86%85%E3%81%A7%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%A4%89%E6%8F%9B%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95&#34;&gt;AWS Lambda内で文字コードを変換する方法 - ボクココ&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsでDateを任意のフォーマットの文字列にする</title>
          <link>https://www.sambaiz.net/article/79/</link>
          <pubDate>Mon, 06 Mar 2017 20:18:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/79/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://momentjs.com/&#34;&gt;Moment.js&lt;/a&gt;を使う。
相対時間(&lt;code&gt;5 years ago&lt;/code&gt;)を出したり、日付の計算(&lt;code&gt;add(3, &#39;days&#39;)&lt;/code&gt;)もできる便利なライブラリ。
ブラウザでも使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install moment
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const moment = require(&#39;moment&#39;)
const jst = +9
let now = moment().utcOffset(jst).format(&amp;quot;YYYY-MM-DD HH:mm:ss.SSSZ&amp;quot;);
console.log(now);
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Node.jsのバージョン管理</title>
          <link>https://www.sambaiz.net/article/8/</link>
          <pubDate>Fri, 15 Jul 2016 19:20:00 &#43;0900</pubDate>
          <author></author>
          <guid>https://www.sambaiz.net/article/8/</guid>
          <description>

&lt;h2 id=&#34;nvm-https-github-com-creationix-nvm&#34;&gt;&lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;大体これを使っておけばよさそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash
$ nvm install node
$ node -v
v7.7.2

$ nvm install 6
$ node -v
v6.10.0

$ nvm ls
        v6.10.0
-&amp;gt;       v7.7.2
default -&amp;gt; node (-&amp;gt; v7.7.2)
node -&amp;gt; stable (-&amp;gt; v7.7.2) (default)
stable -&amp;gt; 7.7 (-&amp;gt; v7.7.2) (default)
iojs -&amp;gt; N/A (default)
lts/* -&amp;gt; lts/boron (-&amp;gt; v6.10.0)
lts/argon -&amp;gt; v4.8.0 (-&amp;gt; N/A)
lts/boron -&amp;gt; v6.10.0

$ nvm use node
Now using node v7.7.2 (npm v4.1.2)

$ nvm use 6
Now using node v6.10.0 (npm v3.10.10)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;n-https-github-com-tj-n&#34;&gt;&lt;a href=&#34;https://github.com/tj/n&#34;&gt;n&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;すでにnodeが入っているならこっちを使うこともできる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n latest&lt;/code&gt;, &lt;code&gt;n stable&lt;/code&gt;, &lt;code&gt;n lts&lt;/code&gt;でバージョンが切り替わる。
バージョンを指定する場合、&lt;code&gt;n &amp;lt;version&amp;gt;&lt;/code&gt;でインストールし、&lt;code&gt;n&lt;/code&gt;でインストールされているバージョンの一覧から選択できる。
バージョンの削除は&lt;code&gt;n - &amp;lt;version&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g n
$ n stable
$ node -v
v6.2.2
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
