<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/react/</link>
    <description>Recent content in React on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Fri, 23 Feb 2018 02:01:00 +0900</lastBuildDate>
    
	<atom:link href="https://www.sambaiz.net/tags/react/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ブラウザのwindow間の値渡し</title>
      <link>https://www.sambaiz.net/article/156/</link>
      <pubDate>Fri, 23 Feb 2018 02:01:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/156/</guid>
      <description>直接Windowを参照する オリジン(プロトコル+ポート+ホスト)が同じ場合は、親はopen()した返り値で、子はwindow.openerで相手のwindowが取れて、直接参照したりDOMを操作したりすることもできる。
同じ/異なるオリジンのiframeの中からできること - sambaiz-net
$ cat index.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Open window&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;quot;btn2&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; let win2; const button = document.getElementById(&amp;quot;btn&amp;quot;); button.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { window.foo = &amp;quot;bar from window1&amp;quot;; win2 = window.open(&amp;quot;index2.html&amp;quot;); }, false); const button2 = document.getElementById(&amp;quot;btn2&amp;quot;); button2.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { if (win2) { win2.close(); } }, false); &amp;lt;/script&amp;gt;  $ cat index2.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; console.log(window.aaa); const parentWindow = window.opener; const view = document.</description>
    </item>
    
    <item>
      <title>webpack環境でredux&amp;react-routerのページをサーバーサイドレンダリングする</title>
      <link>https://www.sambaiz.net/article/5/</link>
      <pubDate>Sun, 10 Jul 2016 03:08:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/5/</guid>
      <description>このページをGoogleのSearch Consoleからクローラーがちゃんと見ているか確認してみたら、 なぜか真っ白のページが表示されていた・・・。とりあえずサーバーサイドレンダリングしてみることにした。 コードはgithubに上げてある。
サーバーサイドとはいえ、css-loaderでcss moduleを使っているのでwebpackを使う必要があった。 まず、そのままのwebpackの設定で作ったものをserver.jsから呼ぶとエラーが出た。
***/sambaiz-net/web/public/bundle.js:20933 module.exports = self.fetch.bind(self); ReferenceError: self is not defined  そこで、targetをnodeにしたサーバーサイド用にwebpackの設定を作成し、実行してみたところ
module.exports = { entry: &#39;./js/server.js&#39;, target: &#39;node&#39;, output: { path: path.join(__dirname, &#39;dist&#39;), filename: &#39;server.js&#39;, publicPath: &#39;/&#39; },  今度はこんなエラーが出たので
ERROR in ./~/iconv-lite/encodings/tables/gb18030-ranges.json Module parse failed: ***/sambaiz-net/web/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json Unexpected token (1:9) You may need an appropriate loader to handle this file type.  loadersに下の設定を追加した。
{ test: /\.json$/, loader: &amp;quot;json-loader&amp;quot;}  webpackには成功したが、serverを起動すると今度は以下のようなエラーが出た。
return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase()); ReferenceError: window is not defined  style-loaderのコードだったので、 まず、フロント側のwebpackで extract-text-webpack-pluginを使ってcssを別に出力することにした。</description>
    </item>
    
    <item>
      <title>Reactで作ったページにTwitterCardsとOGPのメタデータを埋める</title>
      <link>https://www.sambaiz.net/article/2/</link>
      <pubDate>Sat, 02 Jul 2016 13:23:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/2/</guid>
      <description>せっかくページを作ったので、SNSにシェアするときに見栄えをよくしようと思った。
Twitter CardsやOGPのmetaタグを埋めるとTwitterやFacebookにURLを貼ったときに上のように表示されるようになる(上はFacebookの例)。そこで、react-helmetでこんな感じで動的に埋め込んだんだけど読んでくれない。
&amp;lt;Helmet title={&#39;sambaiz.net&#39;} meta={[ {&amp;quot;name&amp;quot;: &amp;quot;twitter:card&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;summary&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:site&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;@sambaiz&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:description&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;僕のホームページ&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:type&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;blog&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:image&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;http://d2wgaf7ubdj1mv.cloudfront.net/my.jpg&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:url&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;https://www.sambaiz.net&amp;quot;} ]} /&amp;gt;  GoogleのクローラーのようにJavascriptを解釈してくれる と思ってた。残念。
しょうがないのでここだけサーバーサイドレンダリングすることにした。
&#39;use strict&#39; import express from &#39;express&#39; import path from &#39;path&#39; import compression from &#39;compression&#39; require(&#39;isomorphic-fetch&#39;); var app = express() app.use(compression()) // serve our static stuff app.use(express.static(path.join(__dirname, &#39;.</description>
    </item>
    
  </channel>
</rss>