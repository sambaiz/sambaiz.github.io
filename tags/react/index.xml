<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on sambaiz-net</title>
    <link>https://www.sambaiz.net/tags/react/</link>
    <description>Recent content in React on sambaiz-net</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>sambaiz-net</copyright>
    <lastBuildDate>Thu, 20 Jun 2019 19:23:00 +0900</lastBuildDate>
    
	<atom:link href="https://www.sambaiz.net/tags/react/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ReactのFunction ComponentとHooks</title>
      <link>https://www.sambaiz.net/article/225/</link>
      <pubDate>Thu, 20 Jun 2019 19:23:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/225/</guid>
      <description>久々にcreate-react-appを実行したら コンポーネントがReact.ComponentのクラスではなくFunction Componentになっていた。
Function Component Function Componentは関数で書かれるStateを持たないコンポーネントで、 簡潔に書けるだけではなくReact.createElement()と比べて45%くらい速いらしい。
45% Faster React Functional Components, Now – Missive App – Medium
const App: React.FC = () =&amp;gt; { return ( &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt; {FunctionalComponent({title: &amp;quot;HELLO FC&amp;quot;})} &amp;lt;/div&amp;gt; ); } interface Props { title: string } const FunctionalComponent: React.FC&amp;lt;Props&amp;gt; = (props) =&amp;gt; { return ( &amp;lt;div&amp;gt; {props.title} &amp;lt;/div&amp;gt; ); }  v16.6でリリースされた React.memo()を使うと PureComponent のようにpropsが変わらない場合は再レンダリングさせなくすることができる。
const App: React.FC = () =&amp;gt; { return ( &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt; &amp;lt;FunctionalComponent title=&amp;quot;HELLO FC&amp;quot; /&amp;gt; &amp;lt;/div&amp;gt; ); } interface Props { title: string } const FunctionalComponent = React.</description>
    </item>
    
    <item>
      <title>React, Material-UI, Unstated, RechartsでTODOを作った</title>
      <link>https://www.sambaiz.net/article/215/</link>
      <pubDate>Thu, 28 Mar 2019 17:52:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/215/</guid>
      <description>コード
create-react-app create-react-appでアプリを作成した。 TypeScriptを有効にしている。
$ npx create-react-app react-todo-unstated --typescript $ cd react-todo-unstated $ tree src/ src/ ├── App.css ├── App.test.tsx ├── App.tsx ├── index.css ├── index.tsx ├── logo.svg ├── react-app-env.d.ts └── serviceWorker.ts $ npm start  Material-UI UIはMaterial-UIでUIで作った。
$ npm install --save @material-ui/core @material-ui/icons  public/index.htmlにRobotoフォントを入れた。
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://fonts.googleapis.com/css?family=Roboto:300,400,500&amp;quot;&amp;gt;  Unstated UnstatedはReact v16からのContext APIを使ったStateを管理するための薄いライブラリ。
$ npm install --save unstated  Stateを持つContainerを作る。
class TodoContainer extends Container&amp;lt;TodoState&amp;gt; { state: TodoState = { newTodo: &amp;quot;&amp;quot;, todos: [], isCreating: false }; changeNewTodo(newTodo: string) { this.</description>
    </item>
    
    <item>
      <title>ブラウザのwindow間の値渡し</title>
      <link>https://www.sambaiz.net/article/156/</link>
      <pubDate>Fri, 23 Feb 2018 02:01:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/156/</guid>
      <description>直接Windowを参照する オリジン(プロトコル+ポート+ホスト)が同じ場合は、親はopen()した返り値で、子はwindow.openerで相手のwindowが取れて、直接参照したりDOMを操作したりすることもできる。
同じ/異なるオリジンのiframeの中からできること - sambaiz-net
$ cat index.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Open window&amp;lt;/button&amp;gt; &amp;lt;button id=&amp;quot;btn2&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; let win2; const button = document.getElementById(&amp;quot;btn&amp;quot;); button.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { window.foo = &amp;quot;bar from window1&amp;quot;; win2 = window.open(&amp;quot;index2.html&amp;quot;); }, false); const button2 = document.getElementById(&amp;quot;btn2&amp;quot;); button2.addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; { if (win2) { win2.close(); } }, false); &amp;lt;/script&amp;gt;  $ cat index2.html &amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;Close window&amp;lt;/button&amp;gt; &amp;lt;div id=&amp;quot;view&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; console.log(window.aaa); const parentWindow = window.opener; const view = document.</description>
    </item>
    
    <item>
      <title>webpack環境でredux&amp;react-routerのページをサーバーサイドレンダリングする</title>
      <link>https://www.sambaiz.net/article/5/</link>
      <pubDate>Sun, 10 Jul 2016 03:08:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/5/</guid>
      <description>このページをGoogleのSearch Consoleからクローラーがちゃんと見ているか確認してみたら、 なぜか真っ白のページが表示されていた・・・。とりあえずサーバーサイドレンダリングしてみることにした。 コードはgithubに上げてある。
サーバーサイドとはいえ、css-loaderでcss moduleを使っているのでwebpackを使う必要があった。 まず、そのままのwebpackの設定で作ったものをserver.jsから呼ぶとエラーが出た。
***/sambaiz-net/web/public/bundle.js:20933 module.exports = self.fetch.bind(self); ReferenceError: self is not defined  そこで、targetをnodeにしたサーバーサイド用にwebpackの設定を作成し、実行してみたところ
module.exports = { entry: &#39;./js/server.js&#39;, target: &#39;node&#39;, output: { path: path.join(__dirname, &#39;dist&#39;), filename: &#39;server.js&#39;, publicPath: &#39;/&#39; },  今度はこんなエラーが出たので
ERROR in ./~/iconv-lite/encodings/tables/gb18030-ranges.json Module parse failed: ***/sambaiz-net/web/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json Unexpected token (1:9) You may need an appropriate loader to handle this file type.  loadersに下の設定を追加した。
{ test: /\.json$/, loader: &amp;quot;json-loader&amp;quot;}  webpackには成功したが、serverを起動すると今度は以下のようなエラーが出た。
return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase()); ReferenceError: window is not defined  style-loaderのコードだったので、 まず、フロント側のwebpackで extract-text-webpack-pluginを使ってcssを別に出力することにした。</description>
    </item>
    
    <item>
      <title>Reactで作ったページにTwitterCardsとOGPのメタデータを埋める</title>
      <link>https://www.sambaiz.net/article/2/</link>
      <pubDate>Sat, 02 Jul 2016 13:23:00 +0900</pubDate>
      
      <guid>https://www.sambaiz.net/article/2/</guid>
      <description>せっかくページを作ったので、SNSにシェアするときに見栄えをよくしようと思った。
Twitter CardsやOGPのmetaタグを埋めるとTwitterやFacebookにURLを貼ったときに上のように表示されるようになる(上はFacebookの例)。そこで、react-helmetでこんな感じで動的に埋め込んだんだけど読んでくれない。
&amp;lt;Helmet title={&#39;sambaiz.net&#39;} meta={[ {&amp;quot;name&amp;quot;: &amp;quot;twitter:card&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;summary&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:site&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;@sambaiz&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;twitter:description&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;僕のホームページ&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:title&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;sambaiz.net&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:type&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;blog&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:image&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;http://d2wgaf7ubdj1mv.cloudfront.net/my.jpg&amp;quot;}, {&amp;quot;property&amp;quot;: &amp;quot;og:url&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;https://www.sambaiz.net&amp;quot;} ]} /&amp;gt;  GoogleのクローラーのようにJavascriptを解釈してくれる と思ってた。残念。
しょうがないのでここだけサーバーサイドレンダリングすることにした。
&#39;use strict&#39; import express from &#39;express&#39; import path from &#39;path&#39; import compression from &#39;compression&#39; require(&#39;isomorphic-fetch&#39;); var app = express() app.use(compression()) // serve our static stuff app.use(express.static(path.join(__dirname, &#39;.</description>
    </item>
    
  </channel>
</rss>