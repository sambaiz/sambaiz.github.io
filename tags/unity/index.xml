<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz-net</title>
    <link>http://sambaiz.net/tags/unity/index.xml</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2017</rights>
    <updated>0001-01-01 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>HoloLensで剣振ってみた</title>
          <link>http://sambaiz.net/article/119/</link>
          <pubDate>Sun, 09 Jul 2017 23:55:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/119/</guid>
          <description>&lt;p&gt;かつてCardboardでやったようにHoloLensでも剣を振ってみた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/29/&#34;&gt;剣を振るVRゲームを作った - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/119-ss.png&#34; alt=&#34;スクリーンショット&#34; /&gt;&lt;/p&gt;

&lt;p&gt;剣を振ってロボットに当てると爆発する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=_gt6ePsqrRc&#34;&gt;動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;剣の方は前回と同じくiOSアプリから傾きをBLEで送信している。今回は傘がなかったのでペットボトルにくくりつけた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/119-sword.jpg&#34; alt=&#34;ミニッツメイドソード&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HoloLensのアプリの方はUWPのネイティブプラグインを作った。
Creater&amp;rsquo;s UpdateのAPIがまだ使えなかったので一つ前のAPIを使ってビルドしている。
なお、ペアリングはアプリ内ではなくOSの設定画面から行なっている。
エラーについては原因が分からずハンドリングできていないものもあるけど、つなぎ直すと大抵どうにかなった。
つなぎ直す際はHoloLens側だけではなくiOS側の方の設定も削除する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105/&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ロボットを小さくしているのは近づいても視野角に収まるようにするため。
小さいとどこにいるか分からないので目印を出したほうが良い。
近接武器じゃなきゃ敵に近づかなくてよくなるのでましになるかも。&lt;/p&gt;

&lt;p&gt;全体的に動きが重くて素でframerateが20ぐらいしか出ていない。
CPUは80%、GPUは20%、メモリが70%ぐらい使われてるんだけど、貼りついているわけではないし
何がボトルネックになってるのかは不明。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>HoloLensのSpartial MappingでNavMeshを生成してランダムにAgentを出現・移動させる</title>
          <link>http://sambaiz.net/article/118/</link>
          <pubDate>Sun, 02 Jul 2017 23:12:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/118/</guid>
          <description>&lt;pre&gt;&lt;code&gt;Unity 5.6.2f1
HoloToolkit v1.5.7.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unity 5.6から動的にNavMeshを生成できるようになったので
HoloLensのSpartial MappingしたものをNavMeshにしてAgentを動かしてみる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/117/&#34;&gt;Unityで動的にNavMeshを生成する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spartial MappingしたものをNavMeshにするのは以下の記事の&lt;a href=&#34;https://gist.github.com/tarukosu/7bc78c189d8a7de8e94ca3fcfc8f7738#file-spatialmappingnavmesh-cs&#34;&gt;スクリプト&lt;/a&gt;を使った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tarukosu.hatenablog.com/entry/2017/04/23/183546&#34;&gt;HoloLens の空間マップで NavMesh を使ってみる - たるこすの日記&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Unity-Technologies/NavMeshComponents&#34;&gt;Unity-Technologies/NavMeshComponents&lt;/a&gt;から
&lt;code&gt;LocalNavMeshBuilder&lt;/code&gt;と&lt;code&gt;NavMeshSourceTag&lt;/code&gt;を持ってきてLocalNavMeshBuilderのObjectを置いておき、
Spartial MappingしたものにNavMeshSourceTagを付けられればExampleと同様にNavMeshにできる。
そこで、このスクリプトではSpatialMappingSourceを取得し、イベントハンドラでNavMeshSourceTagが追加されるようにしている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using HoloToolkit.Unity.SpatialMapping;
using UnityEngine;
using HoloToolkit.Unity;

public class SpatialMappingNavMesh : MonoBehaviour
{
    public GameObject SpatialMapping;

    private void Awake()
    {
        var spatialMappingSources = SpatialMapping.GetComponents&amp;lt;SpatialMappingSource&amp;gt;();
        foreach (var source in spatialMappingSources)
        {
            source.SurfaceAdded += SpatialMappingSource_SurfaceAdded;
            source.SurfaceUpdated += SpatialMappingSource_SurfaceUpdated;
        }
    }

    private void SpatialMappingSource_SurfaceAdded(object sender, DataEventArgs&amp;lt;SpatialMappingSource.SurfaceObject&amp;gt; e)
    {
        e.Data.Object.AddComponent&amp;lt;NavMeshSourceTag&amp;gt;();
    }

    private void SpatialMappingSource_SurfaceUpdated(object sender, DataEventArgs&amp;lt;SpatialMappingSource.SurfaceUpdate&amp;gt; e)
    {
        var navMeshSourceTag = e.Data.New.Object.GetComponent&amp;lt;NavMeshSourceTag&amp;gt;();
        if (navMeshSourceTag == null)
        {
            e.Data.New.Object.AddComponent&amp;lt;NavMeshSourceTag&amp;gt;();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NavMeshのランダムな場所を取得するには、適当なPointを取り、
&lt;a href=&#34;https://docs.unity3d.com/ja/540/ScriptReference/NavMesh.SamplePosition.html&#34;&gt;NavMesh.SamplePosition&lt;/a&gt;で
そこから最も近いNavMeshのPointを取る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool RandomPoint(Vector3 center, float range, out Vector3 result) {
    for (int i = 0; i &amp;lt; 30; i++) {
        Vector3 randomPoint = center + Random.insideUnitSphere * range;
        NavMeshHit hit;
        if (NavMesh.SamplePosition(randomPoint, out hit, 1.0f, NavMesh.AllAreas)) {
            result = hit.position;
            return true;
        }
    }
    result = Vector3.zero;
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;動かすAgentはこんな感じ。こけないようにFreeze Rotationしている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/118.png&#34; alt=&#34;Agentの設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このAgentを出現させて移動させる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class RandomSpawn : MonoBehaviour {

    public GameObject player;
    public GameObject agent;
    public GameObject counter;

    private List&amp;lt;GameObject&amp;gt; spawnedAgents = new List&amp;lt;GameObject&amp;gt;();
    private float interval = 0.0f;

    static int MAX_SPAWN_NUM = 10;
    static float SPAWN_RANGE = 10.0f;

	// Use this for initialization
	void Start () {
        counter.GetComponent&amp;lt;TextMesh&amp;gt;().text = spawnedAgents.Count + &amp;quot;&amp;quot;;
    }

    // Update is called once per frame
    void Update () {

        interval += Time.deltaTime;
        if(interval &amp;gt; 5.0f)
        {
            if (spawnedAgents.Count &amp;lt; MAX_SPAWN_NUM)
            {
                Spawn();
            }
            Move();
            interval = 0.0f;
        }
    }

    void Spawn()
    {
        Vector3 spawnPoint;
        if (GetRandomPosition(player.transform.position, SPAWN_RANGE, out spawnPoint))
        {
            var obj = Instantiate(agent, spawnPoint, Quaternion.identity);
            counter.GetComponent&amp;lt;TextMesh&amp;gt;().text = spawnedAgents.Count + &amp;quot;&amp;quot;;
            spawnedAgents.Add(obj);
        }
    }

    void Move()
    {
        foreach(var agent in spawnedAgents)
        {
            Vector3 next;
            if(GetRandomPosition(agent.transform.position, SPAWN_RANGE, out next)){
                agent.GetComponent&amp;lt;NavMeshAgent&amp;gt;().destination = next;
            }
        }
        
    }

    bool GetRandomPosition(Vector3 center, float range, out Vector3 result)
    {
        for (int i = 0; i &amp;lt; 30; i++)
        {
            Vector3 randomPoint = center + UnityEngine.Random.insideUnitSphere * range;
            NavMeshHit hit;
            if (NavMesh.SamplePosition(randomPoint, out hit, 1.0f, NavMesh.AllAreas))
            {
                result = hit.position;
                return true;
            }
        }
        result = Vector3.zero;
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと床や壁を認識して移動している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/118.gif&#34; alt=&#34;移動するAgent&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityで動的にNavMeshを生成する</title>
          <link>http://sambaiz.net/article/117/</link>
          <pubDate>Sat, 01 Jul 2017 23:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/117/</guid>
          <description>&lt;p&gt;Unity5.6から動的にNavMeshを生成できるようになった。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Unity-Technologies/NavMeshComponents&#34;&gt;Unity-Technologies/NavMeshComponents&lt;/a&gt;の
Exampleの2_drop_blankのsceneを開く。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/117-sample.png&#34; alt=&#34;Exampleの2_drop_blank&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分断されたCubeの床と、その上に黄色いCylindarと赤いCubeがあって、
クリックしたところに黄色いCylindarが動くんだけど、床がつながっていないのでそのままでは赤いCubeまではたどり着けない。
スペースを押すと目の前に板が出てくるのでこの上を渡って移動することができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/117-sample2.png&#34; alt=&#34;スペースを押すと板が出てくる&#34; /&gt;&lt;/p&gt;

&lt;p&gt;板の上がNavMeshとして認識されている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/117-sample3.png&#34; alt=&#34;スペースを押すと板が出てくる&#34; /&gt;&lt;/p&gt;

&lt;p&gt;床のCubeと追加される板には&lt;a href=&#34;https://github.com/Unity-Technologies/NavMeshComponents/blob/5.6.0b4/Assets/Examples/Scripts/NavMeshSourceTag.cs&#34;&gt;NavMeshSourceTag.cs&lt;/a&gt;が付いていて、staticな&lt;code&gt;m_Meshes&lt;/code&gt;と&lt;code&gt;m_Terrains&lt;/code&gt;にそれぞれ追加している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static List&amp;lt;MeshFilter&amp;gt; m_Meshes = new List&amp;lt;MeshFilter&amp;gt;();
public static List&amp;lt;Terrain&amp;gt; m_Terrains = new List&amp;lt;Terrain&amp;gt;();

void OnEnable()
{
    var m = GetComponent&amp;lt;MeshFilter&amp;gt;();
    if (m != null)
    {
        m_Meshes.Add(m);
    }

    var t = GetComponent&amp;lt;Terrain&amp;gt;();
    if (t != null)
    {
        m_Terrains.Add(t);
    }
}

void OnDisable()
{
    var m = GetComponent&amp;lt;MeshFilter&amp;gt;();
    if (m != null)
    {
        m_Meshes.Remove(m);
    }

    var t = GetComponent&amp;lt;Terrain&amp;gt;();
    if (t != null)
    {
        m_Terrains.Remove(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これらはCollectメソッドでNavMeshBuildSourceのリストを生成するのに使われる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void Collect(ref List&amp;lt;NavMeshBuildSource&amp;gt; sources)
{
    sources.Clear();

    for (var i = 0; i &amp;lt; m_Meshes.Count; ++i)
    {
        var mf = m_Meshes[i];
        if (mf == null) continue;

        var m = mf.sharedMesh;
        if (m == null) continue;

        var s = new NavMeshBuildSource();
        s.shape = NavMeshBuildSourceShape.Mesh;
        s.sourceObject = m;
        s.transform = mf.transform.localToWorldMatrix;
        s.area = 0;
        sources.Add(s);
    }

    for (var i = 0; i &amp;lt; m_Terrains.Count; ++i)
    {
       ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを&lt;a href=&#34;https://github.com/Unity-Technologies/NavMeshComponents/blob/5.6.0b4/Assets/Examples/Scripts/LocalNavMeshBuilder.cs&#34;&gt;LocalNavMeshBuilder.cs&lt;/a&gt;から呼び、&lt;a href=&#34;https://docs.unity3d.com/ScriptReference/AI.NavMeshBuilder.UpdateNavMeshData.html&#34;&gt;NavMeshBuilder.UpdateNavMeshData&lt;/a&gt;に渡してNavMeshDataを更新している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NavMeshData m_NavMesh;
AsyncOperation m_Operation;
NavMeshDataInstance m_Instance;
List&amp;lt;NavMeshBuildSource&amp;gt; m_Sources = new List&amp;lt;NavMeshBuildSource&amp;gt;();

IEnumerator Start()
{
    while (true)
    {
        UpdateNavMesh(true);
        yield return m_Operation;
    }
}

void UpdateNavMesh(bool asyncUpdate = false)
{
    NavMeshSourceTag.Collect(ref m_Sources);
    var defaultBuildSettings = NavMesh.GetSettingsByID(0);
    var bounds = QuantizedBounds();

    if (asyncUpdate)
        m_Operation = NavMeshBuilder.UpdateNavMeshDataAsync(m_NavMesh, defaultBuildSettings, m_Sources, bounds);
    else
        NavMeshBuilder.UpdateNavMeshData(m_NavMesh, defaultBuildSettings, m_Sources, bounds);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityの経路探索: NavMeshとAgentとObstacle</title>
          <link>http://sambaiz.net/article/115/</link>
          <pubDate>Thu, 29 Jun 2017 00:17:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/115/</guid>
          <description>

&lt;h2 id=&#34;navmeshと経路探索-https-docs-unity3d-com-jp-540-manual-nav-innerworkings-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/nav-InnerWorkings.html&#34;&gt;NavMeshと経路探索&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;NavMeshというのはエージェントが移動できる面についてのデータ構造で、凸ポリゴンの面と位置関係を含んでいる。
経路探索は2点間を一番近いポリゴンにマッピングし、&lt;a href=&#34;https://ja.wikipedia.org/wiki/A*&#34;&gt;A*アルゴリズム&lt;/a&gt;を用いて行われる。あとからオブジェクトが追加されるなどして道を塞いでしまってもCarvingしてNavMeshに穴をあければ別の経路で移動することができるが、このようなグローバルの経路探索に影響を及ぼす操作は計算にコストがかかるので、各エージェントローカルの衝突回避で済むならそのほうがよい。&lt;/p&gt;

&lt;h2 id=&#34;navmeshをbakeする-https-docs-unity3d-com-jp-540-manual-nav-buildingnavmesh-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/nav-BuildingNavMesh.html&#34;&gt;NavMeshをbakeする&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;こんな感じで床に適当なオブジェクトを置いてみた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-stage.png&#34; alt=&#34;stage&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-stageh.png&#34; alt=&#34;階層&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Window -&amp;gt; Navigation&lt;/code&gt;でBakeするのを選択してNavigation Staticし(StaticになってBakeの対象になる)、
Bakeボタンを押すとこんな感じでBakeされる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-bake.png&#34; alt=&#34;bake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトの上がNavMeshに含まれていないのはAgent sizeのStep Heightよりも高いため。
段差を移動するときに浮いてしまうのを避けるためにはAdvancedの&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/nav-HeightMesh.html&#34;&gt;Height Mesh&lt;/a&gt;をオンにする。
また、端が含まれていないのはこのAgentの中心が入れる位置を表しているためで、
Agent Radiusを変更すると広がったり狭まったりするのを確認できる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-agentsize.png&#34; alt=&#34;Agent size&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;navmesh-agent-https-docs-unity3d-com-jp-540-manual-nav-createnavmeshagent-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/nav-CreateNavMeshAgent.html&#34;&gt;NavMesh Agent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Radius0.5, Height2のCylindarを作成し、Nav Mesh Agentを追加する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-navmesh-agent.png&#34; alt=&#34;NavMesh Agent&#34; /&gt;&lt;/p&gt;

&lt;p&gt;で、ゴールにオブジェクトを置いてそこまで移動させてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine.AI;

public GameObject goal;

void Start () {
    var agent = GetComponent&amp;lt;NavMeshAgent&amp;gt;();
    agent.destination = goal.transform.position;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-move.gif&#34; alt=&#34;ゴールまでたどり着くNavMesh Agent&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;navmesh-obstacle&#34;&gt;NavMesh Obstacle&lt;/h2&gt;

&lt;p&gt;障害物。上で通った経路上にNavMesh Obstacleを追加したCubeを置いたところうまく避けてゴールまでたどり着いた。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-move2.gif&#34; alt=&#34;Obstacleを置いた&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ただ、完全に道をふさいでしまうと立ち往生してしまうので
Carveにチェックを入れるとCarvingされ、他の経路でゴールまで進むようになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/115-move3.gif&#34; alt=&#34;Carvingした&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/117/&#34;&gt;Unityで動的にNavMeshを生成する - sambaiz-net&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityの物理エンジン・衝突: RigidbodyとCollidarとJoint</title>
          <link>http://sambaiz.net/article/114/</link>
          <pubDate>Sun, 25 Jun 2017 23:26:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/114/</guid>
          <description>

&lt;h2 id=&#34;rigidbody-https-docs-unity3d-com-ja-current-manual-rigidbodiesoverview-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/RigidbodiesOverview.html&#34;&gt;Rigidbody&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;GameObjectを物理特性によって制御し、力の影響を受けるようにする。
&lt;code&gt;Mass(質量)&lt;/code&gt;や&lt;code&gt;Drag(空気抵抗)&lt;/code&gt;、&lt;code&gt;Use Gravity&lt;/code&gt;などのプロパティがある。&lt;/p&gt;

&lt;p&gt;移動させるのに自分でTransformは変更せず力をかけて物理演算に任せる。
&lt;code&gt;Is Kinematic&lt;/code&gt;にチェックを入れると物理エンジンによって移動しないようになるので、
Transformを直接変更する場合は有効にする。
ただし、スクリプトで動的にIs Kinematicを切り替えるのはパフォーマンスが良くない。&lt;/p&gt;

&lt;h2 id=&#34;collidar-https-docs-unity3d-com-ja-current-manual-collidersoverview-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/CollidersOverview.html&#34;&gt;Collidar&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;RigidBodyの物理特性の境界を定義する。衝突させるには両方にCollidarが設定されている必要がある。
RigidBodyなしのCollidarを静的Collidarといって、無効にしたり移動しないことを前提に最適化される。
移動したりするものについてはRigidBodyを付けて、必要ならIs Kinematicを有効にする。&lt;/p&gt;

&lt;p&gt;衝突時には&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnCollisionEnter.html&#34;&gt;OnCollisionEnter()&lt;/a&gt;
が呼ばれる。ほかに離れたときの&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnCollisionExit.html&#34;&gt;OnCollisionExit()&lt;/a&gt;、
触れている間、毎フレーム呼ばれる&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnCollisionStay.html&#34;&gt;OnCollisionStay()&lt;/a&gt;がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void OnCollisionEnter(Collision collision)
{
    foreach (ContactPoint contact in collision.contacts)
    {
        if (contact.otherCollider.tag == &amp;quot;Player&amp;quot;)
        {
            Debug.Log(collision.relativeVelocity.magnitude);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Is Trigger&lt;/code&gt;にチェックを入れると物理エンジンには無視されてすり抜け、侵入に対してトリガーイベントが呼ばれる。
OnCollistionと同様に
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnTriggerEnter.html&#34;&gt;OnTriggerEnter()&lt;/a&gt;、
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnTriggerExit.html&#34;&gt;OnTriggerExit()&lt;/a&gt;、
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Collider.OnTriggerStay.html&#34;&gt;OnTriggerStay()&lt;/a&gt;
がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void OnTriggerEnter(Collider other)
{
    Debug.Log(other.tag);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;joint-https-docs-unity3d-com-ja-current-manual-joints-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/Joints.html&#34;&gt;Joint&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Rigitbodyを他のRigitbodyとつなげるもの。
例えばSprint Jointだとオブジェクト間がばねのように伸縮する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/114-joint.png&#34; alt=&#34;Spring Joint&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのMecanimでヒューマノイドアニメーションさせる</title>
          <link>http://sambaiz.net/article/112/</link>
          <pubDate>Tue, 20 Jun 2017 23:58:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/112/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://www.assetstore.unity3d.com/jp/#!/content/4696&#34;&gt;Space Robot Kyle&lt;/a&gt;を動かす。&lt;/p&gt;

&lt;h2 id=&#34;アバターの作成&#34;&gt;アバターの作成&lt;/h2&gt;

&lt;p&gt;Assetsの&lt;code&gt;Model/Robot Kyle&lt;/code&gt;を選択し、RigのAnimation TypeをHumanoidにすると、
自動的にボーン構造を解析して人型にマッピングしたアバターが設定される。
Configure Avatarで確認すると正しく設定されているようだ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-rig.png&#34; alt=&#34;アバター&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;モーションの設定&#34;&gt;モーションの設定&lt;/h2&gt;

&lt;p&gt;KyleのAnimatorのAnimationに設定するAnimation Controllerを作成する。
まずは2つCreate Stateし、それぞれMotionに適当なモーション(今回は&lt;a href=&#34;https://www.assetstore.unity3d.com/jp/#!/content/36286&#34;&gt;Fighter Pack Bundle FREE&lt;/a&gt;を使った)を設定し、
Make Transitionで相互に結ぶと、オレンジになっているデフォルトステートから交互にモーションする。
ステートには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/StateMachineBehaviour.html&#34;&gt;StateMachineBehaviour&lt;/a&gt;のScriptを設定することもできる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-animation.png&#34; alt=&#34;モーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次にParametersでモーションを変化させる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-animation2.png&#34; alt=&#34;分岐したモーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Animatorの左上、parametersタブからBoolのWalkを追加する。
そして片方のTransitionのConditionにWalkがfalse、もう片方にはWalkがtrueを追加すると、
状態によって違うモーションをするようになる。
ちなみに、AnyStateからConditionを設定したTransitionを設定すると、どこのStateからでもそれで遷移させることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-parameters.png&#34; alt=&#34;パラメータ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このParameterはこんな感じに値を設定できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void Update () {
	GetComponent&amp;lt;Animator&amp;gt; ().SetBool (&amp;quot;Walk&amp;quot;, Random.value &amp;lt; 0.5);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一部だけモーションさせる&#34;&gt;一部だけモーションさせる&lt;/h2&gt;

&lt;p&gt;人体の一部だけをモーションさせるにはAvatar Maskを使う。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-avatar-mask.png&#34; alt=&#34;Avatar Mask&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-avatar-mask-motion.png&#34; alt=&#34;Avatar Maskしたモーション&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Animationで複数のレイヤーを作成すれば、異なるMaskでそれぞれステートを持たせることができる。&lt;/p&gt;

&lt;h2 id=&#34;animation-override-controller&#34;&gt;Animation Override Controller&lt;/h2&gt;

&lt;p&gt;作ったAnimationを違うモーションで再利用することができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/112-override.png&#34; alt=&#34;Animator Override Controller&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>VSでのネイティブプラグインのビルドからUnityでのWSAのビルドまでをバッチでする</title>
          <link>http://sambaiz.net/article/110/</link>
          <pubDate>Tue, 13 Jun 2017 00:32:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/110/</guid>
          <description>

&lt;h2 id=&#34;vsでのネイティブプラグインのビルド&#34;&gt;VSでのネイティブプラグインのビルド&lt;/h2&gt;

&lt;p&gt;VSが使っているビルドツール
&lt;a href=&#34;https://docs.microsoft.com/ja-jp/visualstudio/msbuild/msbuild&#34;&gt;MSBuild&lt;/a&gt;を使う。
VSのプロジェクトファイルにはMSBuildのXMLが含まれている。
これ自体はVSに依存していないため、単体で動かすこともできる。&lt;/p&gt;

&lt;p&gt;パスが通ってなかったらパスを通す。管理者権限が必要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild
&#39;MSBuild&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\MSBuild\15.0\Bin&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;別プロセスから適用されるので立ち上げ直すとパスが通っていることを確認できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; MSBuild /version
Microsoft (R) Build Engine バージョン 15.1.1012.6693
Copyright (C) Microsoft Corporation.All rights reserved.

15.1.1012.6693
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ビルドして&lt;code&gt;Assets\Plugins&lt;/code&gt;に配置する。これは前作ったBLEのネイティブプラグインのもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/105/&#34;&gt;Unity/UWPでBLEを扱うプラグインを作る - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; git clone git@github.com:sambaiz/UnityBLE_UWP.git
&amp;gt; cd UnityBLE_UWP
&amp;gt; MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
&amp;gt; MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
&amp;gt; copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
&amp;gt; copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
&amp;gt; cd ..
&amp;gt; rmdir /S /Q UnityBLE_UWP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんなエラーが出てきたらmscorlib.dllをインポートできていないのが原因のようで、
restoreしたらうまくいった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error CS0518: 定義済みの型 &#39;System.Object&#39; は定義、またはインポートされていません
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unityでのwsaのビルド&#34;&gt;UnityでのWSAのビルド&lt;/h2&gt;

&lt;p&gt;同様にUnityもパスが通ってなかったら通す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity
&#39;Unity&#39; は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。

&amp;gt;　SETX /M PATH &amp;quot;%PATH%;C:\Program Files\Unity\Editor&amp;quot;

成功: 指定した値は保存されました。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/BuildPipeline.BuildPlayer.html&#34;&gt;スクリプト&lt;/a&gt;
をAssets/Editorの中に置く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEditor;

public class Build {

    static void PerformBuild()
    {
        string[] scenes = { &amp;quot;Assets/main.unity&amp;quot; };
        BuildPipeline.BuildPlayer(scenes, &amp;quot;build&amp;quot;,
            BuildTarget.WSAPlayer, BuildOptions.None);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このstaticメソッドを&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/CommandLineArguments.html&#34;&gt;executeMethod&lt;/a&gt;
で渡してビルドする。Unityを開いたままだと失敗するので閉じる必要がある。&lt;/p&gt;

&lt;p&gt;この例だとbuildディレクトリに出力される。もし出力されなかったらEditorログを見る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Unity -quit -batchmode -executeMethod Build.PerformBuild
&amp;gt; type C:\Users\(username)\AppData\Local\Unity\Editor\Editor.log
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめたもの&#34;&gt;まとめたもの&lt;/h2&gt;

&lt;p&gt;ということでこんなバッチをUnityプロジェクトの直下に置いておくことにした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:sambaiz/UnityBLE_UWP.git
cd UnityBLE_UWP
MSBuild UnityBLE_UWP\UnityBLE_UWP.csproj /t:restore;build /p:Configuration=Release;Platform=&amp;quot;x86&amp;quot;
MSBuild UnityBLE_Editor\UnityBLE_Editor.csproj /t:restore;build /p:Configuration=Release
copy /Y UnityBLE_UWP\bin\x86\Release\UnityBLE_UWP.dll ..\Assets\Plugins\WSA
copy /Y UnityBLE_Editor\bin\Release\UnityBLE_Editor.dll ..\Assets\Plugins
cd ..
rmdir /S /Q UnityBLE_UWP

rmdir /S /Q build
Unity -quit -batchmode -executeMethod Build.PerformBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://sh-yoshida.hatenablog.com/entry/2017/05/27/012755&#34;&gt;MSBuildでコマンドラインからビルドする - 1.21 jigowatts&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unity/UWPでBLEを扱うプラグインを作る</title>
          <link>http://sambaiz.net/article/105/</link>
          <pubDate>Sun, 04 Jun 2017 11:57:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/105/</guid>
          <description>&lt;p&gt;コードは&lt;a href=&#34;https://github.com/sambaiz/UnityBLE_UWP&#34;&gt;ここ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/aonishi/2013/12/04/unity-on-windows-8-1/&#34;&gt;この動画&lt;/a&gt;の
50:00あたりから説明があるように、
ビルドされたWSAが読むUWPのdllのほかに、
Unityエディタ上から読むための.NET Framework3.5のdllを用意する。
こうすることで実行環境ごとの違いをUnityコード上で気にしなくてもよくなる。&lt;/p&gt;

&lt;p&gt;新しいプロジェクトで&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Visual C# から.NET Framework 3.5にしてクラスライブラリ(.NET Framework)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visual C# -&amp;gt;　Windows -&amp;gt; ユニバーサルからクラスライブラリ(ユニバーサルWindows)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の2つのプロジェクトを同じソリューションに作成する。
VS2017で.NET Frameworkのクラスライブラリプロジェクトを作成するためには
Visual Studio Installerで.NET Coreのワークロードをインストールする必要がある。
また、これとは別に動作確認用のUWPアプリケーションプロジェクトを作成した。&lt;/p&gt;

&lt;p&gt;UWPの方のプロジェクトにあるClass1.csを削除し、追加 -&amp;gt; 既存の項目から、
もう片方のClass1.csをリンクとして追加して、この共通のcsにUWPのコードを書いていくんだけど、
そのまま書くと当然.NET Frameworkの方でビルドできないので
実装部分を&lt;a href=&#34;https://docs.unity3d.com/Manual/PlatformDependentCompilation.html&#34;&gt;#if WINDOWS_UWP ~ #endif&lt;/a&gt;
で囲む。UWPの方のプロジェクトにはプロパティ -&amp;gt; ビルドの条件付きコンパイルにWINDOWS_UWPが含まれているので有効になる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void Start()
{
#if WINDOWS_UWP
    ...
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UWPでBLEを扱うのは前書いた通り。
ただし、なぜかXAMLに依存しているようでD3Dビルドすると失敗する。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/101&#34;&gt;UWPでBLEデバイスとペアリングして値を取得する - sambaiz-net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ビルドするとdllができるので.NET Frameworkの方をAssets/Pluginsに置いてInspectorからEditorにだけチェックを入れる。
UWPの方は&lt;a href=&#34;https://docs.unity3d.com/Manual/PluginInspector.html&#34;&gt;Assets/Plugins/WSA&lt;/a&gt;に置くとWSA Playerにだけチェックが入る。&lt;/p&gt;

&lt;p&gt;あとは普通にusingして使うだけ。Bluetoothのcapabilityを有効にするのを忘れずに。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityBLE;
  
public class BLE : MonoBehaviour {

    string value = &amp;quot;no connection&amp;quot;;

    public GameObject text;

    private string serviceUUID = &amp;quot;***&amp;quot;;
    private string characteristicUUID = &amp;quot;***&amp;quot;;

    void Start() {
        var ble = new UnityBLE.BLE();
        ble.DeviceAdded += (sender, obj) =&amp;gt; {
            value = &amp;quot;DeviceID: &amp;quot; + obj.DeviceID;
            ble.Listen(obj.DeviceID, serviceUUID, characteristicUUID);
            ble.Stop();
        };
        ble.CharacteristicReceived += (sender, obj) =&amp;gt;
        {
            if (sender == ble)
            {
                if (obj.ex == null)
                {
                    value = Encoding.UTF8.GetString(obj.Value);
                }
                else
                {
                    value = obj.ex.Message;
                }
            }
        };
        ble.Start();
    }

    void Update() {
        text.GetComponent&amp;lt;TextMesh&amp;gt;().text = value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityのパーティクル設定(Shuriken)</title>
          <link>http://sambaiz.net/article/92/</link>
          <pubDate>Thu, 13 Apr 2017 17:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/92/</guid>
          <description>

&lt;p&gt;Unityには&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/class-ParticleSystem.html&#34;&gt;Shuriken&lt;/a&gt;というパーティクルシステムがある。&lt;/p&gt;

&lt;p&gt;Sphereを置いてParticle Systemを追加すると、Particleが出始める。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-1.png&#34; alt=&#34;Particleの初期状態&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;モジュール&#34;&gt;モジュール&lt;/h2&gt;

&lt;p&gt;設定項目が多いためモジュールに分かれている。ひとまずデフォルトで有効になっている&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(メインモジュール)&lt;/li&gt;
&lt;li&gt;Emission&lt;/li&gt;
&lt;li&gt;Shape&lt;/li&gt;
&lt;li&gt;Renderer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;について見ていく。&lt;/p&gt;

&lt;h3 id=&#34;メインモジュール-https-docs-unity3d-com-550-documentation-manual-partsysmainmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysMainModule.html&#34;&gt;メインモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Duration: 5&lt;/li&gt;
&lt;li&gt;Looping: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;デフォルトだとLoopingにチェックが入っているのでずっと出ているが、チェックを外すとDurationで止まる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Delay: 0&lt;/li&gt;
&lt;li&gt;Play On Awake: true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PlayOnAwakeがtrueでStartDelayが0なので実行してからすぐにParticleが出始める。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Lifetime: 5&lt;/li&gt;
&lt;li&gt;Max Particles: 1000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartLifetimeはParticleが消えるまでの時間。ただしMaxParticlesに達したら消される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Speed: 5&lt;/li&gt;
&lt;li&gt;Simulation Speed: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StartSpeedはParticleの初速で、上げると勢い良く飛んでいく。
SimulationSpeedを上げるとParticleが出るのも含めて全体のスピードが上がる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Size: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期サイズ。小さくすると塵みたいになる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Start Rotation: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleの初期角度。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gravity Modifier: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重力値。0だと無重力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Simulation Space: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleをlocal座標かworld座標で動かすか。
Localだとオブジェクトが移動したときに一緒に移動する。Worldだと置いてかれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scaling Mode: Local&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ParticleのScale。LocalだとそのオブジェクトのScaleだけを見る。Hierarchyだと親も考慮したScale。Shapeだと開始位置だけ。&lt;/p&gt;

&lt;h3 id=&#34;emissionモジュール-https-docs-unity3d-com-550-documentation-manual-partsysemissionmodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysEmissionModule.html&#34;&gt;Emissionモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Rate over time: 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単位時間あたりにParticleを出す数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rate over Distance: 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;オブジェクトが移動するときにParticleを出す数。Simulation SpaceがWorldのときのみ有効。&lt;/p&gt;

&lt;h3 id=&#34;shapeモジュール-https-docs-unity3d-com-550-documentation-manual-partsysshapemodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysShapeModule.html&#34;&gt;Shapeモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shape: Corn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleを出す形。Cornだと特定方向に向けた円錐状に出る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-corn.png&#34; alt=&#34;ShapeがCorn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Spehreで全方向に出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-sphere.png&#34; alt=&#34;ShapeがSphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hemisphereで片側だけ出したり、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-hemisphere.png&#34; alt=&#34;ShapeがHemisphere&#34; /&gt;&lt;/p&gt;

&lt;p&gt;EdgeでY方向に直線上に出したりすることができる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-particle-shape-edge.png&#34; alt=&#34;ShapeがEdge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そのほかのパラメータはShapeに応じて設定する。&lt;/p&gt;

&lt;h3 id=&#34;rendererモジュール-https-docs-unity3d-com-550-documentation-manual-partsysrenderermodule-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/PartSysRendererModule.html&#34;&gt;Rendererモジュール&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Render Mode: Billboard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleがどのようにレンダリングされるか。Billboardは常にカメラに向くようにレンダリングされる。&lt;/p&gt;

&lt;p&gt;Stretched Billboardにするとカメラの方向に向きながら、&lt;a href=&#34;https://en.wikipedia.org/wiki/Squash_and_stretch&#34;&gt;stretch and squash&lt;/a&gt;させる。つまり速度を強調するように変形させる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-stretched-billboard.png&#34; alt=&#34;Render ModeがStretched Billboard&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material: None&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Particleのmaterial。これにDefault-Particleを指定するとこうなる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-default-particle.png&#34; alt=&#34;MaterialがDefault Particle&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;afterburner&#34;&gt;AfterBurner&lt;/h2&gt;

&lt;p&gt;Standard AssetsにあるAfterBurnerの設定を見てみる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner.png&#34; alt=&#34;AfterBurner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;中央の濃い部分と、そのまわりの薄い部分の2つの設定を組み合わせている。
Explosionとかは9個組み合わせているので比較的シンプル。&lt;/p&gt;

&lt;p&gt;濃い部分ではEmissionのRate over Timeを80にすることで続いているように見えるようにして、
Size over LifetimeモジュールのSizeを徐々に小さくすることによって尾の方にかけて細くなるようにしている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-size.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;さらにColor over LifetimeモジュールのColorで両端のAlphaを0、Location 6.0%のAlphaを30に設定することで、
素早くフェードインし、徐々にフェードアウトするようにしている。&lt;/p&gt;

&lt;p&gt;また、Start SizeをRandom Between Two Constantsの(1.2, 1.4)に設定することで多少揺らいでいるように見せている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/92-after-burner-gradient.png&#34; alt=&#34;AfterBurnerのSize over Lifetime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;薄い部分ではEmissionのRate over Timeを60、ColorのLocation 6.0%のAlphaを8に設定して薄く見せている。
あとはSize over Lifetimeを設定し、Start SizeはRandom Between Two Constantsの(4,6)と大きく設定してある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>C#のdelegateとevent</title>
          <link>http://sambaiz.net/article/83/</link>
          <pubDate>Sun, 12 Mar 2017 21:15:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/83/</guid>
          <description>

&lt;h2 id=&#34;delegate-https-msdn-microsoft-com-ja-jp-library-900fyy8e-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/900fyy8e.aspx&#34;&gt;delegate&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;カプセル化するためのdelegate(移譲)メソッドに使う型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Converter{

	private static double defaultConvert(double num){
		return num;
	}

	public delegate double Convert(double num);
	public Convert convert = defaultConvert;

	public double run(double num){
		return convert (num);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名メソッドやラムダ式を渡すこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var conv = new Converter ();

print (conv.run (2)); // 2

// 匿名メソッドの例
conv.convert = delegate(double input)
{
    return input + 1;
};
print (conv.run (2)); // 2 + 1 = 3

// ラムダ式の例
conv.convert = s =&amp;gt; s * s;
print (conv.run(2)); // 2 * 2 = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;event-https-msdn-microsoft-com-ja-jp-library-8627sbea-aspx&#34;&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/8627sbea.aspx&#34;&gt;event&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;宣言元でしか呼べないマルチキャストデリゲート。&lt;code&gt;+=&lt;/code&gt;でsubscribeして&lt;code&gt;-=&lt;/code&gt;で解除する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void RunEventHandler(double num);
public event RunEventHandler RunEvent;

public double run(double num){
    if (RunEvent != null) {
        RunEvent (num);
    }
    return convert (num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subscribeしたものは全て呼ばれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void runHook(double num){
    print(&amp;quot;b: &amp;quot; +  num);
}

var conv = new Converter ();
conv.RunEvent += s =&amp;gt; print (&amp;quot;a: &amp;quot; +  s); // Subscribe a
conv.run (2); // a: 2

conv.RunEvent += runHook; // Subscribe b
conv.run (3); // a: 3, b: 3

conv.RunEvent -= runHook; // Unsubscribe b
conv.run (4); // a: 4

// error
// conv.RunEvent (); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.NET Frameworkのクラスライブラリの全てのイベントでは
&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/db0etb8x.aspx&#34;&gt;EventHandler&lt;TEventArgs&gt;&lt;/a&gt;を使っていて、
ユーザー定義のコードでもこのパターンを使うのが&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/w369ty8x.aspx&#34;&gt;推奨されている&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public delegate void EventHandler&amp;lt;TEventArgs&amp;gt;(
	object sender,
	TEventArgs e
)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのMaterial</title>
          <link>http://sambaiz.net/article/82/</link>
          <pubDate>Sat, 11 Mar 2017 20:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/82/</guid>
          <description>

&lt;h2 id=&#34;materialとshaderとtexture-https-docs-unity3d-com-550-documentation-manual-shaders-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/Shaders.html&#34;&gt;MaterialとShaderとTexture&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Materialは表面がどのようにレダリングされるかを定義するもの。
Shaderを指定し、Textureなどのパラメーターを設定する。&lt;/p&gt;

&lt;p&gt;Shaderは光と、Materialの設定から、ピクセルの色を計算するスクリプト。
大体&lt;a href=&#34;https://docs.unity3d.com/550/Documentation/Manual/shader-StandardShader.html&#34;&gt;Standard Shader&lt;/a&gt;
で事足りるらしい。&lt;/p&gt;

&lt;p&gt;Textureはビットマップイメージ。色(Albedo)だけではなく、反射率や粗さなど、いろんな要素に使える。&lt;/p&gt;

&lt;h2 id=&#34;standard-shader&#34;&gt;Standard Shader&lt;/h2&gt;

&lt;h3 id=&#34;rendering-mode-https-docs-unity3d-com-manual-standardshadermaterialparameterrenderingmode-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/Manual/StandardShaderMaterialParameterRenderingMode.html&#34;&gt;Rendering Mode&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Albedoは(255, 255, 255, 255)で、テクスチャにはDefault Particleを指定している。
透明度はテクスチャのアルファチャンネルとAlbedoのアルファ値に基づく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-defaultparticle.png&#34; alt=&#34;Default Particle&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Opaque: デフォルト。すべて不透明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-opaque.png&#34; alt=&#34;Opaque&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CutOut: 閾値を境に、完全に透明か、不透明になる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alpha Cutoffを0.1にした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-cutout.png&#34; alt=&#34;CutOut&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transparent: 透明度が適用される。現実世界の透明なマテリアルのように、反射のハイライトは完全に表示される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-transparent.png&#34; alt=&#34;Transparent&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fade: ハイライトにも透明度を適用する。フェードイン/アウトしたいときに使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-fade.png&#34; alt=&#34;Fade&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;metallic&#34;&gt;Metallic&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/StandardShaderMaterialCharts.html&#34;&gt;マテリアルチャート&lt;/a&gt;をもとにAlbedoとMetallicとSmoothnessを設定する。&lt;/p&gt;

&lt;p&gt;これは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Albedo: (255, 255, 255, 255)&lt;/li&gt;
&lt;li&gt;Metallic: 1&lt;/li&gt;
&lt;li&gt;Smoothness: 0.68&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を設定している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/82-metal.png&#34; alt=&#34;Metallic&#34; /&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのUI</title>
          <link>http://sambaiz.net/article/81/</link>
          <pubDate>Wed, 08 Mar 2017 16:49:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/81/</guid>
          <description>

&lt;h2 id=&#34;canvas-https-docs-unity3d-com-ja-540-scriptreference-canvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/ScriptReference/Canvas.html&#34;&gt;Canvas&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;UI要素を配置するための領域。&lt;/p&gt;

&lt;h3 id=&#34;rendermode-https-docs-unity3d-com-jp-540-manual-uicanvas-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UICanvas.html&#34;&gt;renderMode&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Overlay: スクリーンに対してオーバーレイするように表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Camera: Cameraから指定した距離(planeDistance)離れた前方に表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;World Space 他のオブジェクトと同じように表示&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;canvas-scaler-https-docs-unity3d-com-jp-540-manual-script-canvasscaler-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/script-CanvasScaler.html&#34;&gt;Canvas Scaler&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UI Scale Mode (World Space以外)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constant Pixel Size: 画面サイズに関わらず同じピクセル数にする&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scale With Screen Size: 画面サイズでスケールさせる&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Constant Physical Size 解像度や画面サイズによらず物理的に同じサイズにする&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dynami Pixels Per Unit (World Spaceのみ): Textなどの動的に生成されたビットマップの解像度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1と3でそれぞれこんな感じになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu1.png&#34; alt=&#34;Dynamic Pixels Per Unitが1のとき&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/81-ppu3.png&#34; alt=&#34;Dynamic Pixels Per Unitが3のとき&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;autolayout-https-docs-unity3d-com-ja-540-manual-comp-uiautolayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/comp-UIAutoLayout.html&#34;&gt;AutoLayout&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-VerticalLayoutGroup.html&#34;&gt;Vertical Layout Group&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-GridLayoutGroup.html&#34;&gt;Grid Layout Group&lt;/a&gt;
など。これらのComponentを追加すると子要素のTransform(の一部)が自動で設定される。&lt;/p&gt;

&lt;h3 id=&#34;content-size-fitter-https-docs-unity3d-com-ja-540-manual-script-contentsizefitter-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/540/Manual/script-ContentSizeFitter.html&#34;&gt;Content Size Fitter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Layout Component要素に合うように自動で調整される。&lt;/p&gt;

&lt;h2 id=&#34;レイアウトを作る-https-docs-unity3d-com-jp-540-manual-uibasiclayout-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/Manual/UIBasicLayout.html&#34;&gt;レイアウトを作る&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;RectTool(ツールバーボタンの一番右の四角いやつ)を選択して、Pivot, Localにするとよい。
Canvasにいろいろ置いていって、Anchorを選んでRect Transformを設定していく。
あとはPrefabにしてInstantiateするなりして表示する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine.UI;

public GameObject dialogWindow;
var obj = Instantiate(obj, new Vector3(0, 0, 200), Quaternion.identity);

var hogeText = obj.transform.Find(&amp;quot;panel/hoge&amp;quot;).gameObject.GetComponent&amp;lt;Text&amp;gt;();
hogeText.text = &amp;quot;fuga&amp;quot;;

var fugaButton = obj.transform.Find(&amp;quot;panel/fuga&amp;quot;).gameObject.GetComponent&amp;lt;Button&amp;gt;();
fugaButton.onClick.AddListener (() =&amp;gt; {
    Debug.Log (&amp;quot;onClick&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityのTransform</title>
          <link>http://sambaiz.net/article/80/</link>
          <pubDate>Tue, 07 Mar 2017 02:11:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/80/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&#34;&gt;https://docs.unity3d.com/jp/current/ScriptReference/Transform.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトの位置、スケール、回転を保持する。親子関係を持つ。&lt;/p&gt;

&lt;h2 id=&#34;position&#34;&gt;Position&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-position.html&#34;&gt;position&lt;/a&gt;がワールド空間の、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localPosition.html&#34;&gt;localPosition&lt;/a&gt;
が親から見た相対的なローカル空間の位置。localPositionの1unitはscaleに依存する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.position = new Vector3(0, 0, 0);
transform.localPosition = new Vector3(0, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に移動するには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Translate.html&#34;&gt;Translate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;になっていて、&lt;code&gt;Space.World&lt;/code&gt;を指定するとワールド座標を基準にする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Time-deltaTime.html&#34;&gt;Time.deltaTime&lt;/a&gt;は最後のフレームを完了するのにかかった秒数。
なのでフレームレートにかかわらず同じ速度で移動させることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Translate(0, Time.deltaTime, 0, Space.World);
transform.Translate(Vector3.up * Time.deltaTime, Space.World); // 軸に沿って移動
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform); // 最後の引数のローカル座標を基準にする
transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scale&#34;&gt;Scale&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localScale.html&#34;&gt;localScale&lt;/a&gt;
はローカル空間のスケール。ワールド空間のScaleはない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.localScale = new Vector3(0.1f, 1f, 1f);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rotation&#34;&gt;Rotation&lt;/h2&gt;

&lt;p&gt;ワールド空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-rotation.html&#34;&gt;rotation&lt;/a&gt;と
ローカル空間の
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform-localRotation.html&#34;&gt;localRoation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Unityは&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.html&#34;&gt;Quarternion&lt;/a&gt;(四元数)で回転を持っている。
実際はQuarternionそのものを自分で計算することはなく、
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.LookRotation.html&#34;&gt;Quaternion.LookRotation()&lt;/a&gt;や
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Quaternion.Euler.html&#34;&gt;Quaternion.Euler()&lt;/a&gt;などを使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vector3 relativePos;
transform.rotation = Quaternion.LookRotation(relativePos); // そのPointを向くように回転
transform.localRotation = Quaternion.Euler(0, 30, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transformを向くように回転する場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.LookAt.html&#34;&gt;LookAt()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Transform target;
transform.LookAt(target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;徐々に回転させるには&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Rotate.html&#34;&gt;Rotate()&lt;/a&gt;を使う。
最後の引数はデフォルトで&lt;code&gt;Space.Self&lt;/code&gt;で、&lt;code&gt;Space.World&lt;/code&gt;を指定すると回転の軸がワールドの軸になる。指定するのは角度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.Rotate(0, Time.deltaTime, 0, Space.World);
transform.Rotate(Vector3.up, Time.deltaTime, Space.World);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ワールド座標のあるPointを中心として回転させる場合は
&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.RotateAround.html&#34;&gt;RotateAround()&lt;/a&gt;を使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transform.RotateAround(Vector3.zero, Vector3.up, 20 * Time.deltaTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parent-https-docs-unity3d-com-jp-current-scriptreference-transform-parent-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/current/ScriptReference/Transform-parent.html&#34;&gt;parent&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;親を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fuga = GameObject.CreatePrimitive (PrimitiveType.Cube);
fuga.transform.parent = hoge.transform;
fuga.transform.parent = null; // detach
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-https-docs-unity3d-com-jp-540-scriptreference-transform-find-html&#34;&gt;&lt;a href=&#34;https://docs.unity3d.com/jp/540/ScriptReference/Transform.Find.html&#34;&gt;Find&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;子の名前で検索する。
FindChildもあるけどドキュメントに書いてないので使わない方がよさそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var child = transform.Find(&amp;quot;hoge/fuga&amp;quot;)
if(child != null){
    child.gameObject
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Unityと.NETとMono</title>
          <link>http://sambaiz.net/article/78/</link>
          <pubDate>Sun, 05 Mar 2017 18:50:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/78/</guid>
          <description>

&lt;p&gt;.NETとかよくわからなかったのでまとめてみた。&lt;/p&gt;

&lt;h2 id=&#34;net-framework&#34;&gt;.NET Framework&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework - Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoftが開発したアプリケーション開発、実行環境。&lt;/p&gt;

&lt;p&gt;各言語のコンパイラによって言語、環境によらない共通の中間言語(CIL, Common Intermediate Language)バイナリ(exeやdll)に変換し、
実行時に共通言語基盤(CLI, Common Language Infrastructure)の仮想実行システム(VES)が環境依存の機械語を動的に生成(JIT, Just in time)する。
CLIの仕様はECMAで標準化されていて、Microsoftが実装したCLIが共通言語ランタイム(CLR)。Windowsでしか動かない。&lt;/p&gt;

&lt;h2 id=&#34;net-core&#34;&gt;.NET Core&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/magazine/mt694084.aspx&#34;&gt;.NET Core - .NET Core による .NET のクロスプラットフォームへの移行&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Microsoft/dotnet&#34;&gt;Microsoft/dotnet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームに対応した.NET。CoreCLRはWindowsだけではなくMacやLinuxでも動く。
.NET Frameworkと共通のAPIもあるが、GUIまわりでどちらかにしかないAPIが存在する。&lt;/p&gt;

&lt;h2 id=&#34;mono-http-www-mono-project-com&#34;&gt;&lt;a href=&#34;http://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;オープンソースで、クロスプラットフォームな.NET Framework互換ソフトウェア。C#のコンパイラとCLIが実装されている。
Unityはこれを使っているが、バージョンが古くて使えないライブラリがある。&lt;/p&gt;

&lt;h2 id=&#34;net-coreでhello-world&#34;&gt;.NET CoreでHello World&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/net/core#macos&#34;&gt;インストール手順&lt;/a&gt;に沿って
&lt;code&gt;dotnet&lt;/code&gt;コマンドを使えるようにする。&lt;/p&gt;

&lt;p&gt;Hello Worldまで。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dotnet console -o hwapp
$ cd hwapp
$ ls
Program.cs	hwapp.csproj

$ dotnet restore
$ ls
Program.cs	hwapp.csproj	obj

$ ls obj
hwapp.csproj.nuget.g.props	project.assets.json
hwapp.csproj.nuget.g.targets

# dotnet build
$ dotnet run
Hello World!

$ dotnet bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に.NET CoreにしかないAPIも使っていないのでmono(.NET Framework)ででも実行できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Program.cs 
using System;

namespace hwapp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&amp;quot;Hello World!&amp;quot;);
        }
    }
}

$ mono bin/Debug/netcoreapp1.1/hwapp.dll 
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.slideshare.net/AimingStudy/unitynet&#34;&gt;Unityと.NET&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>剣を振るVRゲームを作った</title>
          <link>http://sambaiz.net/article/29/</link>
          <pubDate>Sun, 30 Oct 2016 19:05:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/29/</guid>
          <description>

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_game.png&#34; alt=&#34;ゲーム画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Tlonh7D5UzY&#34;&gt;プレイ動画&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vr.google.com/intl/ja_jp/cardboard/&#34;&gt;Cardboard&lt;/a&gt;にAndroidを入れて、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_card.jpg&#34; alt=&#34;Cardboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;iPhoneをくくりつけた傘を動かすと、画面の剣も動くのでこれで敵を倒すゲーム。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sambaiz.net/images/29_sword.jpg&#34; alt=&#34;iPhoneをくくりつけた傘&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;h3 id=&#34;剣-ios&#34;&gt;剣(iOS)&lt;/h3&gt;

&lt;p&gt;剣にくくりつけたiPhoneの傾きの値をUnity(Android)に送信している。
iOSはClassic Bluetoothを自由に使えないので、Androidと通信する場合はBLEを使う。
BLEは通常だと20byteしか一度に送れないので、これを超えないよう注意する必要がある。&lt;/p&gt;

&lt;p&gt;BLEで通信するところは&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/26&#34;&gt;iOS端末をBLEのPeripheralにする&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;で作ったので、端末の傾きを取得して送るだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import CoreMotion

class Motion{

    let peripheral: BLEPeripheral
    let accelHandler:CMDeviceMotionHandler
    let manager = CMMotionManager()

    public init(peripheral :BLEPeripheral, label :UILabel){
        self.peripheral = peripheral

        accelHandler = {
            (data: CMDeviceMotion?, error: Error?) -&amp;gt; Void in
            let str = String(format: &amp;quot;%.1f %.1f %.1f&amp;quot;,
                             arguments: [data!.attitude.pitch * 180 / M_PI,
                                         data!.attitude.roll * 180 / M_PI,
                                         data!.attitude.yaw * 180 / M_PI]
                )
            let res = peripheral.update(str.data(using: String.Encoding.utf8))
            label.text = str + &amp;quot; &amp;quot; + String(res)
        }
    }

    func start(){
        if manager.isDeviceMotionAvailable {
            manager.deviceMotionUpdateInterval = 1 / 12;
            manager.startDeviceMotionUpdates(to: OperationQueue.current!, withHandler: accelHandler)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ゲーム-unity-android&#34;&gt;ゲーム(Unity &amp;amp; Android)&lt;/h3&gt;

&lt;p&gt;オライリーから&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873117577/&#34;&gt;UnityによるVRアプリケーション開発――作りながら学ぶバーチャルリアリティ入門&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;という本が出ていたので買った。Unityの初歩的なところやBlenderとかも説明があるのでおすすめ。
とりあえず&lt;a href=&#34;https://developers.google.com/vr/unity/&#34;&gt;GoogleのSDK&lt;/a&gt;をimportして、
Prefabの&lt;code&gt;GvrViewerMain&lt;/code&gt;を置くと二眼のそれっぽい感じになる。&lt;/p&gt;

&lt;p&gt;スコアとかゲームオーバーの状態と処理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class Game : MonoBehaviour {

	public static int score = 0;
	public static bool gameOver = false;
	public static bool killed = false;

	public Text gameOverText;
	public Text scoreText;
	public GameObject enemy;

	void Start () {
		gameOverText.enabled = false;
	}

	void Update () {
		scoreText.text = &amp;quot;Score: &amp;quot; + score;
		if (gameOver) gameOverText.enabled = true;
		if (killed) {
			nextLevel ();
			killed = false;
		}
	}

	public void nextLevel(){
		var old = enemy;
		var x = Random.Range (-10, 10);
		enemy = (GameObject) Instantiate (
			enemy, new Vector3(x, 0, Mathf.Sqrt(10 * 10 - x * x)), Quaternion.Euler(0, 0, 0));
		Destroy (old);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵の当たり判定。剣に当たったら爆発して次のが出てくる。
体(見えないCapsule Colliderを設定している)に当たるとゲームオーバー。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class MonsterHit : MonoBehaviour {

	public GameObject killEffect;

	void OnCollisionEnter(Collision collision) {
		switch (collision.gameObject.name) {
		case &amp;quot;sword&amp;quot;:
			if (!Game.gameOver) {
				Game.score += 1;
				Instantiate (killEffect, transform.position, transform.rotation);
				Game.killed = true;
			}
			break;

		case &amp;quot;Body&amp;quot;:
			Game.gameOver = true;
			break;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;敵を動かす。スコアが上がるとスピードも上がる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class MonsterMove : MonoBehaviour {

	private float moveRate;

	void Start () {
		moveRate = 0.0f;
	}

	void Update () {
		transform.position = Vector3.Lerp (transform.position, new Vector3 (0, 0, -1.5f), moveRate);
		moveRate += 0.0001f * (Game.score + 1);
		transform.LookAt (new Vector3 (0, 0, -1.5f));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;センサーの値を受け取って、剣を動かす。ここで使っているネイティブライブラリは前作ったもの。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://sambaiz.net/article/27&#34;&gt;UnityでAndroidのBLEを使うネイティブプラグインを作る&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using UnityEngine;
using System.Collections;

public class SwordMotion : MonoBehaviour {

	private AndroidJavaObject ble;
	private Quaternion q;

	void Start () {
		ble = new AndroidJavaObject (&amp;quot;net.sambaiz.unity_ble.BLE&amp;quot;, this.gameObject.name, &amp;quot;received&amp;quot;);
		q = Quaternion.Euler (0, 0, 0);
	}

	void Update () {
		transform.rotation = q;
	}

	void received(string message){
		var motionData = message.Split (&#39; &#39;); // pitch roll yaw
		q = Quaternion.Euler (
				90 - float.Parse (motionData [0]),
				float.Parse (motionData [1]),
				0) ;
	}

	void OnApplicationPause (bool pauseStatus)
	{
		if (ble != null) {
			if (pauseStatus) {
				ble.Call (&amp;quot;onPause&amp;quot;);
			} else {
				ble.Call (&amp;quot;onActive&amp;quot;);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>UnityでAndroidのBLEを使うネイティブプラグインを作る</title>
          <link>http://sambaiz.net/article/27/</link>
          <pubDate>Sun, 23 Oct 2016 20:39:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/27/</guid>
          <description>

&lt;p&gt;UnityからBLEを使うためのネイティブプラグインを作る。&lt;/p&gt;

&lt;h2 id=&#34;android側&#34;&gt;Android側&lt;/h2&gt;

&lt;p&gt;まず、Activityなしのプロジェクトを作って、New ModuleからAndroid Libraryを選択。
これらのパッケージ名がUnityで使うものと被らないようにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/Applications/Unity/PlaybackEngines/AndroidPlayer/Variations/mono/Release/Classes/classes.jar&lt;/code&gt;
をModuleの方のlibsに置く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import com.unity3d.player.UnityPlayer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このjarは元々のやつとかぶってしまうので除外(build.gradleに追加)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.libraryVariants.all { variant -&amp;gt;
    variant.outputs.each { output -&amp;gt;
        output.packageLibrary.exclude(&#39;libs/classes.jar&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Activiyは&lt;code&gt;UnityPlayer.currentActivity&lt;/code&gt;で取得でき、
Unity側のメソッドを呼ぶのも
&lt;code&gt;UnityPlayer.UnitySendMessage(mGameObjName, mCallBackName, new String(characteristic.getValue()));&lt;/code&gt;
のようにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BLE {

    private final static String TAG = BLE.class.getSimpleName();
    private static final int REQUEST_ENABLE_BT = 1;
    private static final int MY_PERMISSION_RESPONSE = 2;

    private static final String PERIPHERAL_LOCAL_NAME = &amp;quot;my-ble&amp;quot;;
    private static final UUID PERIPHERAL_SERIVCE_UUID = UUID.fromString(&amp;quot;BF9CB85F-620C-4A67-BDD2-1A64213F74CA&amp;quot;);
    private static final UUID PERIPHERAL_CHARACTERISTIC_UUID = UUID.fromString(&amp;quot;5F83E23F-BCA1-42B3-B6F2-EA82BE46A93D&amp;quot;);
    private static final UUID CLIENT_CHARACTERISTIC_CONFIG = UUID.fromString(&amp;quot;00002902-0000-1000-8000-00805f9b34fb&amp;quot;);

    private String mGameObjName;
    private String mCallBackName;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothGatt mBluetoothGatt;
    private BluetoothGattCharacteristic mCharacteristic;
    private Handler mHandler;

    // Stops scanning after 30 seconds.
    private static final long SCAN_PERIOD = 30000;

    public BLE(String gameObjName, String callBackName) {

        this.mGameObjName = gameObjName;
        this.mCallBackName = callBackName;

        mHandler = new Handler();

        if (!UnityPlayer.currentActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
            Toast.makeText(UnityPlayer.currentActivity, &amp;quot;BLEをサポートしていません&amp;quot;, Toast.LENGTH_SHORT).show();
            UnityPlayer.currentActivity.finish();
            return;
        }

        final BluetoothManager bluetoothManager =
                (BluetoothManager) UnityPlayer.currentActivity.getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = bluetoothManager.getAdapter();

        if (mBluetoothAdapter == null) {
            Toast.makeText(UnityPlayer.currentActivity, &amp;quot;Bluetoothをサポートしていません&amp;quot;, Toast.LENGTH_SHORT).show();
            UnityPlayer.currentActivity.finish();
            return;
        }

        onActive();
    }

    public void onActive() {
        Log.d(TAG, &amp;quot;onActive&amp;quot;);
        if (!mBluetoothAdapter.isEnabled()) {
            Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            UnityPlayer.currentActivity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
        }

        scanLeDevice(true);
    }

    public void onPause() {
        Log.d(TAG, &amp;quot;onPause&amp;quot;);
        scanLeDevice(false);

        if(mCharacteristic != null){
            mBluetoothGatt.setCharacteristicNotification(
                    mCharacteristic,
                    false
            );
        }

        if(mBluetoothGatt != null) {
            mBluetoothGatt.close();
            mBluetoothGatt = null;
        }
    }

    private void scanLeDevice(final boolean enable) {
        if (enable) {
            mHandler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    mBluetoothAdapter.stopLeScan(mLeScanCallback);
                }
            }, SCAN_PERIOD);

            mBluetoothAdapter.startLeScan(mLeScanCallback);
        } else {
            mBluetoothAdapter.stopLeScan(mLeScanCallback);
        }
    }

    private BluetoothAdapter.LeScanCallback mLeScanCallback =
            new BluetoothAdapter.LeScanCallback() {

                @Override
                public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {
                    if(PERIPHERAL_LOCAL_NAME.equals(device.getName())){
                        scanLeDevice(false);
                        connect(device);
                    }
                }
            };

    private boolean connect(BluetoothDevice device) {
        if (mBluetoothAdapter == null) {
            Log.w(TAG, &amp;quot;BluetoothAdapter not initialized or unspecified address.&amp;quot;);
            return false;
        }

        // Previously connected device.  Try to reconnect.
        if (mBluetoothGatt != null) {
            Log.d(TAG, &amp;quot;Trying to use an existing mBluetoothGatt for connection.&amp;quot;);
            if (mBluetoothGatt.connect()) {
                return true;
            } else {
                return false;
            }
        }

        mBluetoothGatt = device.connectGatt(UnityPlayer.currentActivity, false, mGattCallback);
        Log.d(TAG, &amp;quot;Trying to create a new connection.&amp;quot;);
        return true;
    }


    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            if (newState == BluetoothProfile.STATE_CONNECTED) {

                scanLeDevice(false);
                Log.i(TAG, &amp;quot;Connected to GATT server.&amp;quot;);
                gatt.discoverServices();

            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                Log.i(TAG, &amp;quot;Disconnected from GATT server.&amp;quot;);
            } else{
                Log.i(TAG, &amp;quot;onConnectionStateChange:&amp;quot; + newState);
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                mCharacteristic = gatt.getService(PERIPHERAL_SERIVCE_UUID).
                        getCharacteristic(PERIPHERAL_CHARACTERISTIC_UUID);

                gatt.setCharacteristicNotification(
                        mCharacteristic,
                        true
                );
                BluetoothGattDescriptor descriptor = mCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
                descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
                mBluetoothGatt.writeDescriptor(descriptor);
            } else {
                Log.w(TAG, &amp;quot;onServicesDiscovered received: &amp;quot; + status);
            }
        }

        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt,
                                            BluetoothGattCharacteristic characteristic) {
            UnityPlayer.UnitySendMessage(mGameObjName, mCallBackName, new String(characteristic.getValue()));
        }
    };

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manifestに追加した分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-feature android:name=&amp;quot;android.hardware.bluetooth_le&amp;quot; android:required=&amp;quot;true&amp;quot;/&amp;gt;

&amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.BLUETOOTH_ADMIN&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_COARSE_LOCATION&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できたらaarを生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gradlew assembleRelease
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build/outputs/aar/*-release.aar&lt;/code&gt;をUnityの&lt;code&gt;Assets/Plugins/Android/libs&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;あと、依存aarはこの中に含まれないようなのでそれもまとめてコピーする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;task copyLibs(type: Copy) {
    from configurations.compile
    into &#39;build/outputs/aar&#39;
    exclude { details -&amp;gt; details.file.name.endsWith(&amp;quot;.jar&amp;quot;) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manifetstのmergeに失敗したのでSDKVersionを合わせる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compileSdkVersion 22

defaultConfig {
    minSdkVersion 19
    targetSdkVersion 22
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unity側&#34;&gt;Unity側&lt;/h2&gt;

&lt;p&gt;こんな感じでインスタンスを作り、
&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/AndroidJavaObject.Call.html&#34;&gt;メソッドを呼べる&lt;/a&gt;。
ただし、unity editor上では&lt;code&gt;Init&#39;d AndroidJavaClass with null ptr!&lt;/code&gt;のエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugin = new AndroidJavaObject(&amp;quot;net.sambaiz.unity_ble.BLE&amp;quot;, this.gameObject.name, &amp;quot;received&amp;quot;);

void received(string message){
	Debug.Log (&amp;quot;BLE:&amp;quot; + message);
}

void OnApplicationPause (bool pauseStatus)
{
	if (pauseStatus) {
		plugin.Call (&amp;quot;onPause&amp;quot;);
	} else {
		plugin.Call (&amp;quot;onActive&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
