<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz.net</title>
    <link>http://sambaiz.net/tags/golang/</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2016</rights>
    <updated>2016-08-15 04:07:00 &#43;0900 JST</updated>

    
      
        <item>
          <title>GolangでAPIとテストを書く(echo/dbr/glide/goose/mock)</title>
          <link>http://sambaiz.net/article/15/</link>
          <pubDate>Mon, 15 Aug 2016 04:07:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/15/</guid>
          <description>

&lt;p&gt;久々にGolangを書くことになったので、以下の記事を参考にして簡単なAPIとそのテストを書いてみた。
コードは&lt;a href=&#34;https://github.com/sambaiz/go-api-with-test&#34;&gt;ここ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ameblo.jp/principia-ca/entry-12130127314.html&#34;&gt;Go言語でTestableなWebアプリケーションを目指して｜サイバーエージェント 公式エンジニアブログ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使った主なライブラリ-ツール&#34;&gt;使った主なライブラリ・ツール&lt;/h2&gt;

&lt;h3 id=&#34;echo-https-github-com-labstack-echo&#34;&gt;&lt;a href=&#34;https://github.com/labstack/echo&#34;&gt;echo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;webフレームワーク。速いらしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/labstack/echo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    conn, err := dbr.Open(&amp;quot;mysql&amp;quot;, &amp;quot;root:@tcp(localhost:3306)/mboard&amp;quot;, nil)
    if err != nil {
        panic(err)
    }
    conn.SetMaxIdleConns(200)
    conn.SetMaxOpenConns(200)

    e := echo.New()

    // middlewares
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{&amp;quot;*&amp;quot;},
        AllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},
    }))

    // endpoints
    e.GET(&amp;quot;/&amp;quot;, func(c echo.Context) error {
		    return c.String(http.StatusOK, &amp;quot;Hello, World!&amp;quot;)
  	})
  	e.GET(&amp;quot;/messages&amp;quot;, func(c echo.Context) error {
  		  return handler.NewMessageWithSession(conn.NewSession(nil)).GetMessages(c)
  	})
  	e.POST(&amp;quot;/messages&amp;quot;, func(c echo.Context) error {
  		  return handler.NewMessageWithSession(conn.NewSession(nil)).CreateMessage(c)
  	})
    std := standard.New(&amp;quot;:1323&amp;quot;)
    std.SetHandler(e)
    gracehttp.Serve(std.Server)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dbr-https-github-com-gocraft-dbr&#34;&gt;&lt;a href=&#34;https://github.com/gocraft/dbr&#34;&gt;dbr&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;database/sql&lt;/code&gt;を強化したもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/gocraft/dbr
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;res, err := t.sess.InsertInto(&amp;quot;message&amp;quot;).Columns(&amp;quot;content&amp;quot;).Record(model.Message{Content: content}).Exec()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;glide-https-github-com-masterminds-glide&#34;&gt;&lt;a href=&#34;https://github.com/Masterminds/glide&#34;&gt;glide&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;パッケージ管理ツール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install glide
$ glide create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で&lt;code&gt;glide.yaml&lt;/code&gt;が作られる。&lt;code&gt;glide get&lt;/code&gt;で&lt;code&gt;glide.yaml&lt;/code&gt;に追加していったり、
&lt;code&gt;glide install&lt;/code&gt;でvendor下にインストールしたりする。&lt;/p&gt;

&lt;h3 id=&#34;goose-https-bitbucket-org-liamstask-goose&#34;&gt;&lt;a href=&#34;https://bitbucket.org/liamstask/goose&#34;&gt;goose&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DBマイグレーションツール。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;db/dbconf.yml&lt;/code&gt;に以下のようなyamlファイルを置いて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
  driver: mymysql
  open: tcp:localhost:3306*bbs_go/root/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;goose create&lt;/code&gt;でマイグレーションファイルを作成する。これはgoかsqlで書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get bitbucket.org/liamstask/goose/cmd/goose
$ goose create CreateMessages sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
-- +goose Up
-- SQL in section &#39;Up&#39; is executed when this migration is applied
CREATE TABLE message (
  id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  content TEXT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- +goose Down
-- SQL section &#39;Down&#39; is executed when this migration is rolled back
DROP TABLE message;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ goose up
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;テストの書き方&#34;&gt;テストの書き方&lt;/h2&gt;

&lt;p&gt;参考にした記事と同じく、handler, service, daoで構成し、
それぞれのコンストラクタの引数に直下のレイヤーのインタフェースを取ることでDIする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewMessage(tx dao.Tx, messageDao dao.Message) *MessageImpl {
	return &amp;amp;MessageImpl{tx: tx, messageDao: messageDao}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
テスト時には&lt;a href=&#34;https://github.com/golang/mock&#34;&gt;mock&lt;/a&gt;を渡す。
&lt;code&gt;mockgen&lt;/code&gt;でmockを生成し、以下のようにして入力と出力を指定することができる。
これによってテストでdbを参照するのがdaoだけになり、各パッケージを並行してテストできるようになる、ということが
記事に書いてあった。mockを簡単に用意できるのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/golang/mock/gomock
$ go get github.com/golang/mock/mockgen
$ mockgen -package dao -source message.go -destination message_mock.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;ctl := gomock.NewController(t)
defer ctl.Finish()

message := model.Message{ID: 1, Content: &amp;quot;メッセージ&amp;quot;}
messageDaoMoc := dao.NewMockMessage(ctl)
messageDaoMoc.EXPECT().Create(message.Content).Return(int64(1), nil)
messageDaoMoc.EXPECT().FindById(message.ID).Return(&amp;amp;message, nil)
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
