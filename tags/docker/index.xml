<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sambaiz.net</title>
    <link>http://sambaiz.net/tags/docker/</link>
    <language>ja</language>
    <author>sambaiz</author>
    <rights>(C) 2016</rights>
    <updated>2016-07-18 22:22:00 &#43;0900 JST</updated>

    
      
        <item>
          <title>Kubernatesのチュートリアルをたどる</title>
          <link>http://sambaiz.net/article/9/</link>
          <pubDate>Mon, 18 Jul 2016 22:22:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/9/</guid>
          <description>

&lt;h2 id=&#34;kubernatesとは-http-kubernetes-io-docs-whatisk8s&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/whatisk8s/&#34;&gt;Kubernatesとは&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Kubernates(クバネテスと周りでは呼んでる。ギリシャ語で操舵手)はアプリケーションコンテナにおける、自動デプロイ、スケーリング、操作を
自動化するオープンソースプラットフォームだ。K8sと略される。Googleによって開発が始められた。&lt;/p&gt;

&lt;h2 id=&#34;minikube-https-github-com-kubernetes-minikube&#34;&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;Minikube&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;K8sをローカルで試すためのに、MinikubeというVMの中で単一ノードのK8sクラスターを動かすツールを入れる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube/releases/tag/v0.6.0&#34;&gt;v0.6.0&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.6.0/minikube-darwin-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ minikube start
Starting local Kubernetes cluster...

...

$ kubectl version
Client Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;2&amp;quot;, GitVersion:&amp;quot;v1.2.4&amp;quot;, GitCommit:&amp;quot;3eed1e3be6848b877ff80a93da3785d9034d0a4f&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
Server Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;3&amp;quot;, GitVersion:&amp;quot;v1.3.0&amp;quot;, GitCommit:&amp;quot;283137936a498aed572ee22af6774b6fb6e9fd94&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pods-http-kubernetes-io-docs-user-guide-walkthrough-pods&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/#pods&#34;&gt;Pods&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;K8sではコンテナのグループをpodと呼ぶ。pod中のコンテナは共にデプロイされ、起動し、停止する。
また、グループとして複製される。&lt;/p&gt;

&lt;p&gt;Podの定義は以下のようにyamlで書かれる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podの定義に望ましい状態を記述すると、Kubernatesはそれを見て現在の状態が一致しているかどうか確認する。
例えば、Podが作られたときに、コンテナがその中で動いている状態が望ましい状態だとすると、
コンテナが動かなくなったときに、Kubernatesは新しいものを再作成することで望ましい状態にする。&lt;/p&gt;

&lt;p&gt;podの作成とリストの取得のコマンドは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx.yaml
$ kubectl get pods
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          4s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kubectl exec&lt;/code&gt;で&lt;a href=&#34;http://kubernetes.io/docs/user-guide/getting-into-containers/&#34;&gt;コマンドを実行&lt;/a&gt;し、
podが動いていることを確認しようとしたが、使えそうなコマンドが見つからなかった。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl exec -it nginx ps
rpc error: code = 2 desc = &amp;quot;oci runtime error: exec failed: exec: \&amp;quot;ps\&amp;quot;: executable file not found in $PATH&amp;quot;error: error executing remote command: error executing command in container: Error executing in Docker Container: 126
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そこで、リクエストを投げるために&lt;code&gt;kubectl run&lt;/code&gt;で&lt;a href=&#34;http://kubernetes.io/docs/user-guide/kubectl/kubectl_run/&#34;&gt;イメージを動かす単一コンテナのpodを管理するためのDeploymentを作成する。&lt;/a&gt;
Deploymentについては後で説明がある。
&lt;code&gt;--restart=Never&lt;/code&gt;でpodが存在しなくなったときに再起動しないようにし、&lt;code&gt;--env&lt;/code&gt;で環境変数としてnginxのpodのIPを渡している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run busybox --image=busybox --restart=Never --tty -i --env &amp;quot;POD_IP=$(kubectl get pod nginx -o go-template={{.status.podIP}})&amp;quot;
busybox$ wget -qO- http://$POD_IP
busybox$ exit # Exit the busybox container

$ kubectl get deployments

$ kubectl get pods
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          54m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--restart=Never&lt;/code&gt;なしで実行するとこうなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl run busybox --image=busybox --tty -i --env &amp;quot;POD_IP=$(kubectl get pod nginx -o go-template={{.status.podIP}})&amp;quot;
busybox$ exit
Session ended, resume using &#39;kubectl attach busybox-985443498-9elny -c busybox -i -t&#39; command when the pod is running

$ kubectl get deployments
NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
busybox   1         1         1            1           3m

$ kubectl get pods
NAME                      READY     STATUS    RESTARTS   AGE
busybox-985443498-9elny   1/1       Running   1          3m
nginx                     1/1       Running   0          59m

$ kubectl delete pods busybox-985443498-9elny
pod &amp;quot;busybox-985443498-9elny&amp;quot; deleted

$ kubectl get pods # Podsだけ削除しても新しいものが立ち上がってくる
NAME                      READY     STATUS              RESTARTS   AGE
busybox-985443498-4iyvx   0/1       ContainerCreating   0          1s
busybox-985443498-9elny   1/1       Terminating         1          13m
nginx                     1/1       Running             0          1h

$ kubectl delete deployment busybox

$ kubectl get pods # Deploymentを削除するとPodsも消える
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          1h
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;volumes-http-kubernetes-io-docs-user-guide-walkthrough-volumes&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/#volumes&#34;&gt;Volumes&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;コンテナのファイルシステムはコンテナが生存しているときに限り有効なので、
永続化したいデータはコンテナの外に保存する必要がある。&lt;/p&gt;

&lt;p&gt;以下の例のように&lt;code&gt;volumes&lt;/code&gt;でvolumeを定義し、&lt;code&gt;volumeMounts&lt;/code&gt;でどこにマウントするか指定することができる。
&lt;code&gt;volumes&lt;/code&gt;には、そのPodがノードで実行されている間存在するディレクトリを作成して使う&lt;code&gt;EmptyDir&lt;/code&gt;か、
ノードのファイルシステムに既に存在するディレクトリを使う&lt;code&gt;HostPath&lt;/code&gt;を指定する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis
    volumeMounts:
    - name: redis-persistent-storage
      mountPath: /data/redis
  volumes:
  - name: redis-persistent-storage
    emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;labels-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-labels&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#labels&#34;&gt;Labels&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;metadataとしてkey-valueのラベルを付けることができる。たくさんのPodをまとめたりするのに便利だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;metadata:
  name: nginx
  labels:
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;kubectl get pods -l app=nginx
NAME      READY     STATUS    RESTARTS   AGE
nginx     1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;deployments-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-deployments&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#deployments&#34;&gt;Deployments&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;実行しているPodの維持と更新を管理するのが、上でも出てきたDeploymentだ。
Deploymentの定義には、Podを作るためのテンプレートと、維持するPod数を記述する。
pod名はDeployment名から生成されるので、templateには含めない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f deployment.yaml
$ kubectl get deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2         2         2            2           3m

$ kubectl get pods -l app=nginx
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1159050644-ar3i7   1/1       Running   0          3m
nginx-deployment-1159050644-kdjly   1/1       Running   0          3m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kubectl apply&lt;/code&gt;でDeploymentは変更を実行中のPodに安全にロールアウトする。
以下の例ではnginxのバージョンを上げている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.8
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl apply -f deployment-update.yaml
$ kubectl get pods
NAME                                READY     STATUS              RESTARTS   AGE
nginx-deployment-1159050644-kdjly   1/1       Running             0          30m
nginx-deployment-1771418926-pi3vy   0/1       ContainerCreating   0          7s
nginx-deployment-1771418926-ygoxl   0/1       ContainerCreating   0          7s

$ kubectl get pods
NAME                                READY     STATUS              RESTARTS   AGE
nginx-deployment-1771418926-pi3vy   0/1       ContainerCreating   0          12s
nginx-deployment-1771418926-ygoxl   1/1       Running             0          12s

$ kubectl get pods
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1771418926-pi3vy   1/1       Running   0          15s
nginx-deployment-1771418926-ygoxl   1/1       Running   0          15s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;services-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-services&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#services&#34;&gt;Services&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;アプリケーションのレイヤー間(例えばフロントエンドとバックエンド)の接続で使われるのがServiceだ。
以下のServiceは、8080番ポートで待ち、&lt;code&gt;app: nginx&lt;/code&gt;のラベルが付いているPodの80番ポートに向けるロードバランサーとして働く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  ports:
  - port: 8000
    targetPort: 80
    protocol: TCP
  selector:
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f service.yaml
$ kubectl get services
NAME            CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
kubernetes      10.0.0.1     &amp;lt;none&amp;gt;        443/TCP    19h
nginx-service   10.0.0.90    &amp;lt;none&amp;gt;        8000/TCP   36s

$ export SERVICE_IP=$(kubectl get service nginx-service -o go-template=&#39;{{.spec.clusterIP}}&#39;)
$ export SERVICE_PORT=$(kubectl get service nginx-service -o go-template=&#39;{{(index .spec.ports 0).port}}&#39;)
$ echo &amp;quot;$SERVICE_IP:$SERVICE_PORT&amp;quot;
10.0.0.90:8000
$ kubectl run busybox --image=busybox --restart=Never --tty -i --env &amp;quot;SERVICE_IP=$SERVICE_IP,SERVICE_PORT=$SERVICE_PORT&amp;quot;
busybox$ wget -qO- http://$SERVICE_IP:$SERVICE_PORT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;health-checking-http-kubernetes-io-docs-user-guide-walkthrough-k8s201-health-checking&#34;&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/walkthrough/k8s201/#health-checking&#34;&gt;Health Checking&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;livenessProbe&lt;/code&gt;でヘルスチェックの設定を含めることができる。
以下の例では、初期化のために30秒待った後、&lt;code&gt;/_status/healthz&lt;/code&gt;へのHTTP GETリクエストに対して
200~399以外のステータスコードが返るか、1秒以上かかった場合、コンテナを再起動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: pod-with-healthcheck
spec:
  containers:
  - name: nginx
    image: nginx
    livenessProbe:
      httpGet:
        path: /_status/healthz
        port: 80
      initialDelaySeconds: 30
      timeoutSeconds: 1
    ports:
    - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Docker公式ドキュメント&#34;network コマンドを使う&#34;をまとめた</title>
          <link>http://sambaiz.net/article/7/</link>
          <pubDate>Fri, 15 Jul 2016 00:38:00 &#43;0900</pubDate>
          <author></author>
          <guid>http://sambaiz.net/article/7/</guid>
          <description>&lt;pre&gt;&lt;code&gt;Docker version 1.12.0-rc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公式ドキュメント&lt;a href=&#34;http://docs.docker.jp/engine/userguide/networking/work-with-networks.html&#34;&gt;network コマンドを使う&lt;/a&gt;
の内容をまとめてみた。&lt;/p&gt;

&lt;p&gt;dockerには3つのデフォルトネットワークが存在する。&lt;code&gt;docker run&lt;/code&gt;時に&lt;code&gt;--net&lt;/code&gt;オプションでネットワークを指定しない限り、
docker0として表示されるbridgeネットワークにコンテナを接続する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
a3b712537566        bridge              bridge              local               
f6d86cb54edd        host                host                local               
33cb30b024d9        none                null                local            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ただし、後方互換性を維持するため、デフォルトのbridgeネットワークでは自動的に名前解決が行われない。&lt;/p&gt;

&lt;p&gt;これらのネットワークとは別にユーザー定義のネットワークを作成することもできる。
単一ホストの&lt;code&gt;bridge&lt;/code&gt;ネットワークと、複数ホストにまたがる&lt;code&gt;overlay&lt;/code&gt;ネットワークから選択でき、
何も指定しなかったら&lt;code&gt;bridge&lt;/code&gt;になる。&lt;code&gt;subnet&lt;/code&gt;を指定しなければ、
dockerデーモンがネットワークに対してサブネットを自動的に割り当てるが、
dockerが管理していないサブネットと重複するのを避けるために指定することが推奨されている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker network create -d bridge --subnet 172.25.0.0/16 isolated_nw
$ docker network inspect isolated_nw
$ docker network rm isolated_nw  # 削除
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;docker network inspect&lt;/code&gt;で以下のようなネットワークの情報が得られる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {
        &amp;quot;Name&amp;quot;: &amp;quot;isolated_nw&amp;quot;,
        &amp;quot;Id&amp;quot;: &amp;quot;c81547cf7ed897054ea645192c6c47dcf7a248e77bc8067609becab5330e417d&amp;quot;,
        &amp;quot;Scope&amp;quot;: &amp;quot;local&amp;quot;,
        &amp;quot;Driver&amp;quot;: &amp;quot;bridge&amp;quot;,
        &amp;quot;EnableIPv6&amp;quot;: false,
        &amp;quot;IPAM&amp;quot;: {
            &amp;quot;Driver&amp;quot;: &amp;quot;default&amp;quot;,
            &amp;quot;Options&amp;quot;: {},
            &amp;quot;Config&amp;quot;: [
                {
                    &amp;quot;Subnet&amp;quot;: &amp;quot;172.25.0.0/16&amp;quot;
                }
            ]
        },
        &amp;quot;Internal&amp;quot;: false,
        &amp;quot;Containers&amp;quot;: {},
        &amp;quot;Options&amp;quot;: {},
        &amp;quot;Labels&amp;quot;: {}
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起動時に&lt;code&gt;--net&lt;/code&gt;オプションでネットワークに接続したり、
既に存在するコンテナを&lt;code&gt;docker network connect&lt;/code&gt;で接続することができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=isolated_nw -itd --name=container1 --link container2:c2 busybox
$ docker network connect isolated_nw container1
$ docker network disconnect isolated_nw container1 # 切断
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の&lt;code&gt;run&lt;/code&gt;によって同一ネットワークからこのコンテナへ、&lt;code&gt;ping container1&lt;/code&gt;が届くようになり、
このコンテナから同一ネットワークのconteiner2にc2というエイリアスが付くため、&lt;code&gt;ping c2&lt;/code&gt;が届くようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker attach container1
# ping c2
PING c2 (172.25.0.2): 56 data bytes
64 bytes from 172.25.0.2: seq=0 ttl=64 time=0.094 ms
...
CTRL-p CTRL-q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定時点でcontainer2が存在しなかったとしてもエラーにならない。
また、この&lt;code&gt;--link&lt;/code&gt;によるエイリアスは所属するネットワーク全体に適用される。&lt;/p&gt;

&lt;p&gt;他にrunで指定している&lt;a href=&#34;http://docs.docker.jp/engine/reference/commandline/run.html&#34;&gt;オプション&lt;/a&gt;は以下の通り。
どれも良く使うもの。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-i コンテナの STDIN にアタッチ
-t 疑似ターミナル (pseudo-TTY) を割り当てる
-d コンテナをバックグラウンドで実行し、コンテナIDを表示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--link&lt;/code&gt;は、コンテナ内におけるプライベートな名前解決のために、他のコンテナの&lt;code&gt;name&lt;/code&gt;に対してエイリアスを付けるものだったが、
これとは別に同一ネットワークの他のコンテナからの名前解決のために使われる、ネットワーク範囲のエイリアスを&lt;code&gt;--net-alias&lt;/code&gt;で付けることができる。
このエイリアスは同一ネットワークの複数のコンテナで同じものに設定でき、有効ないずれかのコンテナに名前解決される。
つまり、コンテナが停止するかネットワークから切断されると、同じネットワーク範囲のエイリアスを持った別のコンテナに名前解決されることになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --net=isolated_nw -itd --name=container3 --net-alias app busybox
$ docker run --net=isolated_nw -itd --name=container4 --net-alias app busybox
$ docker network connect --alias app isolated_nw container5 # connectで指定するとき
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    

  </channel>
</rss>
